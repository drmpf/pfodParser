<!--
================================================================================
  STANDALONE BUNDLE: pfodWebDebug.html
  Generated: 2025-10-20T19:42:26.588Z

  This file contains all JavaScript inlined for standalone deployment.
  No external files or webserver required - just open in browser!

  For development, edit the separate source files and rebuild.

  Build command: node build-bundle.js

  (c)2025 Forward Computing and Control Pty. Ltd.
  NSW Australia, www.forward.com.au
================================================================================
-->
<!DOCTYPE html>
<!--
   pfodWebDebug.html
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
-->

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pfodWeb</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: white;
        }
        #layout-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            overflow: hidden;
        }
        #canvas-pane {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            background-color: white;
            overflow: auto;
        }
        #resize-divider {
            width: 6px;
            background-color: #ccc;
            cursor: col-resize;
            flex-shrink: 0;
            border-left: 1px solid #999;
            border-right: 1px solid #999;
            transition: background-color 0.2s;
        }
        #resize-divider:hover {
            background-color: #999;
        }
        #resize-divider.dragging {
            background-color: #0066cc;
        }
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        #white-border {
            background-color: white;
            border-radius: 20px;
            padding: 3px;
            border-width: 2px;
        }
        #black-border {
            background-color: black;
            border-radius: 18px;
            padding: 3px;
            border-width: 2px;
        }
        #border-inner {
            background-color: white;
            border-radius: 16px;
            padding: 5px;
            border-width: 3px;
        }
        canvas {
            background-color: #0000ff;
            display: block;
            padding: 0px;
            width: 100%;
            height: 100%;
        }
        #message-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        #message-overlay h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #333;
        }
        #message-overlay p {
            font-size: 16px;
            margin-bottom: 15px;
            color: #666;
            max-width: 600px;
        }
        #connection-prompt {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            z-index: 2000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .prompt-container {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 90%;
            text-align: center;
        }
        .prompt-container h2 {
            color: blue;
            margin-bottom: 20px;
        }
        .protocol-selector {
            margin: 20px 0 10px 0;
        }
        .protocol-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
        }
        .protocol-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .protocol-option input[type="radio"] {
            cursor: pointer;
        }
        .protocol-option label {
            cursor: pointer;
            font-size: 16px;
        }
        .connection-details {
            margin: 20px 0;
        }
        .connection-details input[type="text"],
        .connection-details select {
            width: 100%;
            max-width: 300px;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin: 10px 0;
        }
        .connection-details button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 16px;
            border: none;
            cursor: pointer;
            margin: 10px 5px;
        }
        .connection-details button:hover {
            background-color: #45a049;
        }
        .connection-details button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
        }
        .connection-details button:disabled:hover {
            background-color: #cccccc;
        }
        .connection-details .help-text {
            color: #666;
            font-size: 14px;
            margin: 5px 0 10px 0;
        }
        .protocol-section {
            display: none;
        }
        .protocol-section.visible {
            display: block;
        }
        .hidden {
            display: none;
        }
    </style>
<link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,AAABAAEAQD0AAAEAGADQLwAAFgAAACgAAABAAAAAegAAAAEAGAAAAAAAAAAAAGAAAABgAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////////////////////////////////////////v7+/v7+/Pz9+vr8+fn8+fn8+fn8+vr9+vr+/Pz+/v7//v7////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8/v707u7s4eHl0dHgyMjdxsbfxsbgysrlz8/s39/07e39+/v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7+vrp2NjTqqq9f3+sWFiiOjqaJyeXGhqTDw+SDw+SDw+TDw+XGBiaJyegOjqrWFi8fHzRqqro19f5+vr////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////q29vKnJysWVmZIyORBgaPAACRAACSAACUAACVAACWAACWAACWAACWAACVAACUAACSAACRAACPAACRAACXIiKrU1PJmJjp19f////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+///iyMi5eHidLS2RAACRAACUAACWAACYAACYAACYAACYAACXAACXAACXAACXAACXAACXAACYAACYAACYAACYAACWAACUAACRAACPAACaJye4c3PfxcX9///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////m0tK4dnaYIiKPAACSAACWAACYAACYAACWAACUAACTAACQAACPAACQAACQAACRAACRAACSAACQAACPAACQAACTAACUAACWAACYAACYAACXAACTAACPAACXHBy2b2/jzc3////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////z6+vEj4+cLCyOAACTAACXAACYAACWAACTAACPAACSBgaaJSWmSkq1bW3CjIzMoaHUr6/UsbHUsbHTr6/MoqLCjIy3cXGnTU2ZJyeTBgaPAACTAACWAACYAACXAACTAACPAACbJyfBiYnw6Oj////////////////////////////////////////////////////////////////////////////////////////////////////////////ex8eqU1OSBgaTAACXAACYAACWAACSAACRAACeLy+2b2/Sra3q29v69/f////////////////////////////////////////5+vrr3t7VsbG5c3OdMzORAACSAACVAACYAACXAACSAACRAACpTk7cv7/////////////////////////////////////////////////////////////////////////////////////////////////+/v7OoaGcLS2PAACVAACXAACWAACSAACSCQmkRUXImJjr39/////////////////////////////////////////////////////////////////////////u4eHLnJynS0uTBgaSAACWAACYAACVAACPAACaJyfKmJj7/Pz////////////////////////////////////////////////////////////////////////////////////49/fDjIyVFBSSAACXAACXAACTAACRAACiPDzLnJzx6ur////////////////////////////////////////////////////////////////////////////////////////07u7OpKSkQ0OQAACTAACXAACXAACTAACTEhLAhIT39PT////////////////////////////////////////////////////////////////////////////59va/goKSDAySAACXAACWAACRAACXGhq9fX3s39/////////////////////////////////////////////////////////////////////////////////////////////////////////v5OTAhYWYHh6RAACWAACXAACTAACTBga8e3v28/P////////////////////////////////////////////////////////////////////8/f3Bh4eSDAyTAACYAACVAACQAACiPDzWs7P////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////XubmlRUWPAACVAACXAACTAACTCQm9fn76+fn////////////////////////////////////////////////////////////////LnZ2UEhKSAACXAACVAACQAACrVFTl1NT////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////p2NiwXl6RAACUAACXAACTAACTDAzHlJT////////////////////////////////////////////////////////////cv7+bKCiTAACXAACVAACSAACxY2Pt4uL////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////x6em0aWmRAACVAACXAACTAACXHh7Wt7f////////////////////////////////////////////////////w5eWnS0uPAACXAACWAACPAACuXFzu4+P////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////x6uqxZGSQAACWAACXAACRAACkQkLs3t7////////////////////////////////////////////////AhISSAACVAACXAACRAAClQkLo2dn////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////s3t6pTU2QAACXAACWAACPAAC6eXn+/v7////////////////////////////////////////fyMiYIiKSAACYAACTAACZIiLbvLz////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////exsacKCiSAACYAACTAACYHBzbvb3////////////////////////////////////6+fmyZWWQAACXAACWAACUBgbGkJD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////HlZWSCQmVAACXAACPAACuWlr49fX////////////////////////////////ZurqVFBSUAACXAACRAACsUFHl2uK6mqCqd3WocHLRr6b////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////z7u6rU1OQAACXAACVAACTEhLVsrL////////////////////////////9//+0ZmaPAACXAACVAACUDAzZtrT1/P+EPEtuAABsAAC2e2z////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Yt7eWFhaUAACYAACQAACuXl77+vr////////////////////////k0dGYIiKTAACYAACRAACsVlb///74//+KQ1J2AAB1AAC7h3j////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6+vqwYWGQAACYAACUAACXGhrgycn////////////////////////GkJCQAACXAACWAACTCQnSra3////1/P+KQ1J3AAB1AAC8iHn////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////YtbWTEhKVAACXAACPAADAhob////////////////////6+vqpU1ORAACYAACSAACjPT3y6+v////z+P+KQ1J3AAB1AAC9i3v////////////+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////07++lRUWTAACYAACSAAClRUX38/P////////////////p2NiZIyOUAACYAACQAAC7fX3////////y9/+KQ1J3AAB4AADDlIX////XyM6qfYGcYGCla2jEn5nv5+L////////////////////////////////UwsXJra3Ms7PIrKzn19L////////////////////////9///SvcHKrq3MsrLLrKzv493////////////////////////////////////Bh4ePAACXAACUAACXGhrjz8/////////////////UsrKSBgaWAACWAACTBgbUs7P////////y9/+KQ1J3AAB7AACxemy5lZp7FBxrAABtAABuAAB1AACXSkLhysH////////////////////////s7vaHPktxAAB2AABwAACwc2b////////////////////////m5OyALzpzAAB1AABzAADFmIn////////////////////////////////////bvb2TDAyWAACXAACQAADQqKj////////////////Di4uPAACXAACUAACaJyfr3d3////////y9/+KQ1J4AAB8AACBEg95AAZ/GBSZU1CSSkt8DxR0AAB0AACVRTrs3dT////////////////////c1997HCd5AAB9AAB0AACYSDz89e/////////////////////Pw893Dxh6AAB8AABzAACucWT////////////////////////////////////u4+OcLCyUAACYAACPAAC+goL///////////////+0a2uPAACYAACSAACjQkL59PT////////y9/+KQ1J4AAB8AAB3AACbUEbj08r////4/P3BqLJ+Hih1AAB1AAC4gXb////////////////////DsLx1Bgx9AAB/AAB5AACCHhTn1Mn///////////////////+ykqF1AAB+AAB/AAB3AACWQzf58uz////////////////////////////////5+vqoTEyTAACYAACQAACyY2P//////////v7+//+sVlaRAACYAACSAACuXFz+///////////y9/+KQ1J4AAB5AACGIxrgysH///////////////+lfYl1AAB1AACQNiz06t////////////////+ogI90AAB/AACAAAB8AAB4AADLo5f////////////////5//+WX212AAB/AAB/AAB5AACCHBTn1Mj///////////////////////////////////+xZWWRAACYAACSAACoTk76+fn//v7+/v759/elSEiRAACYAACQAAC1a2v////////////y9/+KQ1J3AAB3AACiXlD///n////////////////Kvcl5DBZ3AAB9EgngyL3////////////2+/+RUWF2AAB+AAB+AAB9AAB0AACub2H////////////////k5O2DMDp4AAB9AAB9AAB7AAB5AADOqZr///////////////////////////////////+6eHiPAACYAACSAACjPj717+/+/v7+/v738PCjPz+SAACYAACPAAC4d3f////////////y9/+KQ1J3AAB2AAC2gHH////////////////////b1+F7Hih5AAB5AADTr6L////////////g3+mAKDV4AAB/AACJKCd9BgZ2AACSPDL37uX////////////Iucd3CRR4AACJIyOLLTV7AAB1AACzeWn///////////////////////////////////++g4OQAACYAACTAACfNzfy6+v+/v7+/v717++jPT2SAACYAACPAAC5eHj////////////y9/+KQ1J3AAB2AAC+kIH////////////////////g3uh9Iy95AAB3AADMpJX////////////HusZ3DBJ4AACIIxi1i4qEKjV2AAB/FAzhyLz///////////+rhpZ0AAB4AACtcGStg4p5AAB1AACYSz/89u////////////////////////////////+/hoaPAACYAACTAACfMzPz6ur+/v7+/v748fGiQUGRAACYAACPAAC4c3P////////////y9/+KQ1J3AAB2AAC9jX3////////////////////c2uR7Hih5AAB2AADPqpn///////////+ui5l1AAB2AACVQjXm3NqTVWN1AAB2AADDloj////////1/P+QUmF1AAB5AADQrZ7Owcx4CRR2AACFIhjq2c3///////////////////////////////++f3+OAACYAACSAACgOTn07Oz+/v7//v76+fmoTk6SAACYAACRAACzZ2f////////////y9/+KQ1J3AAB2AACuc2X////////////////////Ows56Dxh4AAB6CQDZvLH////////4//+TW2h2AAB1AACoZlb///+qhZR0AAB0AAClYVL///v////h3eV/JzJ0AACBGA/s2c3n6vN9Iy93AAB6BgDTsKT///////////////////////////////+3cHCQAACYAACRAACkQ0P48/P+/v7///////+vX1+RAACYAACTAACpUVH8/f3////////y9/+KQ1J4AAB4AACRPTLz5+D///////////////+shZZ2AAB1AACIJxzu3tH////////m5fCCMjx3AAB2AADAjoD////FtsV2Bg90AACLMCf0597////Dsr52Bg91AACSPDD++e74//+LRVN2AAB0AAC4gHL///////////////////////////////+tWlqSAACYAACSAACrWFj9/f3//v7///////+6enqOAACYAACTAACeNTX07e3////////y9/+KQ1J4AAB6AAB5AACzfG/49fD////////NvcaCLTV2AAB0AACqaFz//fn////////Owc15EhZ4AAB5BgDWtaf////h4el/KDJ2AAB8DAbfwbT///+mf45zAAB0AACral7///////+gcX90AAB1AACbUEL8+fP////////////////////////08vKiPDySAACYAACPAAC2cHD////////////////KmZmQAACXAACVAACWGBjlz8/////////y9v6JQVB2AAB8AACEIiJ3BgmUQz6wg4OlcnaCJSx0AABzAACHJyDexLv///////////+zlKJ1AAB3AACFIhbs2c/////3/P+TVWV1AAB1AADDlIT5//+PUWB2AAB3AADHm4////////+3nax0AAB3AACIJxzt3dT////////////////////////n19eXHh6VAACXAACPAADGj4/////////////////cwsKTDw+VAACXAACRAADKoKD////////t7fiCNUVsAAB4AADAk4mmdn5wAABsAABvAABwAAByAACHJyDMqZ/////////////7//+aZnR1AAB2AACXRTn69e3///////+tjJp0AAB0AACoYVXXyc2BKjV1AACAFAniy73////////RxtN5FBp4AAB5CQDVtqj////////////////////////RqamSBgaXAACWAACRCQnYuLj////////////////x6emdMzOSAACYAACQAACwZGT////////09vu4lJqufn2zg4Hu4Nb5//+/o6yWU1mHNTaPPjyqdG3cycH////////////////r7fSEOUV3AAB0AACtcWP////////////LwMp4DBZ3AACLLSOia219DBR2AACQOi317OT////////p6fCCNT93AAB1AAC5hXj///////////////////////+0bW2PAACYAACTAACbLCzt39////////////////////+za2uPAACYAACUAACaJyfn1NT////////////////////////////////5+vzx7u/28vH////////////////////////Uy9V6FBx5AAB4AADHm4/////////////p6fCEN0F3AAB/AACAFBR7AAB1AACpal3////////////5/v+UXGp2AAB2AACfVUr//fb////////////////r3NycLS2TAACYAACQAACvYWH9///////////////////////SrKySBgaWAACXAACPAADDiYn///////////////////////////////////////////////////////////////////+5oKt2AAZ5AAB+Egzfxrn////////////7//+aZ3V1AAB+AAB/AAB9AAB2AADHmo7///////////////+siJh1AAB2AACKLCDv4Nj////////////////Hk5OQAACWAACWAACSAADOoqL////////////////////////x6OiiPDyTAACYAACTAACfNTXr3d3////////////////////////////////////////////////////////////9//+eb352AAB2AACLMiXy5d3///////////////+4m6l2AAB+AAB/AAB6AAB/FAzgybz////////////////EtMB2Bgx5AAB6CQbauqz////////////v5OSjPj6TAACYAACSAACeMjLt4OD////////////////////////////Djo6QAACWAACWAACRAADAg4P////////////////////////////////////////////////////////////q6vGCMj5vAABuAACcTT79+/L////////////////SyNN0DBZ0AAB3AABvAACLLyP06eD////////////////Z1N94FiBxAABtAAC4f3H////////////FkJCRAACWAACXAACPAAC9fn7////////////////////////////////q2tqeMjKTAACYAACSAACbJyfgyMj////////////////////////////////////////////////////////f1t+VVFuTSEeRSkq/kYf////////////////////s6/KdZm6US0yWU1OSSEq1f3b//Pb////////////////v7vWfaXGTSEqQRUK1fXP/+/j////kz8+dLy+TAACYAACSAACcLCzm0tL////////////////////////////////////EjY2RAACVAACXAACPAACuXV317u7////////////////////////////////////////////////////9///39PT8/fz5+Pn+/Pv////////////////////////5+fn8/Pv9///6+vv7+/j////////////////////////5+Pn7/Pv5+vr6+fj////49veyZmaQAACXAACWAACQAAC+goL////////////////////////////////////////w5+emRkaRAACXAACVAACTBgbDiYn+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Hk5OTDAyUAACXAACSAACiPDzt3t7////////////////////////////////////////////VsLCXGBiTAACXAACSAACYGhrRp6f////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VsLCYHh6UAACXAACTAACUEhLPp6f////////////////////////////////////////////////8//++fn6SAACVAACXAACSAACaKCjWs7P////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////au7ufMjKSAACXAACVAACRAAC4cXH6+fn////////////////////////////////////////////////////w5uarU1OQAACWAACXAACRAACcLCzVra3////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////YtLSfNTWRAACXAACWAACPAACoSkrs4OD////////////////////////////////////////////////////////////k0NCjPDyQAACWAACXAACSAACYIiLGlZX4+Pj////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7+vrLnZ2ZIyORAACXAACXAACRAACeNTXgyMj////////////////////////////////////////////////////////////////////cwMCfMjKQAACWAACXAACUAACTDw+1bW3q2Nj////////////////////////////////////////////////////////////////////////////////////////////////////////////////s39+5d3eUEhKTAACXAACXAACRAACeLCzZuLj////////////////////////////////////////////////////////////////////////////avb2gNzePAACWAACXAACUAACRAAChOTnMoaH18PD////////////////////////////////////////////////////////////////////////////////////////////////48/PPpaWjPT2QAACUAACXAACWAACQAACdMDDYt7f////////////////////////////////////////////////////////////////////////////////////gyMimSkqQAACUAACXAACWAACSAACTCQmpUFDSrKz18PD////////////////////////////////////////////////////////////////////////////////48vLUsrKsVVWSDAySAACWAACXAACUAACPAACkQUHbwMD////////////////////////////////////////////////////////////////////////////////////////////r3Ny0aWmSDAyTAACWAACYAACVAACRAACSDAynS0vImJjo2dn9/f3////////////////////////////////////////////////////////////p29vLnJypUFCTDw+QAACVAACYAACXAACTAACTBgaxZGTo1tb////////////////////////////////////////////////////////////////////////////////////////////////////49PTKm5udMjKPAACTAACXAACYAACVAACSAACQAACaJyetXV3FkJDbvLzq3Nz17u77+/v////+///+///////7+/v08fHr3t7cvr7Hk5OuXV2bKCiRAACRAACVAACYAACXAACUAACPAACcLCzHlJT38fH////////////////////////////////////////////////////////////////////////////////////////////////////////////////m09O4cnKWGBiPAACUAACXAACYAACXAACUAACRAACQAACSDAyYIyOfOTmnTU2tWVmuW1uuW1utWVmnTU2hOjqZJyeTDAyPAACRAACTAACWAACYAACXAACUAACPAACVFha0a2vjzs7////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/v7avr6yZGSWGBiPAACSAACWAACYAACYAACXAACWAACVAACTAACTAACSAACRAACRAACSAACTAACTAACUAACWAACXAACYAACYAACWAACSAACQAACVFBSuXl7Yubn8+vr////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8+/vfxMS5dnacMDCRBgaPAACSAACVAACXAACYAACYAACYAACYAACYAACYAACYAACYAACYAACYAACXAACVAACSAACPAACRAACdLCy4cXHbvr75+fn////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////t4uLRq6u2bm6iOjqVGBiRAACPAACOAACQAACRAACSAACSAACSAACQAACPAACOAACRAACVFhagOTmzbGzQpaXr4OD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////z7+/kz8/TrKzEj4+5eHiyZGSsWVmpU1OnU1OqVlawYWG3dnbDjY3Rq6vkzMz07Oz////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+/v79/v77/v7+/v7//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////v7//v7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==">
</head>
<body>
    <div id="layout-container">
        <div id="canvas-pane">
            <div id="canvas-container">
                <div id="white-border">
                    <div id="black-border">
                      <div id="border-inner">
                        <canvas id="drawing-canvas" width="300" height="100"></canvas>
                    </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="resize-divider"></div>
        <div id="raw-message-viewer"></div>
    </div>

    
<!-- All JavaScript files combined inline -->
<script>
// Set flag to indicate this is a bundled version (prevents dynamic script loading)
window.PFODWEB_BUNDLED = true;


/* ========================================
 * Inlined from: version.js
 * ======================================== */
// Shared constants to avoid circular dependencies
  var JS_VERSION = "V2.0.0 -- 13th October 2025";
// V2.0.0 removed nodejs server, bundled all files in single htmls
// V1.1.5 added init() of drawings
// V1.1.4 added pfodMainDrawing.h generated file
// V1.1.3 dwg updates as response received

// Make available globally for browser use
if (typeof window !== 'undefined') {
    window.JS_VERSION = JS_VERSION;
}

// Export for Node.js use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { JS_VERSION };
}


/* ========================================
 * Inlined from: connectionManager.js
 * ======================================== */
/*
   connectionManager.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

/**
 * Custom alert modal with pfodWeb branding
 * Shows a styled modal dialog positioned lower on the page
 * @param {string} message - The message to display
 * @param {function} onClose - Optional callback when Close button is clicked
 */
function pfodAlert(message, onClose = null) {
  // Create modal overlay
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding-top: 150px;
    z-index: 10000;
  `;

  // Create modal box
  const modal = document.createElement('div');
  modal.style.cssText = `
    background-color: white;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    overflow: hidden;
  `;

  // Create title bar
  const titleBar = document.createElement('div');
  titleBar.style.cssText = `
    background-color: #4CAF50;
    color: white;
    padding: 15px 20px;
    font-size: 18px;
    font-weight: bold;
    font-family: Arial, sans-serif;
  `;
  titleBar.textContent = 'pfodWeb';

  // Create message area
  const messageArea = document.createElement('div');
  messageArea.style.cssText = `
    padding: 20px;
    font-family: Arial, sans-serif;
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-line;
  `;
  messageArea.textContent = message;

  // Assemble modal
  modal.appendChild(titleBar);
  modal.appendChild(messageArea);

  // Add Close button if callback provided
  if (onClose) {
    const buttonArea = document.createElement('div');
    buttonArea.style.cssText = `
      padding: 0 20px 20px 20px;
      text-align: center;
    `;

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.style.cssText = `
      background-color: #4CAF50;
      color: white;
      padding: 10px 30px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      font-family: Arial, sans-serif;
    `;
    const closeAction = () => {
      document.body.removeChild(overlay);
      onClose();
    };
    closeButton.onclick = closeAction;

    // Add Enter key handler for the overlay
    overlay.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        closeAction();
      }
    });

    buttonArea.appendChild(closeButton);
    modal.appendChild(buttonArea);

    // Focus the close button so Enter key works immediately
    setTimeout(() => closeButton.focus(), 100);
  }

  overlay.appendChild(modal);

  // Add to page
  document.body.appendChild(overlay);
}

/**
 * Shared dedup mechanism - used by all connection protocols
 * Rotating character prepended to commands to detect duplicates
 * Only increments on successful sends, not on retries
 */
let dedupCounter = 0;
const dedupChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

function getCurrentDedupChar() {
  return dedupChars[dedupCounter];
}

function advanceDedupChar() {
  dedupCounter = (dedupCounter + 1) % dedupChars.length;
}

/**
 * Find the index of the closing brace that matches the opening brace at startIdx
 * Handles nested braces by counting depth
 * @param {string} text - The text to search
 * @param {number} startIdx - Index of opening brace
 * @returns {number} Index of matching closing brace, or -1 if not found
 */
function findMatchingClosingBrace(text, startIdx) {
  if (startIdx < 0 || startIdx >= text.length || text[startIdx] !== '{') {
    return -1;
  }

  let depth = 0;
  for (let i = startIdx; i < text.length; i++) {
    if (text[i] === '{') {
      depth++;
    } else if (text[i] === '}') {
      depth--;
      if (depth === 0) {
        return i;
      }
    }
  }
  return -1; // No matching closing brace found
}

/**
 * ConnectionManager - Unified connection abstraction for multiple protocols
 *
 * Provides a protocol-agnostic interface for communicating with pfod devices.
 * Currently supports: HTTP, Serial, BLE
 */
class ConnectionManager {
  // Static message collector shared across all connection managers
  static messageCollector = null;

  static setMessageCollector(collector) {
    ConnectionManager.messageCollector = collector;
    console.log('[CONNECTION_MANAGER] Message collector set');
  }

  constructor(config = {}) {
    this.protocol = config.protocol || 'http';
    this.adapter = null;
    this.config = config;

    // Response timeout configuration
    // Default is 3 seconds, configurable from 0 (never, actually 60sec) to 30 seconds
    // Timeout value in seconds from config, default to 3
    const timeoutSeconds = config.responseTimeoutSec !== undefined ? config.responseTimeoutSec : 3;

    // Validate and constrain timeout: 0-30 seconds
    let validatedTimeout = Math.max(0, Math.min(30, timeoutSeconds));

    // Convert to milliseconds, with special case: 0 means "never" (use 60 seconds)
    if (validatedTimeout === 0) {
      this.responseTimeoutMs = 60000;  // 60 seconds for "never"
      console.log(`[CONNECTION_MANAGER] Response timeout set to 0 (never) - using 60 seconds actual timeout`);
    } else {
      this.responseTimeoutMs = validatedTimeout * 1000;
      console.log(`[CONNECTION_MANAGER] Response timeout set to ${validatedTimeout} seconds`);
    }

    // Set up max retries based on protocol
    // BLE = 0 (unreliable, fail fast)
    // HTTP = 0 (fail fast for network)
    // Serial = 1 (most reliable, allow one retry)
    const retryConfig = {
      'ble': 0,
      'http': 2,
      'serial': 2
    };
    // Use explicit check for protocol key to handle 0 values correctly, default to 0
    this.maxRetries = (this.protocol in retryConfig) ? retryConfig[this.protocol] : 0;
    console.log(`[CONNECTION_MANAGER] Max retries set to ${this.maxRetries} for protocol: ${this.protocol}`);

    console.log(`[CONNECTION_MANAGER] Creating connection manager with protocol: ${this.protocol}`);

    // Initialize the appropriate protocol adapter
    this.initializeAdapter();
  }

  initializeAdapter() {
    switch(this.protocol) {
      case 'http':
        this.adapter = new HTTPConnection(this.config, this);
        console.log(`[CONNECTION_MANAGER] Initialized HTTP adapter with targetIP: ${this.config.targetIP}`);
        break;

      case 'serial':
        this.adapter = new SerialConnection(this.config, this);
        console.log(`[CONNECTION_MANAGER] Initialized Serial adapter`);
        break;

      case 'ble':
        this.adapter = new BLEConnection(this.config, this);
        console.log(`[CONNECTION_MANAGER] Initialized BLE adapter`);
        break;

      default:
        throw new Error(`Unknown protocol: ${this.protocol}`);
    }
  }

  /**
   * Send a command to the device and get response
   * @param {string} cmd - The pfod command (e.g., "{.}" or "{dwgName}")
   * @returns {Promise<string>} - Response text (usually JSON)
   */
  async send(cmd) {
    if (!this.adapter) {
      throw new Error('No adapter initialized');
    }

    console.log(`[CONNECTION_MANAGER] Sending command: ${cmd}`);

    const response = await this.adapter.send(cmd);
    console.log(`[CONNECTION_MANAGER] Received response (${response.length} bytes)`);

    return response;
  }

  /**
   * Connect to the device (if needed for the protocol)
   */
  async connect() {
    if (this.adapter && this.adapter.connect) {
      console.log(`[CONNECTION_MANAGER] Connecting via ${this.protocol}...`);
      await this.adapter.connect();
      console.log(`[CONNECTION_MANAGER] Connected`);
    }
  }

  /**
   * Disconnect from the device (if needed for the protocol)
   */
  async disconnect() {
    if (this.adapter && this.adapter.disconnect) {
      console.log(`[CONNECTION_MANAGER] Disconnecting...`);
      await this.adapter.disconnect();
      console.log(`[CONNECTION_MANAGER] Disconnected`);
    }
  }

  /**
   * Check if connection is active
   */
  isConnected() {
    if (this.adapter && this.adapter.isConnected) {
      return this.adapter.isConnected();
    }
    return true; // HTTP doesn't need explicit connection
  }

  /**
   * Get response timeout in milliseconds for waiting for device response
   * Returns the configured timeout value
   * @returns {number} - Timeout in milliseconds
   */
  getResponseTimeout() {
    return this.responseTimeoutMs;
  }

  /**
   * Get max retries for the current connection protocol
   * @returns {number} - Max retries (BLE: 1, HTTP: 2, Serial: 3)
   */
  getMaxRetries() {
    return this.maxRetries;
  }
}

/**
 * HTTPConnection - Adapter for HTTP protocol
 *
 * Handles communication with pfod devices over HTTP.
 * Supports CORS for cross-origin requests.
 */
class HTTPConnection {
  constructor(config, connectionManager) {
    this.config = config;
    this.connectionManager = connectionManager;
    this.targetIP = config.targetIP;
    this.baseURL = this.targetIP ? `http://${this.targetIP}` : '';
    this.timeoutId = null;  // Store timeout ID so it can be cancelled

    console.log(`[HTTP_CONNECTION] Created with baseURL: ${this.baseURL || '(relative)'}`);
  }

  /**
   * Build fetch options with appropriate CORS settings
   * @returns {object} - Fetch options
   */
  buildFetchOptions() {
    return {
      headers: {
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      mode: this.targetIP ? 'cors' : 'same-origin',
      credentials: this.targetIP ? 'omit' : 'same-origin',
      cache: 'no-cache'
    };
  }

  /**
   * Send a command via HTTP and return the response text
   * @param {string} cmd - The pfod command (e.g., "{.}" or "{dwgName}")
   * @returns {Promise<string>} - Response text
   */
  async send(cmd) {
    // Prepend current dedup character to the command (don't advance yet - only advance on success)
    const cmdWithPrefix = getCurrentDedupChar() + cmd;

    // Build endpoint from command with prefix
    const endpoint = this.baseURL + `/pfodWeb?cmd=${encodeURIComponent(cmdWithPrefix)}`;
    const options = this.buildFetchOptions();

    // Cancel any previous timeout that might still be running
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      console.log(`[HTTP_CONNECTION] Cancelled previous timeout`);
      this.timeoutId = null;
    }

    // Add timeout using AbortController
    const controller = new AbortController();
    const timeout = this.connectionManager.getResponseTimeout();
    console.log(`[HTTP_CONNECTION] Setting response timeout to ${timeout}ms`);
    this.timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      console.log(`[HTTP_CONNECTION] Fetching: ${endpoint}`);

      // Record the command being sent (with the dedup prefix)
      if (ConnectionManager.messageCollector) {
        ConnectionManager.messageCollector.addMessage('sent', cmdWithPrefix, 'http', cmd);
      }

      const response = await fetch(endpoint, {
        ...options,
        signal: controller.signal
      });

      console.log(`[HTTP_CONNECTION] Response status: ${response.status}`);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const responseText = await response.text();

      // Clear timeout on successful response
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }

      // Record the response in the message collector using byte-by-byte scan
      if (ConnectionManager.messageCollector) {
        // Find text before {
        const startBrace = responseText.indexOf('{');
        if (startBrace > 0) {
          const beforeText = responseText.substring(0, startBrace);
          if (beforeText.trim()) {
            ConnectionManager.messageCollector.addMessage('received', beforeText, 'http', cmd);
          }
        }

        // Find and record { to } - use matching brace for nested structures
        const endBrace = startBrace >= 0 ? findMatchingClosingBrace(responseText, startBrace) : -1;
        if (startBrace !== -1 && endBrace !== -1) {
          const pfodMessage = responseText.substring(startBrace, endBrace + 1);
          ConnectionManager.messageCollector.addMessage('received', pfodMessage, 'http', cmd);

          // Find text after }
          const afterText = responseText.substring(endBrace + 1);
          if (afterText.trim()) {
            ConnectionManager.messageCollector.addMessage('received', afterText, 'http', cmd);
          }
        } else if (startBrace === -1) {
          // No { found - record entire response as junk
          if (responseText.trim()) {
            ConnectionManager.messageCollector.addMessage('received', responseText, 'http', cmd);
          }
        }
      }

      // Advance dedup character only on successful response (not on retry/timeout)
      advanceDedupChar();

      return responseText;
    } catch (error) {
      // Clear timeout on error
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }

      if (error.name === 'AbortError') {
        throw new Error('HTTP response timeout - device may not be responding');
      }
      throw error;
    }
  }

  /**
   * HTTP doesn't need explicit connection
   */
  async connect() {
    // No-op for HTTP
  }

  /**
   * HTTP doesn't need explicit disconnection
   */
  async disconnect() {
    // No-op for HTTP
  }

  /**
   * HTTP is always "connected"
   */
  isConnected() {
    return true;
  }
}

/**
 * SerialConnection - Adapter for Serial protocol using Web Serial API
 *
 * Handles communication with pfod devices over serial ports (USB, UART, etc).
 * Uses the browser's Web Serial API for direct serial communication.
 */
class SerialConnection {
  constructor(config, connectionManager) {
    this.config = config;
    this.connectionManager = connectionManager;
    this.port = null;
    this.portName = 'Unknown Port';  // Store human-readable port name for error messages
    this.reader = null;
    this.writer = null;
    this.connected = false;
    this.readBuffer = '';
    this.responsePromise = null;
    this.responseResolve = null;
    this.responseReject = null;
    this.timeoutId = null;  // Store timeout ID so it can be cancelled
    this.firstRequest = true;  // Flag to track if this is the first request
    this.firstRequestAttemptTimeout = 2000;  // Start at 1 second for first request attempts

    // Serial configuration with defaults
    this.baudRate = config.baudRate || 9600;
    this.dataBits = config.dataBits || 8;
    this.stopBits = config.stopBits || 1;
    this.parity = config.parity || 'none';
    this.flowControl = 'none'; //'hardware' ;//config.flowControl || 'none';

    console.log(`[SERIAL_CONNECTION] Created with baud rate: ${this.baudRate}`);
  }

  /**
   * Connect to a serial port
   * Always prompts user to select port (does not reuse previously granted ports)
   */
  async connect() {
    try {
      // Check if Web Serial API is supported
      if (!('serial' in navigator)) {
        const errorMsg = 'Web Serial API is not supported in this browser.\n\n' +
                        'Serial connections require:\n' +
                        '• Chrome (version 89 or later)\n' +
                        '• Edge (version 89 or later)\n' +
                        '• Opera (version 75 or later)\n\n' +
                        'Please use a supported browser for Serial connections.';
        throw new Error(errorMsg);
      }

      // Always prompt user to select serial port
      console.log('[SERIAL_CONNECTION] Prompting user to select serial port...');

      try {
        // Request port from user
        this.port = await navigator.serial.requestPort();

        // Capture port name from port info
        try {
          const portInfo = this.port.getInfo();
          let foundComPort = null;

          // Try to find matching port from navigator.serial.getPorts()
          // This works better on Windows where COM port info isn't exposed directly
          try {
            const allPorts = await navigator.serial.getPorts();
            console.log('[SERIAL_CONNECTION] Total available ports:', allPorts.length);

            // Try to find the just-selected port by matching VID/PID
            for (let availablePort of allPorts) {
              const availableInfo = availablePort.getInfo();
              if (availableInfo.usbVendorId === portInfo.usbVendorId &&
                  availableInfo.usbProductId === portInfo.usbProductId) {
                console.log('[SERIAL_CONNECTION] Matched port by VID/PID');

                // Try to extract path/name from available port
                if (availablePort.path) {
                  foundComPort = availablePort.path;
                  console.log('[SERIAL_CONNECTION] Found path:', availablePort.path);
                  break;
                }
              }
            }
          } catch (e) {
            console.warn('[SERIAL_CONNECTION] Error getting ports list:', e);
          }

          // Fallback approaches if above didn't work
          if (!foundComPort) {
            // Try port.path
            if (this.port.path) {
              foundComPort = this.port.path;
              console.log('[SERIAL_CONNECTION] Using port.path:', foundComPort);
            }
          }

          // Set final port name
          if (foundComPort) {
            // If it looks like a COM port, use it as is
            if (foundComPort.match(/COM\d+/)) {
              this.portName = foundComPort.match(/COM\d+/)[0];
            } else {
              this.portName = foundComPort;
            }
          } else {
            // Chrome on Windows doesn't expose COM port number, just show COM?
            this.portName = 'COM?';
          }

          console.log('[SERIAL_CONNECTION] Final port name:', this.portName);
        } catch (e) {
          this.portName = 'Serial Port';
          console.warn('[SERIAL_CONNECTION] Error extracting port name:', e);
        }
        console.log('[SERIAL_CONNECTION] Attempting to open port...');

        // Try to open the newly selected port
        await this.port.open({
          baudRate: this.baudRate,
          dataBits: this.dataBits,
          stopBits: this.stopBits,
          parity: this.parity,
          flowControl: this.flowControl
        });
        console.log('[SERIAL_CONNECTION] Port opened successfully');
      } catch (selectError) {
        console.error('[SERIAL_CONNECTION] Port selection or opening failed:', selectError);

        const errorMsg = 'Serial port could not be opened. Please ensure:\n' +
                        '1. The device is connected\n' +
                        '2. No other application is using the port\n' +
                        '3. You selected the correct port';
        throw new Error(errorMsg);
      }

      // Get reader and writer
      this.reader = this.port.readable.getReader();
      this.writer = this.port.writable.getWriter();
      this.connected = true;

      // Reset first request flag for new connection
      this.firstRequest = true;
      console.log('[SERIAL_CONNECTION] Serial connection established successfully, firstRequest flag reset');

      // Start reading loop (don't await - let it run in background)
      this.startReading();

      // Give a moment for the read loop to actually start before returning
      // This ensures the reader is actively listening before we send commands
      await new Promise(resolve => setTimeout(resolve, 50));

    } catch (error) {
      console.error('[SERIAL_CONNECTION] Connection failed:', error);
      throw error;
    }
  }

  /**
   * Start continuous reading from serial port
   * Buffers incoming data until a complete response is received
   * Resets timeout each time data is received
   */
  async startReading() {
    console.log('[SERIAL_CONNECTION] Starting read loop...');

    try {
      while (this.connected && this.reader) {
        const { value, done } = await this.reader.read();

        if (done) {
          console.log('[SERIAL_CONNECTION] Reader closed');
          break;
        }

        // Convert Uint8Array to string
        const text = new TextDecoder().decode(value);
        this.readBuffer += text;

        // Reset timeout each time we receive data
        if (this.timeoutId && this.responseReject) {
          clearTimeout(this.timeoutId);
          // Use the current timeout value that was set in send()
    //      console.log(`[SERIAL_CONNECTION] Resetting timeout to ${this.currentTimeout}ms after receiving data`);
          this.timeoutId = setTimeout(() => {
            if (this.responseReject) {
              this.responseReject(new Error('Serial response timeout - device may not be responding'));
              this.responseResolve = null;
              this.responseReject = null;
              this.timeoutId = null;
            }
          }, this.currentTimeout);
        }

        // Check if we have a complete pfod response
        this.processReadBuffer();
      }
    } catch (error) {
      if (this.connected) {
        console.error('[SERIAL_CONNECTION] Read error:', error);
        if (this.responseReject) {
          this.responseReject(error);
          this.responseResolve = null;
          this.responseReject = null;
        }
      }
    }
  }

  /**
   * Convert pfod protocol string to JSON format expected by pfodWebDebug
   * pfod format: {,~`0~V2|+A~z}
   * Split by | and } where each starts a new array element
   * Result: {"cmd": ["{,~`0~V2", "|+A~z", "}"]}
   */
  pfodToJson(pfodString) {
    console.log(`[PFOD_TO_JSON] INPUT pfod string:`, pfodString);

    // Split the string where | or } starts a new element
    const cmdArray = [];
    let currentElement = '';

    for (let i = 0; i < pfodString.length; i++) {
      const char = pfodString[i];

      if (char === '|' || char === '}') {
        // Save current element if not empty
        if (currentElement.length > 0) {
          cmdArray.push(currentElement);
        }
        // Start new element with the delimiter
        currentElement = char;

        // If it's }, add it as its own element and reset
        if (char === '}') {
          cmdArray.push(currentElement);
          currentElement = '';
        }
      } else {
        currentElement += char;
      }
    }

    // Add any remaining element (shouldn't happen with well-formed pfod)
    if (currentElement.length > 0) {
      cmdArray.push(currentElement);
    }

    // Wrap in JSON structure
    const jsonObject = {
      cmd: cmdArray
    };

    const jsonString = JSON.stringify(jsonObject);
    console.log(`[PFOD_TO_JSON] OUTPUT JSON:`, jsonString);

    return jsonString;
  }

  /**
   * Process the read buffer for complete pfod responses
   * Parsing starts on { and stops on }
   * Captures ALL text including chars outside { }
   */
  processReadBuffer() {
    // Find the start of a pfod command
    const startBrace = this.readBuffer.indexOf('{');

    if (startBrace === -1) {
      // No start brace yet - but capture any non-empty text as raw output
      if (this.readBuffer.length > 0) {
        if (ConnectionManager.messageCollector) {
          ConnectionManager.messageCollector.addMessage('received', this.readBuffer, 'serial');
        }
      }
      this.readBuffer = '';
      return;
    }

    // Capture any text BEFORE the start brace
    if (startBrace > 0) {
      const beforeText = this.readBuffer.substring(0, startBrace);
      if (ConnectionManager.messageCollector) {
        ConnectionManager.messageCollector.addMessage('received', beforeText, 'serial');
      }
      this.readBuffer = this.readBuffer.substring(startBrace);
    }

    // Now check if we have the closing brace
    const endBrace = this.readBuffer.indexOf('}');

    if (endBrace === -1) {
      // No end brace yet - keep buffering
      return;
    }

    // We have a complete pfod command from { to }
    const pfodString = this.readBuffer.substring(0, endBrace + 1);

    // Calculate time elapsed since send
    const receiveTime = Date.now();
    const elapsedMs = this.sendTime ? (receiveTime - this.sendTime) : 0;

    console.log(`[SERIAL_CONNECTION] Received complete pfod command after ${elapsedMs}ms:`, pfodString);

    // Convert pfod protocol to JSON format
    const jsonString = this.pfodToJson(pfodString);

    // Record the raw pfod message received
    if (ConnectionManager.messageCollector) {
      ConnectionManager.messageCollector.addMessage('received', pfodString, 'serial');
    }

    if (this.responseResolve) {
      // Cancel the timeout since we got a response
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }

      // Advance dedup character only on successful response (not on retry/timeout)
      advanceDedupChar();

      this.responseResolve(jsonString);
      this.responseResolve = null;
      this.responseReject = null;
    }

    // Clear the buffer up to and including the closing brace
    this.readBuffer = this.readBuffer.substring(endBrace + 1);
  }

  /**
   * Send a command via serial and return the response
   * For first request: starts with 1 second timeout, doubles on each timeout up to user-set timeout
   * Logs warnings (not errors) for first request timeouts during auto-detection
   * @param {string} cmd - The pfod command (e.g., "{.}" or "{dwgName}")
   * @returns {Promise<string>} - Response text (usually JSON)
   */
  async send(cmd) {
    // Auto-connect if not already connected
    if (!this.connected || !this.writer) {
      console.log('[SERIAL_CONNECTION] Not connected, connecting now...');
      await this.connect();
    }

    // Diagnostic logging: Check if a previous request is still pending
    if (this.responseResolve || this.responseReject) {
      console.warn(`[SERIAL_CONNECTION] WARNING: send() called while previous request still pending`);
      console.warn(`[SERIAL_CONNECTION] This should not happen - queue protection may not be working`);
    }

    // Cancel any previous timeout that might still be running
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      console.log(`[SERIAL_CONNECTION] Cancelled previous timeout`);
      this.timeoutId = null;
    }

    // Clear previous response state
    this.readBuffer = '';

    // For first request, implement progressive timeout doubling
    if (this.firstRequest) {
      this.firstRequest = false;
      return this.sendWithProgressiveTimeout(cmd);
    }

    // Normal send for subsequent requests
    return this.sendOnce(cmd, this.connectionManager.getResponseTimeout());
  }

  /**
   * Send with progressive timeout doubling for first request
   * EVERY timeout throws error back to caller (pfodWebDebug queue) for retry
   * Timeout doubles on each retry until user-set max or first response received
   */
  async sendWithProgressiveTimeout(cmd) {
    const maxTimeout = this.connectionManager.getResponseTimeout();
    const timeoutToUse = Math.min(this.firstRequestAttemptTimeout, maxTimeout);
    const isMaxTimeout = (timeoutToUse >= maxTimeout);

    console.error(`[SERIAL_CONNECTION] First request attempt with ${timeoutToUse}ms timeout`);

    try {
      // Try to send with current timeout
      const response = await this.sendOnce(cmd, timeoutToUse);

      // Success! Clear first request flag and return
      this.firstRequest = false;
      console.error(`[SERIAL_CONNECTION] First request succeeded with ${timeoutToUse}ms timeout`);
      return response;
    } catch (error) {
      // Check if it was a timeout error
      if (error.message.includes('timeout')) {
        // Double timeout for next retry (unless already at max)
        if (!isMaxTimeout) {
        //  this.firstRequestAttemptTimeout *= 2;
        }

        // Log and throw error back to queue for retry
        if (isMaxTimeout) {
          console.error(`[SERIAL_CONNECTION] First request timeout at ${maxTimeout}ms (max) - will retry`);
          this.firstRequest = false;  // Clear flag when max reached
        } else {
          console.error(`[SERIAL_CONNECTION] First request timeout at ${timeoutToUse}ms - next attempt will use ${this.connectionManager.getResponseTimeout()}ms`);
        }

        // Throw error for EVERY timeout - let queue handle retry
        throw new Error('Serial response timeout - device may not be responding');
      } else {
        // Non-timeout error, propagate immediately
        this.firstRequest = false;  // Clear flag on error
        throw error;
      }
    }
  }

  /**
   * Send command once with specified timeout
   * @param {string} cmd - The pfod command
   * @param {number} timeout - Timeout in milliseconds
   * @returns {Promise<string>} - Response text
   */
  async sendOnce(cmd, timeout) {
    // Record send time for performance measurement
    this.sendTime = Date.now();
    this.currentTimeout = timeout;

    // Set up promise for response
    const responsePromise = new Promise((resolve, reject) => {
      this.responseResolve = resolve;
      this.responseReject = reject;

      console.log(`[SERIAL_CONNECTION] Setting timeout to ${timeout}ms`);
      this.timeoutId = setTimeout(() => {
        if (this.responseReject) {
          this.responseReject(new Error('Serial response timeout - device may not be responding'));
          this.responseResolve = null;
          this.responseReject = null;
          this.timeoutId = null;
        }
      }, timeout);
    });

    // Prepend current dedup character to the command (don't advance yet - only advance on success)
    const cmdWithPrefix = getCurrentDedupChar() + cmd;

    // Send the command
    console.log(`[SERIAL_CONNECTION] Sending: ${cmdWithPrefix} at ${new Date(this.sendTime).toISOString()}`);

    // Record the command being sent (with the dedup prefix)
    if (ConnectionManager.messageCollector) {
      ConnectionManager.messageCollector.addMessage('sent', cmdWithPrefix, 'serial', cmd);
    }

    const encoder = new TextEncoder();
    const data = encoder.encode(cmdWithPrefix + '\n'); // Add newline for command termination
    await this.writer.write(data);

    // Wait for response
    return responsePromise;
  }

  /**
   * Disconnect from the serial port
   */
  async disconnect() {
    console.log('[SERIAL_CONNECTION] Disconnecting...');

    this.connected = false;

    try {
      // Cancel reader
      if (this.reader) {
        await this.reader.cancel();
        this.reader.releaseLock();
        this.reader = null;
      }

      // Release writer
      if (this.writer) {
        this.writer.releaseLock();
        this.writer = null;
      }

      // Close port
      if (this.port) {
        await this.port.close();
        this.port = null;
      }

      console.log('[SERIAL_CONNECTION] Disconnected successfully');
    } catch (error) {
      console.error('[SERIAL_CONNECTION] Error during disconnect:', error);
      throw error;
    }
  }

  /**
   * Check if serial connection is active
   */
  isConnected() {
    return this.connected && this.port !== null;
  }
}

/**
 * BLEConnection - Adapter for BLE protocol using Web Bluetooth API
 *
 * Handles communication with pfod devices over Bluetooth Low Energy.
 * Uses the browser's Web Bluetooth API for direct BLE communication.
 * Filters devices to only show those advertising the UART service.
 */
class BLEConnection {
  constructor(config, connectionManager) {
    this.config = config;
    this.connectionManager = connectionManager;
    this.device = null;
    this.server = null;
    this.service = null;
    this.characteristicTX = null;
    this.characteristicRX = null;
    this.connected = false;
    this.readBuffer = '';
    this.responseResolve = null;
    this.responseReject = null;
    this.timeoutId = null;  // Store timeout ID so it can be cancelled

    // UART Service UUIDs (Nordic UART Service)
    this.UART_SERVICE_UUID = '6E400001-B5A3-F393-E0A9-E50E24DCCA9E'.toLowerCase();
    this.UART_TX_CHAR_UUID = '6E400002-B5A3-F393-E0A9-E50E24DCCA9E'.toLowerCase();
    this.UART_RX_CHAR_UUID = '6E400003-B5A3-F393-E0A9-E50E24DCCA9E'.toLowerCase();

    console.log(`[BLE_CONNECTION] Created with UART service filtering`);
  }

  /**
   * Connect to a BLE device
   * Uses previously granted device if available, otherwise prompts user with filtering
   */
  async connect() {
    try {
      // Check if Web Bluetooth API is supported
      if (!('bluetooth' in navigator)) {
        const errorMsg = 'Web Bluetooth API is not supported in this browser.\n\n' +
                        'Bluetooth connections require:\n' +
                        '• Chrome (version 56 or later)\n' +
                        '• Edge (version 79 or later)\n' +
                        '• Opera (version 43 or later)\n\n' +
                        'Please use a supported browser for Bluetooth connections.';
        throw new Error(errorMsg);
      }

      // Prompt user to select BLE device
      console.log('[BLE_CONNECTION] Prompting user to select BLE device...');

      try {
        // Request device from user with UART service filter
        this.device = await navigator.bluetooth.requestDevice({
          filters: [{services: [this.UART_SERVICE_UUID]}]
        });
        console.log(`[BLE_CONNECTION] User selected device: ${this.device.name || 'Unknown Device'}`);

        // Try to connect to the newly selected device
        await this.connectToDevice(this.device);
      } catch (selectError) {
        console.error('[BLE_CONNECTION] Device selection or connection failed:', selectError);

        const errorMsg = 'BLE device could not be connected. Please ensure:\n' +
                        '1. The device is powered on\n' +
                        '2. The device is within range\n' +
                        '3. The device is advertising the UART service';
        throw new Error(errorMsg);
      }

      console.log('[BLE_CONNECTION] BLE connection established successfully');

    } catch (error) {
      console.error('[BLE_CONNECTION] Connection failed:', error);
      throw error;
    }
  }

  /**
   * Connect to a specific BLE device and set up characteristics
   */
  async connectToDevice(device) {
    console.log(`[BLE_CONNECTION] Connecting to device: ${device.name || 'Unknown Device'}`);

    // Set up disconnect listener
    device.addEventListener('gattserverdisconnected', () => this.onDisconnected());

    // Connect to GATT server
    this.server = await device.gatt.connect();
    console.log('[BLE_CONNECTION] Connected to GATT Server');

    // Get UART service
    this.service = await this.server.getPrimaryService(this.UART_SERVICE_UUID);
    console.log('[BLE_CONNECTION] UART Service discovered');

    // Get RX characteristic (device transmits, we receive)
    this.characteristicRX = await this.service.getCharacteristic(this.UART_RX_CHAR_UUID);
    console.log('[BLE_CONNECTION] RX Characteristic discovered');

    // Set up notification handler
    this.characteristicRX.addEventListener('characteristicvaluechanged', (event) => {
      this.handleCharacteristicChange(event);
    });

    // Start notifications
    await this.characteristicRX.startNotifications();
    console.log('[BLE_CONNECTION] Notifications started');

    // Get TX characteristic (we transmit, device receives)
    this.characteristicTX = await this.service.getCharacteristic(this.UART_TX_CHAR_UUID);
    console.log('[BLE_CONNECTION] TX Characteristic discovered');

    this.connected = true;
    this.device = device;
  }

  /**
   * Handle disconnect event
   */
  onDisconnected() {
    console.log('[BLE_CONNECTION] Device disconnected');
    this.connected = false;
    this.server = null;
    this.service = null;
    this.characteristicTX = null;
    this.characteristicRX = null;
  }

  /**
   * Handle incoming data from BLE device
   * Resets timeout each time data is received
   */
  handleCharacteristicChange(event) {
    const text = new TextDecoder().decode(event.target.value);
    this.readBuffer += text;
    console.log(`[BLE_CONNECTION] Received data: ${text}`);

    // Reset timeout each time we receive data
    if (this.timeoutId && this.responseReject) {
      clearTimeout(this.timeoutId);
      const timeout = this.connectionManager.getResponseTimeout();
      console.log(`[BLE_CONNECTION] Resetting timeout to ${timeout}ms after receiving data`);
      this.timeoutId = setTimeout(() => {
        if (this.responseReject) {
          this.responseReject(new Error('BLE response timeout - device may not be responding'));
          this.responseResolve = null;
          this.responseReject = null;
          this.timeoutId = null;
        }
      }, timeout);
    }

    // Check if we have a complete pfod response
    this.processReadBuffer();
  }

  /**
   * Convert pfod protocol string to JSON format expected by pfodWebDebug
   * Same logic as SerialConnection
   */
  pfodToJson(pfodString) {
    console.log(`[PFOD_TO_JSON] INPUT pfod string:`, pfodString);

    // Split the string where | or } starts a new element
    const cmdArray = [];
    let currentElement = '';

    for (let i = 0; i < pfodString.length; i++) {
      const char = pfodString[i];

      if (char === '|' || char === '}') {
        // Save current element if not empty
        if (currentElement.length > 0) {
          cmdArray.push(currentElement);
        }
        // Start new element with the delimiter
        currentElement = char;

        // If it's }, add it as its own element and reset
        if (char === '}') {
          cmdArray.push(currentElement);
          currentElement = '';
        }
      } else {
        currentElement += char;
      }
    }

    // Add any remaining element (shouldn't happen with well-formed pfod)
    if (currentElement.length > 0) {
      cmdArray.push(currentElement);
    }

    // Wrap in JSON structure
    const jsonObject = {
      cmd: cmdArray
    };

    const jsonString = JSON.stringify(jsonObject);
    console.log(`[PFOD_TO_JSON] OUTPUT JSON:`, jsonString);

    return jsonString;
  }

  /**
   * Process the read buffer for complete pfod responses
   * Same logic as SerialConnection
   */
  processReadBuffer() {
    // Find the start of a pfod command
    const startBrace = this.readBuffer.indexOf('{');

    if (startBrace === -1) {
      // No start brace yet - but capture any non-empty text as raw output
      if (this.readBuffer.length > 0) {
        if (ConnectionManager.messageCollector) {
          ConnectionManager.messageCollector.addMessage('received', this.readBuffer, 'ble');
        }
      }
      this.readBuffer = '';
      return;
    }

    // Capture any text BEFORE the start brace
    if (startBrace > 0) {
      const beforeText = this.readBuffer.substring(0, startBrace);
      if (ConnectionManager.messageCollector) {
        ConnectionManager.messageCollector.addMessage('received', beforeText, 'ble');
      }
      this.readBuffer = this.readBuffer.substring(startBrace);
    }

    // Now check if we have the closing brace
    const endBrace = this.readBuffer.indexOf('}');

    if (endBrace === -1) {
      // No end brace yet - keep buffering
      return;
    }

    // We have a complete pfod command from { to }
    const pfodString = this.readBuffer.substring(0, endBrace + 1);

    // Calculate time elapsed since send
    const receiveTime = Date.now();
    const elapsedMs = this.sendTime ? (receiveTime - this.sendTime) : 0;

    console.log(`[BLE_CONNECTION] Received complete pfod command after ${elapsedMs}ms:`, pfodString);

    // Convert pfod protocol to JSON format
    const jsonString = this.pfodToJson(pfodString);

    // Record the raw pfod message received
    if (ConnectionManager.messageCollector) {
      ConnectionManager.messageCollector.addMessage('received', pfodString, 'ble');
    }

    if (this.responseResolve) {
      // Cancel the timeout since we got a response
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }

      // Advance dedup character only on successful response (not on retry/timeout)
      advanceDedupChar();

      this.responseResolve(jsonString);
      this.responseResolve = null;
      this.responseReject = null;
    }

    // Clear the buffer up to and including the closing brace
    this.readBuffer = this.readBuffer.substring(endBrace + 1);
  }

  /**
   * Send a command via BLE and return the response
   * @param {string} cmd - The pfod command (e.g., "{.}" or "{dwgName}")
   * @returns {Promise<string>} - Response text (usually JSON)
   */
  async send(cmd) {
    // Auto-connect if not already connected
    if (!this.connected || !this.characteristicTX) {
      console.log('[BLE_CONNECTION] Not connected, connecting now...');
      await this.connect();
    }

    // Diagnostic logging: Check if a previous request is still pending
    if (this.responseResolve || this.responseReject) {
      console.warn(`[BLE_CONNECTION] WARNING: send() called while previous request still pending`);
      console.warn(`[BLE_CONNECTION] This should not happen - queue protection may not be working`);
    }

    // Cancel any previous timeout that might still be running
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      console.log(`[BLE_CONNECTION] Cancelled previous timeout`);
      this.timeoutId = null;
    }

    // Clear previous response state
    this.readBuffer = '';

    // Record send time for performance measurement
    this.sendTime = Date.now();

    // Set up promise for response
    const responsePromise = new Promise((resolve, reject) => {
      this.responseResolve = resolve;
      this.responseReject = reject;

      // Get timeout from connection manager (default 10 seconds)
      const timeout = this.connectionManager.getResponseTimeout();
      console.log(`[BLE_CONNECTION] Setting response timeout to ${timeout}ms`);
      this.timeoutId = setTimeout(() => {
        if (this.responseReject) {
          this.responseReject(new Error('BLE response timeout - device may not be responding'));
          this.responseResolve = null;
          this.responseReject = null;
          this.timeoutId = null;
        }
      }, timeout);
    });

    // Prepend current dedup character to the command (don't advance yet - only advance on success)
    const cmdWithPrefix = getCurrentDedupChar() + cmd;

    // Send the command
    console.log(`[BLE_CONNECTION] Sending: ${cmdWithPrefix} at ${new Date(this.sendTime).toISOString()}`);

    // Record the command being sent (with the dedup prefix)
    if (ConnectionManager.messageCollector) {
      ConnectionManager.messageCollector.addMessage('sent', cmdWithPrefix, 'ble', cmd);
    }

    const encoder = new TextEncoder();
    const data = encoder.encode(cmdWithPrefix + '\n'); // Add newline for command termination
    await this.characteristicTX.writeValue(data);

    // Wait for response
    return responsePromise;
  }

  /**
   * Disconnect from the BLE device
   */
  async disconnect() {
    console.log('[BLE_CONNECTION] Disconnecting...');

    this.connected = false;

    try {
      // Stop notifications
      if (this.characteristicRX) {
        await this.characteristicRX.stopNotifications();
        console.log('[BLE_CONNECTION] Notifications stopped');
      }

      // Disconnect GATT server
      if (this.server && this.server.connected) {
        this.server.disconnect();
        console.log('[BLE_CONNECTION] GATT server disconnected');
      }

      // Clear references
      this.device = null;
      this.server = null;
      this.service = null;
      this.characteristicTX = null;
      this.characteristicRX = null;

      console.log('[BLE_CONNECTION] Disconnected successfully');
    } catch (error) {
      console.error('[BLE_CONNECTION] Error during disconnect:', error);
      throw error;
    }
  }

  /**
   * Check if BLE connection is active
   */
  isConnected() {
    return this.connected && this.server && this.server.connected;
  }
}

// Make classes available globally for browser use
window.ConnectionManager = ConnectionManager;
window.HTTPConnection = HTTPConnection;
window.SerialConnection = SerialConnection;
window.BLEConnection = BLEConnection;



/* ========================================
 * Inlined from: messageViewer.js
 * ======================================== */
/*
   messageViewer.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

/**
 * MessageCollector - Centralized collector for raw messages from all connections
 * Stores messages with metadata (timestamp, direction, connection type, size)
 */
class MessageCollector {
  constructor(maxMessages = 500) {
    this.messages = [];
    this.maxMessages = maxMessages;
    this.subscribers = []; // Callback functions to notify of new messages
    this.isPaused = false;
    console.log('[MESSAGE_COLLECTOR] Created with max messages:', maxMessages);
  }

  /**
   * Add a message to the collector
   * @param {string} direction - 'sent' or 'received'
   * @param {string} message - The raw message text
   * @param {string} protocol - 'http', 'serial', or 'ble'
   * @param {string} cmd - Optional command that was sent (for reference)
   */
  addMessage(direction, message, protocol, cmd = null) {
    if (this.isPaused) {
      return;
    }

    const entry = {
      timestamp: new Date().toISOString(),
      direction: direction,
      protocol: protocol,
      message: message,
      cmd: cmd,
      size: message ? message.length : 0
    };

    this.messages.push(entry);

    // Trim to max messages if needed
    if (this.messages.length > this.maxMessages) {
      this.messages.shift();
    }

    // Notify subscribers
    this.notifySubscribers(entry);

    const logPrefix = direction === 'sent' ? '>>> SENT' : '<<< RECEIVED';
    console.log(`[MESSAGE_COLLECTOR] ${logPrefix} [${protocol}] ${message ? message.substring(0, 100) : '(empty)'}`);
  }

  /**
   * Subscribe to new messages
   * @param {function} callback - Function to call with new message entry
   */
  subscribe(callback) {
    this.subscribers.push(callback);
  }

  /**
   * Unsubscribe from messages
   * @param {function} callback - The callback to remove
   */
  unsubscribe(callback) {
    this.subscribers = this.subscribers.filter(cb => cb !== callback);
  }

  /**
   * Notify all subscribers of a new message
   */
  notifySubscribers(entry) {
    this.subscribers.forEach(callback => {
      try {
        callback(entry);
      } catch (error) {
        console.error('[MESSAGE_COLLECTOR] Error in subscriber callback:', error);
      }
    });
  }

  /**
   * Get all messages
   */
  getMessages() {
    return [...this.messages];
  }

  /**
   * Get messages filtered by protocol
   */
  getMessagesByProtocol(protocol) {
    return this.messages.filter(msg => msg.protocol === protocol);
  }

  /**
   * Get messages filtered by direction
   */
  getMessagesByDirection(direction) {
    return this.messages.filter(msg => msg.direction === direction);
  }

  /**
   * Clear all messages
   */
  clear() {
    this.messages = [];
    console.log('[MESSAGE_COLLECTOR] Messages cleared');
  }

  /**
   * Pause collecting messages
   */
  pause() {
    this.isPaused = true;
    console.log('[MESSAGE_COLLECTOR] Paused');
  }

  /**
   * Resume collecting messages
   */
  resume() {
    this.isPaused = false;
    console.log('[MESSAGE_COLLECTOR] Resumed');
  }

  /**
   * Export messages as JSON
   */
  exportAsJSON() {
    return JSON.stringify(this.messages, null, 2);
  }

  /**
   * Export messages as CSV
   */
  exportAsCSV() {
    if (this.messages.length === 0) {
      return 'timestamp,direction,protocol,message,size\n';
    }

    const header = 'timestamp,direction,protocol,message,size\n';
    const rows = this.messages.map(msg => {
      const message = msg.message.replace(/"/g, '""').replace(/\n/g, ' '); // Escape quotes and newlines
      return `"${msg.timestamp}","${msg.direction}","${msg.protocol}","${message}",${msg.size}`;
    });

    return header + rows.join('\n');
  }
}

/**
 * RawMessageViewer - UI component to display collected messages
 */
class RawMessageViewer {
  constructor(messageCollector, containerId = 'raw-message-viewer') {
    this.collector = messageCollector;
    this.containerId = containerId;
    this.isVisible = false;
    this.filterDirection = 'all'; // 'all', 'sent', 'received'
    this.autoScroll = true;
    this.messageViews = []; // Store references to message view elements for scrolling

    console.log('[RAW_MESSAGE_VIEWER] Created with container:', containerId);

    // Subscribe to new messages
    this.collector.subscribe((entry) => this.onNewMessage(entry));
  }

  /**
   * Initialize and create the viewer UI
   */
  initialize() {
    const container = document.getElementById(this.containerId);
    if (!container) {
      console.error('[RAW_MESSAGE_VIEWER] Container not found:', this.containerId);
      return;
    }

    this.createViewerHTML(container);
    this.attachEventListeners();
    this.updateMessageDisplay();
    console.log('[RAW_MESSAGE_VIEWER] Initialized');
  }

  /**
   * Create the HTML structure for the viewer
   */
  createViewerHTML(container) {
    container.innerHTML = `
      <div class="raw-message-viewer" id="raw-message-viewer-main">
        <div class="raw-message-header">
          <div class="raw-message-title">
            <span>Raw Message Viewer</span>
            <button class="raw-message-close-btn" id="raw-message-close-btn" title="Close viewer">&times;</button>
          </div>
          <div class="raw-message-toolbar">
            <div class="raw-message-filters">
              <select id="raw-msg-filter-direction" class="raw-message-filter">
                <option value="all">Direction: All</option>
                <option value="sent">Direction: Sent</option>
                <option value="received">Direction: Received</option>
              </select>
            </div>
            <div class="raw-message-buttons">
              <label class="raw-message-checkbox">
                <input type="checkbox" id="raw-msg-autoscroll" checked>
                Auto-scroll
              </label>
              <button id="raw-msg-clear-btn" class="raw-message-btn">Clear</button>
              <button id="raw-msg-export-json-btn" class="raw-message-btn">Export JSON</button>
              <button id="raw-msg-export-csv-btn" class="raw-message-btn">Export CSV</button>
            </div>
          </div>
        </div>
        <div class="raw-message-content">
          <div class="raw-message-list" id="raw-message-list">
            <div class="raw-message-empty">No messages yet</div>
          </div>
        </div>
      </div>
    `;

    this.attachStyles(container);
  }

  /**
   * Attach CSS styles to the container
   */
  attachStyles(container) {
    const style = document.createElement('style');
    style.textContent = `
      #${this.containerId} {
        all: initial;
        display: none;
        flex-direction: column;
        width: 100%;
        height: 100%;
        font-family: 'Courier New', monospace;
        min-width: 200px;
        background-color: #1e1e1e;
      }

      .raw-message-viewer {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        background-color: #1e1e1e;
        color: #d4d4d4;
        border: 1px solid #333;
        box-sizing: border-box;
        z-index: 5000;
      }

      .raw-message-header {
        flex-shrink: 0;
        background-color: #252526;
        border-bottom: 1px solid #3e3e42;
        padding: 8px;
      }

      .raw-message-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-weight: bold;
        font-size: 14px;
        color: #cccccc;
      }

      .raw-message-close-btn {
        background: none;
        border: none;
        color: #cccccc;
        font-size: 20px;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .raw-message-close-btn:hover {
        color: #ffffff;
      }

      .raw-message-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
      }

      .raw-message-filters {
        display: flex;
        gap: 8px;
      }

      .raw-message-filter,
      .raw-message-btn,
      .raw-message-checkbox input {
        background-color: #3c3c3c;
        color: #d4d4d4;
        border: 1px solid #555;
        padding: 4px 8px;
        border-radius: 3px;
        font-size: 12px;
        cursor: pointer;
        font-family: Arial, sans-serif;
      }

      .raw-message-filter:hover,
      .raw-message-btn:hover {
        background-color: #454545;
      }

      .raw-message-filter:focus,
      .raw-message-btn:focus {
        outline: 1px solid #007acc;
      }

      .raw-message-buttons {
        display: flex;
        gap: 8px;
      }

      .raw-message-checkbox {
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        font-size: 12px;
        color: #d4d4d4;
      }

      .raw-message-checkbox input {
        cursor: pointer;
        padding: 0;
        width: 16px;
        height: 16px;
      }

      .raw-message-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .raw-message-list {
        flex: 1;
        overflow-y: auto;
        overflow-x: auto;
        background-color: #1e1e1e;
        padding: 4px;
      }

      .raw-message-item {
        display: flex;
        padding: 4px;
        margin: 2px 0;
        border-radius: 2px;
        border-left: 3px solid;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-size: 11px;
        line-height: 1.4;
      }

      .raw-message-item.sent {
        border-left-color: #4ec9b0;
        background-color: #1e3b2a;
      }

      .raw-message-item.received {
        border-left-color: #ce9178;
        background-color: #3b2a1e;
      }

      .raw-message-item-time {
        color: #858585;
        min-width: 100px;
        margin-right: 0px;
        flex-shrink: 0;
      }

      .raw-message-item-direction {
        color: #d7ba7d;
        min-width: 20px;
        margin-right: 2px;
        flex-shrink: 0;
        font-weight: bold;
      }

      .raw-message-item-text {
        flex: 1;
        color: #ce9178;
        word-break: break-all;
      }

      .raw-message-empty {
        color: #858585;
        padding: 20px;
        text-align: center;
        font-style: italic;
      }

      /* Scrollbar styling */
      .raw-message-list::-webkit-scrollbar {
        width: 12px;
        height: 12px;
      }

      .raw-message-list::-webkit-scrollbar-track {
        background-color: #1e1e1e;
      }

      .raw-message-list::-webkit-scrollbar-thumb {
        background-color: #464647;
        border-radius: 4px;
      }

      .raw-message-list::-webkit-scrollbar-thumb:hover {
        background-color: #5a5a5a;
      }
    `;
    document.head.appendChild(style);
  }

  /**
   * Attach event listeners to controls
   */
  attachEventListeners() {
    document.getElementById('raw-message-close-btn')?.addEventListener('click', () => this.hide());
    document.getElementById('raw-msg-filter-direction')?.addEventListener('change', (e) => {
      this.filterDirection = e.target.value;
      this.updateMessageDisplay();
    });
    document.getElementById('raw-msg-autoscroll')?.addEventListener('change', (e) => {
      this.autoScroll = e.target.checked;
    });
    document.getElementById('raw-msg-clear-btn')?.addEventListener('click', () => {
      this.collector.clear();
      this.updateMessageDisplay();
    });
    document.getElementById('raw-msg-export-json-btn')?.addEventListener('click', () => this.exportJSON());
    document.getElementById('raw-msg-export-csv-btn')?.addEventListener('click', () => this.exportCSV());
  }

  /**
   * Called when a new message is added to the collector
   */
  onNewMessage(entry) {
    if (!this.isVisible) {
      return; // Don't update if not visible
    }

    if (!this.shouldDisplayMessage(entry)) {
      return;
    }

    this.addMessageToDisplay(entry);

    if (this.autoScroll) {
      const messageList = document.getElementById('raw-message-list');
      if (messageList) {
        messageList.scrollTop = messageList.scrollHeight;
      }
    }
  }

  /**
   * Check if message should be displayed based on current filters
   */
  shouldDisplayMessage(entry) {
    if (this.filterDirection !== 'all' && entry.direction !== this.filterDirection) {
      return false;
    }
    return true;
  }

  /**
   * Add a message to the display
   */
  addMessageToDisplay(entry) {
    const messageList = document.getElementById('raw-message-list');
    if (!messageList) return;

    // Remove empty message if it exists
    const emptyMsg = messageList.querySelector('.raw-message-empty');
    if (emptyMsg) {
      emptyMsg.remove();
    }

    const messageEl = document.createElement('div');
    messageEl.className = `raw-message-item ${entry.direction}`;

    const timeEl = document.createElement('span');
    timeEl.className = 'raw-message-item-time';
    const time = new Date(entry.timestamp).toLocaleTimeString('en-US', {
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3
    });
    timeEl.textContent = time;

    const directionEl = document.createElement('span');
    directionEl.className = 'raw-message-item-direction';
    directionEl.textContent = entry.direction === 'sent' ? '<<' : '>>';

    const textEl = document.createElement('span');
    textEl.className = 'raw-message-item-text';
    textEl.textContent = entry.message;

    messageEl.appendChild(timeEl);
    messageEl.appendChild(directionEl);
    messageEl.appendChild(textEl);

    messageList.appendChild(messageEl);
    this.messageViews.push(messageEl);

    // Limit number of visible elements to prevent memory issues
    const maxVisibleMessages = 1000;
    if (this.messageViews.length > maxVisibleMessages) {
      const removed = this.messageViews.shift();
      removed.remove();
    }
  }

  /**
   * Update the entire message display based on filters
   */
  updateMessageDisplay() {
    const messageList = document.getElementById('raw-message-list');
    if (!messageList) return;

    messageList.innerHTML = '';
    this.messageViews = [];

    const messages = this.collector.getMessages();
    const filteredMessages = messages.filter(msg => this.shouldDisplayMessage(msg));

    if (filteredMessages.length === 0) {
      messageList.innerHTML = '<div class="raw-message-empty">No messages match the filters</div>';
      return;
    }

    filteredMessages.forEach(entry => this.addMessageToDisplay(entry));

    if (this.autoScroll) {
      messageList.scrollTop = messageList.scrollHeight;
    }
  }

  /**
   * Show the viewer
   */
  show() {
    const container = document.getElementById(this.containerId);
    if (container) {
      container.style.display = 'flex';
      container.style.flexDirection = 'column';
      container.style.flex = 0.30; // 30% width
      this.isVisible = true;
      this.updateMessageDisplay();

      // Show the divider
      const divider = document.getElementById('resize-divider');
      if (divider) {
        divider.style.display = 'block';
      }

      // Set canvas pane to 70%
      const canvasPane = document.getElementById('canvas-pane');
      if (canvasPane) {
        canvasPane.style.flex = 0.70;
      }

      console.log('[RAW_MESSAGE_VIEWER] Shown - canvas 70%, viewer 30%');
    }
  }

  /**
   * Hide the viewer
   */
  hide() {
    const container = document.getElementById(this.containerId);
    if (container) {
      container.style.display = 'none';
      container.style.flex = 0; // Take no space
      this.isVisible = false;

      // Hide the divider
      const divider = document.getElementById('resize-divider');
      if (divider) {
        divider.style.display = 'none';
      }

      // Set canvas pane to 100%
      const canvasPane = document.getElementById('canvas-pane');
      if (canvasPane) {
        canvasPane.style.flex = 1;
      }

      console.log('[RAW_MESSAGE_VIEWER] Hidden - canvas 100%');
    }
  }

  /**
   * Toggle viewer visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Export messages as JSON file
   */
  exportJSON() {
    const json = this.collector.exportAsJSON();
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `pfod-messages-${new Date().toISOString().replace(/:/g, '-')}.json`;
    link.click();
    URL.revokeObjectURL(url);
    console.log('[RAW_MESSAGE_VIEWER] Exported as JSON');
  }

  /**
   * Export messages as CSV file
   */
  exportCSV() {
    const csv = this.collector.exportAsCSV();
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `pfod-messages-${new Date().toISOString().replace(/:/g, '-')}.csv`;
    link.click();
    URL.revokeObjectURL(url);
    console.log('[RAW_MESSAGE_VIEWER] Exported as CSV');
  }
}

// Make classes available globally
window.MessageCollector = MessageCollector;
window.RawMessageViewer = RawMessageViewer;



/* ========================================
 * Inlined from: pfodWebDebug.js
 * ======================================== */
/*   
   pfodWebDebug.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// Canvas Drawing Application
// Dependencies are loaded as global variables via script tags
// MergeAndRedraw and DrawingManager are available on window object


// JavaScript version constant loaded globally from version.js
// JS_VERSION is available as a global variable

// DrawingViewer class to encapsulate all viewer functionality
class DrawingViewer {
  constructor(options = {}) {
    console.log('[PFODWEB_DEBUG] DrawingViewer constructor called - NEW INSTANCE CREATED');
    console.log('[PFODWEB_DEBUG] URL:', window.location.href);
    console.log('[PFODWEB_DEBUG] Referrer:', document.referrer);
    console.log('[PFODWEB_DEBUG] Constructor options:', options);

    // Check if we have a pre-connected ConnectionManager from connectWithPrompt
    if (window.pfodConnectionManager) {
      console.log('[PFODWEB_DEBUG] Using pre-connected ConnectionManager from connectWithPrompt');
      // Use the existing ConnectionManager directly - it already has all protocol info and connection details
      this.connectionManager = window.pfodConnectionManager;
      this.protocol = this.connectionManager.protocol;
      this.targetIP = this.connectionManager.config?.targetIP || null;
      this.baudRate = this.connectionManager.config?.baudRate || 115200;
      console.log('[PFODWEB_DEBUG] Set protocol from ConnectionManager:', this.protocol);
      // Keep the global for error messages - will be cleared on page reload
    } else {
      // Extract protocol, target IP, and baud rate from URL parameters (fallback for HTTP with targetIP in URL)
      this.protocol = this.extractProtocol();
      this.targetIP = this.extractTargetIP();
      this.baudRate = this.extractBaudRate();
      console.log('[PFODWEB_DEBUG] Protocol:', this.protocol);
      console.log('[PFODWEB_DEBUG] Target IP:', this.targetIP);
      console.log('[PFODWEB_DEBUG] Baud Rate:', this.baudRate);

      // Initialize ConnectionManager with selected protocol
      this.connectionManager = new ConnectionManager({
        protocol: this.protocol,
        targetIP: this.targetIP,
        baudRate: this.baudRate
      });
    }
    console.log('[PFODWEB_DEBUG] ConnectionManager initialized with protocol:', this.protocol);

    // DOM Elements
    this.canvas = document.getElementById('drawing-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.canvasContainer = document.getElementById('canvas-container');

    // Application State - each viewer has its own isolated state
    this.updateTimer = null;
    this.isUpdating = false; // Start with updates disabled until first load completes
    this.js_ver = window.JS_VERSION; // Client JavaScript version

    // Request queue system - isolated per viewer
    this.requestQueue = [];
    // Use simple boolean for queue processing state (single-threaded JavaScript environment)
    this._isProcessingQueue = false;
    console.log(`[SENTREQUEST] CLEARED: on creation`);
    this.sentRequest = null; // Currently in-flight request
    this.currentRetryCount = 0;
    // MAX_RETRIES will be set based on connection manager's protocol
    // It's accessed dynamically via this.connectionManager.getMaxRetries()

    // Request tracking for touch vs insertDwg - isolated per viewer
    this.requestTracker = {
      touchRequests: new Set(), // Track touch-triggered requests
      insertDwgRequests: new Set() // Track insertDwg-triggered requests
    };

    // Unified shadow processing system for all request types (always active)
    this.shadowProcessing = {
      responses: new Map(), // drawingName -> response data
      requestType: null, // 'main', 'refresh', 'touch', 'insertDwg', etc.
      shadowDrawingManager: new DrawingManager() // shadow copy of drawing manager
    };

    // Transformation state for push/pop operations - used during JSON processing
    this.transformStack = []; // Stack to store transformation states

    // Map to store all active touchZones by command - now managed by DrawingManager
    // this.touchZonesByCmd = {}; // Format: {cmd: touchZone} - DEPRECATED

    // Window dimension tracking for change detection and saving
    this.lastLogicalWidth = null;
    this.lastLogicalHeight = null;
    this.lastWindowWidth = null;
    this.lastWindowHeight = null;

    // Load previous window dimensions from storage to pass to redraw
    const initialDimensions = this.loadPreviousDimensions();

    // Initialize our tracking with loaded dimensions
    if (initialDimensions) {
      this.lastLogicalWidth = initialDimensions.logicalWidth;
      this.lastLogicalHeight = initialDimensions.logicalHeight;
      this.lastWindowWidth = initialDimensions.windowWidth;
      this.lastWindowHeight = initialDimensions.windowHeight;
    }

    // Touch state for handling mouse/touch events - instance-specific
    this.touchState = {
      isDown: false,
      wasDown: false,
      startX: 0,
      startY: 0,
      lastX: 0,
      lastY: 0,
      startTime: 0,
      longPressTimer: null,
      targetTouchZone: null,
      hasEnteredZones: new Set(),
      hasDragged: false,
      lastSentTouchType: null
    };

    // Current identifier for touchZone requests - defaults to 'pfodWeb'
    this.currentIdentifier = 'pfodWeb';

    // Queue for holding responses while mouse is down (to prevent flashing)
    this.pendingResponseQueue = [];

    // Update collection for atomic refresh processing
    // updateCollection removed - using unified shadow processing system

    // Text input dialog state
    this.textInputDialog = null;

    // Transformation state for push/pop operations - used during JSON processing
    this.currentTransform = {
      x: 0,
      y: 0,
      scale: 1.0
    }; // Current transformation (initial state)

    // Create isolated MergeAndRedraw instance for this viewer
    // Create Redraw instance with canvas and context - uses its own local data
    this.redraw = new window.Redraw(this.canvas, this.ctx, initialDimensions);

    // Create DrawingDataProcessor instance for this viewer
    this.drawingDataProcessor = new window.DrawingDataProcessor(this);

    // Initialize Message Collector and Viewer
    this.initializeMessageViewer();

    // Set up event listeners using pfodWebMouse.js
    this.setupEventListeners();
  }

  /**
   * Initialize message collector and raw message viewer
   */
  initializeMessageViewer() {
    try {
      // Skip message viewer and collector initialization if designer parameter is present
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('designer')) {
        console.log('[PFODWEB_DEBUG] Designer mode detected - skipping message viewer and collector initialization');
        return;
      }

      // Create message collector if not already created
      if (!window.messageCollector) {
        window.messageCollector = new MessageCollector(500);
        ConnectionManager.setMessageCollector(window.messageCollector);
        console.log('[PFODWEB_DEBUG] Message collector created and set on ConnectionManager');
      }

      // Create raw message viewer
      window.rawMessageViewer = new RawMessageViewer(window.messageCollector, 'raw-message-viewer');
      window.rawMessageViewer.initialize();
      console.log('[PFODWEB_DEBUG] Raw message viewer initialized');

      // Add a keyboard shortcut to toggle the viewer (Ctrl+Shift+M)
      document.addEventListener('keydown', (event) => {
        if (event.ctrlKey && event.shiftKey && event.key === 'M') {
          event.preventDefault();
          if (window.rawMessageViewer) {
            window.rawMessageViewer.toggle();
          }
        }
      });
      console.log('[PFODWEB_DEBUG] Keyboard shortcut Ctrl+Shift+M added to toggle message viewer');
    } catch (error) {
      console.error('[PFODWEB_DEBUG] Error initializing message viewer:', error);
    }
  }

  // Extract protocol from URL parameters
  extractProtocol() {
    console.log(`[PROTOCOL] Extracting protocol from URL parameters`);
    console.log(`[PROTOCOL] window.location.search: ${window.location.search}`);

    // Infer protocol from parameter presence
    const urlParams = new URLSearchParams(window.location.search);

    // Check for protocol-specific parameters
    if (urlParams.has('serial')) {
      console.log(`[PROTOCOL] Found 'serial' parameter - using Serial protocol`);
      return 'serial';
    } else if (urlParams.has('ble')) {
      console.log(`[PROTOCOL] Found 'ble' parameter - using BLE protocol`);
      return 'ble';
    } else if (urlParams.has('targetIP')) {
      console.log(`[PROTOCOL] Found 'targetIP' parameter - using HTTP protocol`);
      return 'http';
    }

    // Default to HTTP if not specified
    console.log(`[PROTOCOL] No protocol-specific parameters found, defaulting to 'http'`);
    return 'http';
  }

  // Extract target IP address from URL parameters or global variable
  extractTargetIP() {
    console.log(`[TARGET_IP] Extracting target IP from URL or global variable`);
    console.log(`[TARGET_IP] window.PFOD_TARGET_IP: ${window.PFOD_TARGET_IP}`);
    console.log(`[TARGET_IP] window.location.search: ${window.location.search}`);

    // First check if global variable was set by index.html
    if (window.PFOD_TARGET_IP) {
      console.log(`[TARGET_IP] Using global variable: ${window.PFOD_TARGET_IP}`);
      return window.PFOD_TARGET_IP;
    }

    // Extract from URL parameters (e.g., ?targetIP=192.168.1.100)
    const urlParams = new URLSearchParams(window.location.search);
    const targetIP = urlParams.get('targetIP');
    console.log(`[TARGET_IP] URL parameter targetIP: ${targetIP}`);

    if (targetIP) {
      // Validate IP address format
      const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
      if (ipRegex.test(targetIP)) {
        const parts = targetIP.split('.');
        // Validate IP address ranges
        const isValidIP = parts.every(part => {
          const num = parseInt(part, 10);
          return num >= 0 && num <= 255;
        });
        if (isValidIP) {
          console.log(`[TARGET_IP] Valid IP found: ${targetIP}`);
          return targetIP;
        } else {
          console.log(`[TARGET_IP] Invalid IP ranges in: ${targetIP}`);
        }
      } else {
        console.log(`[TARGET_IP] Invalid IP format: ${targetIP}`);
      }
    }

    console.log(`[TARGET_IP] No valid target IP found, returning null`);
    return null;
  }

  // Extract baud rate from URL parameters
  extractBaudRate() {
    console.log(`[BAUD_RATE] Extracting baud rate from URL parameters`);
    console.log(`[BAUD_RATE] window.location.search: ${window.location.search}`);

    // Extract from URL parameters - can be ?serial=115200 or standalone ?baudRate=115200
    const urlParams = new URLSearchParams(window.location.search);

    // First check if serial parameter has a value (e.g., ?serial=115200)
    const serialValue = urlParams.get('serial');
    console.log(`[BAUD_RATE] URL parameter serial: ${serialValue}`);

    if (serialValue && serialValue !== '') {
      // Parse and validate baud rate from serial parameter value
      const parsedBaudRate = parseInt(serialValue, 10);
      const validBaudRates = [9600, 19200, 38400, 57600, 74880, 115200];

      if (validBaudRates.includes(parsedBaudRate)) {
        console.log(`[BAUD_RATE] Valid baud rate found in serial parameter: ${parsedBaudRate}`);
        return parsedBaudRate;
      } else {
        console.log(`[BAUD_RATE] Invalid baud rate in serial parameter: ${serialValue}, defaulting to 115200`);
      }
    }

    // Fallback to baudRate parameter (for backwards compatibility)
    const baudRate = urlParams.get('baudRate');
    console.log(`[BAUD_RATE] URL parameter baudRate: ${baudRate}`);

    if (baudRate) {
      // Parse and validate baud rate
      const parsedBaudRate = parseInt(baudRate, 10);
      const validBaudRates = [9600, 19200, 38400, 57600, 74880, 115200];

      if (validBaudRates.includes(parsedBaudRate)) {
        console.log(`[BAUD_RATE] Valid baud rate found: ${parsedBaudRate}`);
        return parsedBaudRate;
      } else {
        console.log(`[BAUD_RATE] Invalid baud rate: ${baudRate}, defaulting to 9600`);
      }
    }

    // Default to 115200 if not specified or invalid
    console.log(`[BAUD_RATE] No valid baud rate found, defaulting to 115200`);
    return 115200;
  }

  // Build endpoint URL with target IP
  buildEndpoint(path) {
    console.log(`[ENDPOINT] buildEndpoint called with path: ${path}, targetIP: ${this.targetIP}`);
    if (this.targetIP) {
      const fullEndpoint = `http://${this.targetIP}${path}`;
      console.log(`[ENDPOINT] Built full endpoint: ${fullEndpoint}`);
      return fullEndpoint;
    }
    console.log(`[ENDPOINT] No targetIP, returning relative path: ${path}`);
    return path; // Fallback to relative URL
  }

  // Build fetch options with appropriate CORS settings
  buildFetchOptions(additionalHeaders = {}) {
    return {
      headers: {
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        ...additionalHeaders
      },
      mode: this.targetIP ? 'cors' : 'same-origin',
      credentials: this.targetIP ? 'omit' : 'same-origin',
      cache: 'no-cache'
    };
  }

  // Get context-specific storage key based on referrer and current URL
  getDimensionStorageKey() {
    const isIframe = window.self !== window.top;
    const referrer = document.referrer;

    if (isIframe && referrer) {
      // Extract page name from referrer for iframe context
      const referrerPath = new URL(referrer).pathname;
      const pageName = referrerPath.split('/').pop().split('.')[0] || 'unknown';
      return `pfodWeb_dimensions_iframe_${pageName}`;
    } else {
      // Main window context
      return 'pfodWeb_dimensions_main';
    }
  }

  // Load previous dimensions from localStorage to pass to redraw
  loadPreviousDimensions() {
    try {
      const storageKey = this.getDimensionStorageKey();
      const saved = localStorage.getItem(storageKey);
      if (saved) {
        const dims = JSON.parse(saved);
        console.log(`[DIMENSIONS] Loaded previous dimensions from ${storageKey}: logical=${dims.logicalWidth}x${dims.logicalHeight}, window=${dims.windowWidth}x${dims.windowHeight}`);
        return dims;
      } else {
        console.log(`[DIMENSIONS] No previous dimensions found for ${storageKey}`);
        return null;
      }
    } catch (e) {
      console.log('[DIMENSIONS] Error loading dimensions:', e);
      return null;
    }
  }

  // Handle resize with dimension change detection and saving
  handleResize() {
    // Get current drawing data to determine logical dimensions
    const logicalDrawingData = this.redraw.redrawDrawingManager.getCurrentDrawingData();
    if (!logicalDrawingData) {
      console.warn('No drawing data available for resize handling');
      this.redraw.resizeCanvas(this.touchState);
      return;
    }

    // Get current dimensions
    const logicalWidth = Math.min(Math.max(logicalDrawingData.x, 1), 255);
    const logicalHeight = Math.min(Math.max(logicalDrawingData.y, 1), 255);
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    // Check if dimensions have changed
    const dimensionsChanged = (
      this.lastLogicalWidth !== logicalWidth ||
      this.lastLogicalHeight !== logicalHeight ||
      this.lastWindowWidth !== windowWidth ||
      this.lastWindowHeight !== windowHeight
    );

    // Update tracking and save if dimensions changed
    if (dimensionsChanged) {
      console.log(`[DIMENSIONS] Dimensions changed - saving: logical=${logicalWidth}x${logicalHeight}, window=${windowWidth}x${windowHeight}`);

      this.lastLogicalWidth = logicalWidth;
      this.lastLogicalHeight = logicalHeight;
      this.lastWindowWidth = windowWidth;
      this.lastWindowHeight = windowHeight;

      // Save to localStorage
      this.saveDimensions(logicalWidth, logicalHeight, windowWidth, windowHeight);
    }

    // Call redraw to handle the actual resizing and redraw elements
    this.redraw.resizeCanvas(this.touchState);
    this.redraw.performRedraw();
  }

  // Save current dimensions to localStorage for future reloads
  saveDimensions(logicalWidth, logicalHeight, windowWidth, windowHeight) {
    try {
      const dims = {
        logicalWidth: logicalWidth,
        logicalHeight: logicalHeight,
        windowWidth: windowWidth,
        windowHeight: windowHeight
      };
      const storageKey = this.getDimensionStorageKey();
      localStorage.setItem(storageKey, JSON.stringify(dims));
      console.log(`[DIMENSIONS] Saved dimensions to ${storageKey}: logical=${logicalWidth}x${logicalHeight}, window=${windowWidth}x${windowHeight}`);
    } catch (e) {
      console.log('[DIMENSIONS] Error saving dimensions:', e);
    }
  }

  // Set up event listeners for the canvas - delegates to pfodWebMouse.js
  setupEventListeners() {
    // Mouse and touch event handling is now in pfodWebMouse.js
    if (typeof window.pfodWebMouse !== 'undefined') {
      window.pfodWebMouse.setupEventListeners(this);
    } else {
      console.error('pfodWebMouse.js not loaded - mouse events will not work');
    }

    // Setup context menu for right-click access to message viewer
    this.setupContextMenu();
  }

  /**
   * Setup right-click context menu
   */
  setupContextMenu() {
    // Skip context menu setup if designer parameter is present
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('designer')) {
      console.log('[PFODWEB_DEBUG] Designer mode detected - skipping context menu setup');
      return;
    }

    const canvas = document.getElementById('drawing-canvas');
    if (!canvas) {
      console.warn('[CONTEXT_MENU] Canvas not found');
      return;
    }

    // Create context menu container
    const contextMenu = document.createElement('div');
    contextMenu.id = 'pfod-context-menu';
    contextMenu.style.cssText = `
      display: none;
      position: fixed;
      background-color: #2d2d30;
      border: 1px solid #555;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 10000;
      min-width: 200px;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 12px;
    `;

    contextMenu.innerHTML = `
      <div class="pfod-context-menu-item" data-action="show-messages">
        <span style="color: #ce9178; margin-right: 8px;">📊</span>
        Show Raw Messages
        <span style="color: #858585; margin-left: auto; margin-left: 20px; font-size: 10px;">Ctrl+Shift+M</span>
      </div>
    `;

    // Add styles for menu items
    const style = document.createElement('style');
    style.textContent = `
      .pfod-context-menu-item {
        padding: 8px 12px;
        color: #d4d4d4;
        cursor: pointer;
        display: flex;
        align-items: center;
        user-select: none;
        transition: background-color 0.15s;
      }

      .pfod-context-menu-item:hover {
        background-color: #3e3e42;
      }

      .pfod-context-menu-item:active {
        background-color: #454545;
      }

      .pfod-context-menu-divider {
        height: 1px;
        background-color: #3e3e42;
        margin: 4px 0;
      }
    `;
    document.head.appendChild(style);
    document.body.appendChild(contextMenu);

    // Handle right-click on canvas
    canvas.addEventListener('contextmenu', (event) => {
      event.preventDefault();
      this.showContextMenu(event.clientX, event.clientY, contextMenu);
    });

    // Close menu on document click
    document.addEventListener('click', (event) => {
      if (event.target.closest('#pfod-context-menu')) {
        return; // Don't close if clicking menu
      }
      contextMenu.style.display = 'none';
    });

    // Handle menu item clicks
    contextMenu.addEventListener('click', (event) => {
      const item = event.target.closest('.pfod-context-menu-item');
      if (!item) return;

      const action = item.dataset.action;
      contextMenu.style.display = 'none';

      switch (action) {
        case 'show-messages':
          if (window.rawMessageViewer) {
            window.rawMessageViewer.show();
            console.log('[CONTEXT_MENU] Opened message viewer');
          }
          break;
        case 'clear-messages':
          if (window.messageCollector) {
            window.messageCollector.clear();
            console.log('[CONTEXT_MENU] Cleared all messages');
          }
          break;
        case 'export-json':
          if (window.rawMessageViewer) {
            window.rawMessageViewer.exportJSON();
            console.log('[CONTEXT_MENU] Exported messages as JSON');
          }
          break;
        case 'export-csv':
          if (window.rawMessageViewer) {
            window.rawMessageViewer.exportCSV();
            console.log('[CONTEXT_MENU] Exported messages as CSV');
          }
          break;
      }
    });

    console.log('[CONTEXT_MENU] Context menu setup complete');
  }

  /**
   * Show context menu at specified position
   */
  showContextMenu(x, y, menu) {
    menu.style.display = 'block';
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Adjust if menu goes off-screen
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) {
      menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    }
    if (rect.bottom > window.innerHeight) {
      menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
    }

    console.log('[CONTEXT_MENU] Showing at', x, y);
  }

  // Queue initial request using existing request queue system
  queueInitialRequest() {
    const startupCmd = '{.}';

    console.log('Sending {.} request without version to get drawing name from server via session context');
    console.log(`Queueing initial request with command: ${startupCmd}`);

    // Add to request queue with mainMenu type - not a drawing request
    const requestType = 'mainMenu';
    this.addToRequestQueue(null, startupCmd, null, null, requestType);
  }

  // Update page title to include main drawing name
//  updatePageTitle(drawingName) {
//    if (drawingName) {
//      document.title = `pfodWeb ${drawingName}`;
//    }
//  }

  // Load drawing data from the server
  async loadDrawing() {
    // Main drawing is always the first in the array
    const currentDrawingName = this.redraw.redrawDrawingManager.getCurrentDrawingName();
    if (!currentDrawingName) {
      console.error('No drawing name specified');
      return;
    }

    try {
      // Disable updates during loading
      this.isUpdating = false;
      // Clear any existing timer
      if (this.updateTimer) {
        clearTimeout(this.updateTimer);
        this.updateTimer = null;
      }

      // Check if we have a saved version
      const savedVersion = localStorage.getItem(`${currentDrawingName}_version`);
      const savedData = localStorage.getItem(`${currentDrawingName}_data`);

      let cmd;
      if (savedVersion) {
        cmd = '{' + savedVersion+ ':'+ currentDrawingName + '}';
        console.log(`Using saved version: ${savedVersion}`);
      } else {
        console.log('No valid saved version+data pair - requesting fresh data (dwg:start)');
        cmd = '{' + currentDrawingName + '}';
      }

      console.log(`Requesting drawing with command: ${cmd}`);

      // Add main drawing request to the queue
      this.addToRequestQueue(currentDrawingName, cmd, null, null, 'main');
    } catch (error) {
      console.error('Failed to load drawing:', error);
      this.isUpdating = true; // Re-enable updates even if loading failed
    }
  }

  // Schedule the next update request
  scheduleNextUpdate() {
    const mainDrawingName = this.redraw.getCurrentDrawingName();
    console.log(`[SCHEDULE_NEXT_UPDATE] ${mainDrawingName}`);
    // Clear any existing timer first
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
      console.log('Cleared existing update timer');
    }

    // Get the current main drawing data from redraw system (where data is actually stored after processing)
    const currentDrawingData = this.redraw.redrawDrawingManager.drawingsData[mainDrawingName]?.data;

    // Only schedule an update if refresh is greater than 0, mouse is not down, queue is empty, and no request in flight
    // This ensures that a refresh value of 0 properly disables automatic updates
    // and prevents updates during mouse interactions or ongoing queue processing
    if (this.isUpdating && currentDrawingData && currentDrawingData.refresh > 0 && !this.touchState.isDown &&
        this.requestQueue.length === 0 && !this.sentRequest) {
      console.log(`[REFRESH] Scheduling next update in ${currentDrawingData.refresh}ms for drawing "${this.redraw.getCurrentDrawingName()}"`);
      this.updateTimer = setTimeout(() => this.fetchRefresh(), currentDrawingData.refresh);
      // Also schedule updates for inserted drawings
      if (this.redraw.redrawDrawingManager.drawings.length > 1) {
        console.log(`Will fetch updates for ${this.redraw.redrawDrawingManager.drawings.length - 1} inserted drawings during next update cycle`);
      }
    } else if (currentDrawingData && currentDrawingData.refresh === 0) {
      console.log(`[REFRESH] Automatic updates disabled (refresh=0) for drawing "${this.redraw.getCurrentDrawingName()}"`);
    } else if (!currentDrawingData) {
      console.log('[REFRESH] No drawing data available, cannot schedule updates');
    } else if (!this.isUpdating) {
      console.log('[REFRESH] Updates currently paused');
    } else if (this.touchState.isDown) {
      console.log('[REFRESH] Skipping update scheduling - mouse is down');
    } else if (this.requestQueue.length > 0) {
      console.log(`[REFRESH] Skipping update scheduling - queue not empty (${this.requestQueue.length} requests)`);
    } else if (this.sentRequest) {
      console.log(`[REFRESH] Skipping update scheduling - request in flight for "${this.sentRequest.drawingName}"`);
    }

  }

  // Fetch refreshes from the server
  async fetchRefresh() {
    console.log(`[REFRESH] Refresh timer fired - starting update cycle for drawing "${this.redraw.getCurrentDrawingName()}" at ${new Date().toISOString()}`);

    // Block update requests if user activity is present
    if (this.touchState.isDown) {
      console.log(`[REFRESH] Blocking update cycle - mouse is down`);
      this.scheduleNextUpdate(); // Reschedule for later
      return;
    }

    // Check if queue has user requests (non-refresh requestType)
    const hasUserRequests = this.requestQueue.some(req => req.requestType !== 'refresh');
    if (hasUserRequests) {
      console.log(`[REFRESH] Blocking refresh cycle - user requests in queue`);
      this.scheduleNextUpdate(); // Reschedule for later
      return;
    }

    // Check if user request is in flight (non-refresh requestType)
    if (this.sentRequest && this.sentRequest.requestType !== 'refresh') {
      console.log(`[REFRESH] Blocking refresh cycle - user request in flight (${this.sentRequest.requestType})`);
      this.scheduleNextUpdate(); // Reschedule for later
      return;
    }

    // Check if shadow processing is already active
    if (this.shadowProcessing.requestType) {
      console.log(`[REFRESH] Shadow processing already active (${this.shadowProcessing.requestType}), waiting for completion`);
      // Don't reschedule - let the current processing complete and schedule naturally
      return;
    }

    try {
      // Get main drawing name from redraw manager (same as scheduleNextUpdate)
      const mainDrawingName = this.redraw.redrawDrawingManager.getMainDrawingName();
      const currentDrawingData = this.redraw.redrawDrawingManager.drawingsData[mainDrawingName]?.data;

      if (!currentDrawingData || !mainDrawingName) {
        throw new Error('No active drawing');
      }

      // Set flag to indicate we're currently updating
      this.isUpdating = false;

      console.log(`[UPDATE] Starting update cycle at ${new Date().toISOString()}`);

      // TODO: Need to introduce concept of current drawing different from drawings[0]
      // For now, using drawings[0] as current drawing but this needs architectural change
      const currentDrawingName = this.redraw.redrawDrawingManager.drawings.length > 0 ? this.redraw.redrawDrawingManager.drawings[0] : '';
      console.log(`[UPDATE] Current drawing: "${currentDrawingName}", inserted drawings: ${this.redraw.redrawDrawingManager.drawings.length - 1}`);

      // Update collection removed - using unified shadow processing system

      // First, queue the current drawing update
      console.log(`[UPDATE] Queueing update for current drawing "${currentDrawingName}"`);
      await this.queueDrawingUpdate(currentDrawingName);

      // Inserted drawings will be queued automatically as they're discovered during response processing

      // Re-enable updates
      this.isUpdating = true;
      this.scheduleNextUpdate();
      console.log(`[UPDATE] Update cycle queued at ${new Date().toISOString()}`);
    } catch (error) {
      console.error('[UPDATE] Failed to update drawing:', error);
      // Re-enable updates even if this one failed
      this.isUpdating = true;
      this.scheduleNextUpdate();
    }
  }

  // Add a request to the queue
  addToRequestQueue(drawingName, cmd, options, touchZoneInfo, requestType = 'unknown') {
    console.warn(`[QUEUE] Adding request for "${drawingName}" to queue (type: ${requestType})`);
    console.log(`[QUEUE] Command "${cmd}"`);
    console.log(`[QUEUE] Current shadow processing type: ${this.shadowProcessing.requestType}`);
    console.log(`[QUEUE] Queue length before add: ${this.requestQueue.length}, sentRequest: ${this.sentRequest ? this.sentRequest.drawingName + '(' + this.sentRequest.requestType + ')' : 'null'}`);
    if (requestType == 'unknown') {
      console.error(`[QUEUE] Error: Unknown requestType`);
      return;
    }

    // If this is a non-refresh request, clean up any existing refresh requests
    if (requestType !== 'refresh') {
      // Remove all refresh requests from queue
      const refreshRequestsInQueue = this.requestQueue.filter(req => req.requestType === 'refresh');
      if (refreshRequestsInQueue.length > 0) {
        this.requestQueue = this.requestQueue.filter(req => req.requestType !== 'refresh');
        console.log(`[QUEUE] Removed ${refreshRequestsInQueue.length} refresh requests from queue due to user activity`);
      }

      // Mark sent refresh request for discard
      if (this.sentRequest && this.sentRequest.requestType === 'refresh') {
        this.sentRequest.discardResponse = true;
        console.log(`[QUEUE] Marked sent refresh request for "${this.sentRequest.drawingName}" to be discarded`);
      }
    }

    this.setProcessingQueue(true);

    // Track the request type
    if (requestType === 'touch') {
      this.requestTracker.touchRequests.add(drawingName);
      console.log(`[QUEUE] Tracking touch request for "${drawingName}"`);
    } else if (requestType === 'insertDwg') {
      this.requestTracker.insertDwgRequests.add(drawingName);
      console.log(`[QUEUE] Tracking insertDwg request for "${drawingName}"`);
    }

    // Check if this is a drag request and remove any existing drag requests from the same touchZone cmd
    if (touchZoneInfo && touchZoneInfo.filter === TouchZoneFilters.DRAG) {
      const cmd = touchZoneInfo.cmd;
      console.log(`[QUEUE] Removing existing DRAG requests for cmd="${cmd}" to minimize network traffic`);

      // Remove existing drag requests from the same cmd
      this.requestQueue = this.requestQueue.filter(request => {
        const isDragRequest = request.touchZoneInfo &&
          request.touchZoneInfo.filter === TouchZoneFilters.DRAG &&
          request.touchZoneInfo.cmd === cmd;
        if (isDragRequest) {
          console.log(`[QUEUE] Removed duplicate DRAG request for cmd="${cmd}"`);
        }
        return !isDragRequest;
      });
    }

    this.requestQueue.push({
      drawingName: drawingName,
      cmd: cmd,
      retryCount: 0,
      touchZoneInfo: touchZoneInfo,
      requestType: requestType
    });
    console.warn(`[QUEUE] addToRequestQueue current queue is:`, JSON.stringify(this.requestQueue, null, 2));
    // Process the queue if not already processing
    this.processRequestQueue();
  }

  // process response of type {,..|+A} and {; ,,|+A~dwgName}
  processMenuResponse(data, request) {
    let cmd;
    if (data.cmd) {
      cmd = data.cmd;
    } else {
      console.log('[QUEUE] No cmd field in server response ', JSON.stringify(data));
      return false;
    }
    let msgType = cmd[0];
    if (!(msgType.startsWith("{,") || msgType.startsWith("{;"))) {
      console.log('[QUEUE] Not a menu response ', JSON.stringify(data));
      return false;
    }

    let result = translateMenuResponse(cmd);
    if (result.pfodDrawing == 'error') {
      this.handleDrawingError(result);
      return false;
    }

    // result has form
    //    const result = {
    //  pfodDrawing: 'menu',
    //  drawingName: ${drawingName}', << may be empty
    //  identifier: ${identifier}
    //});
    this.currentIdentifier = result.identifier;
    let drawingName;
    if (result.drawingName.trim() !== '') {
      drawingName = result.drawingName; // update it
    } else {
      drawingName = this.shadowProcessing.shadowDrawingManager.getCurrentDrawingName(); // assume we are updating main dwg from menu
    }
    console.log(`[processMenuResponse] Updated dwgName and currentDrawingName "${drawingName}"`);
    // Update page title with drawing name
   // this.updatePageTitle(drawingName);

    // Add the drawing as the first drawing in the array if not already present
    if (!this.shadowProcessing.shadowDrawingManager.drawings.includes(drawingName)) {
      this.shadowProcessing.shadowDrawingManager.drawings.unshift(drawingName);
    }

    // Check if server response includes version information
    let serverVersion = data.version;
    let storedVersion = null;
    let hasStoredData = false;

    // Get stored version for this drawing using DrawingManager
    if (this.shadowProcessing.shadowDrawingManager) {
      storedVersion = this.shadowProcessing.shadowDrawingManager.getStoredVersion(drawingName);
      // Check if we actually have saved data for this drawing (not just the version)
      hasStoredData = this.shadowProcessing.shadowDrawingManager.drawingsData[drawingName]?.data ? true : false;
    }

    // For updates without version info (like {;), assume version hasn't changed
    // Use stored version as fallback ONLY if we have actual stored data
    if (!serverVersion && storedVersion && hasStoredData) {
      serverVersion = storedVersion;
      console.log(`[QUEUE] No version in update - using stored version: ${storedVersion}`);
    }

    // Build the command string for the drawing request
    let drawingCmd;
    // Include version in command only if:
    // 1. We have actual stored data for this drawing
    // 2. We have a stored version that matches server version
    if (hasStoredData && storedVersion && serverVersion && storedVersion === serverVersion) {
      drawingCmd = '{' + storedVersion + ':' + drawingName + '}';
      console.log(`[QUEUE] Version match with stored data: Including version ${storedVersion} in {${drawingName}} request`);
    } else {
      drawingCmd = '{' + drawingName + '}';
      if (!hasStoredData) {
        console.log(`[QUEUE] No stored data for ${drawingName} - requesting initial data without version`);
      } else {
        console.log(`[QUEUE] Version mismatch or no stored version: Sending {${drawingName}} without version (stored: ${storedVersion}, server: ${serverVersion})`);
      }
    }

    // Queue the actual drawing request from main menu - add as first drawing and use 'main' requestType
    console.log(`[QUEUE] Main menu requesting drawing "${drawingName}" - adding to drawings[0] and using requestType: main`);
    // Add this drawing as the first drawing since it's from main menu
    if (!this.shadowProcessing.shadowDrawingManager.drawings.includes(drawingName)) {
      this.shadowProcessing.shadowDrawingManager.drawings.unshift(drawingName);
    }
    this.addToRequestQueue(drawingName, drawingCmd, request.options, null, 'main');
    console.log(`[QUEUE] Processed drawing menu item ${cmd}`);
    return true;
  }

  isEmptyCmd(cmd) {
    if (!cmd) {
      return false
    }
    if (cmd.length < 2) {
      return false;
    }
    let cmd0 = cmd[0].trim();
    let cmd1 = cmd[1].trim();
    if ((cmd0 == '{') && (cmd1 == '}')) {
      console.log(`[DRAWING_DATA] Received empty cmd response `);
      return true; // Successfully handled - no drawing data to process
    }
    return false;
  }

  // Atomic helper methods for queue processing state
  isProcessingQueue() {
    return this._isProcessingQueue;
  }

  setProcessingQueue(value) {
    const oldValue = this._isProcessingQueue;
    this._isProcessingQueue = value;
    console.log(`[QUEUE_STATE] setProcessingQueue(${value}) - oldValue: ${oldValue}, newValue: ${value}`);
    return value;
  }

  trySetProcessingQueue(expectedValue, newValue) {
    if (this._isProcessingQueue === expectedValue) {
      this._isProcessingQueue = newValue;
      console.log(`[QUEUE_STATE] trySetProcessingQueue(${expectedValue}, ${newValue}) - success: true`);
      return true;
    } else {
      console.log(`[QUEUE_STATE] trySetProcessingQueue(${expectedValue}, ${newValue}) - success: false, current: ${this._isProcessingQueue}`);
      return false;
    }
  }

  redrawCanvas() {
              // Update the MergeAndRedraw module with the latest state
      console.warn(`[QUEUE] redrawCanvas isDown: ${this.touchState.isDown}`);
              if (!this.touchState.isDown) {
                if (this.touchState.wasDown) {
                  this.touchState.wasDown = this.touchState.isDown;
               }
          // Redraw no longer needs access to drawingManager or requestQueue
          // Data is managed locally in redraw
              }

          // Redraw the canvas with what we have
          // Note: TouchAction redraws are now handled directly by pfodWebMouse calling redraw.redrawForTouchAction()
          // This method only handles normal redraws
          this.handleResize();
   }
    
   
  // Process the request queue
  async processRequestQueue() {
    // Safety check: ensure requestQueue is initialized
    if (!this.requestQueue) {
      console.error('[QUEUE] Error: requestQueue is undefined. Aborting queue processing.');
      return;
    }
    //if (this.sentRequest) {
    //  console.log(`[QUEUE] processRequestQueue have sentRequest, queue length: ${this.requestQueue.length}`);
    //} else {
    //  console.log(`[QUEUE] processRequestQueue no sentRequest, queue length: ${this.requestQueue.length}`);
    //}       
    // Try to atomically set processing state from false to true
//    if (!this.trySetProcessingQueue(false, true)) {
//      console.log(`[QUEUE] Already processing queue - skipping`);
//      return;
//    }

    // Return early if there's already a request in flight or queue is empty
    if (this.sentRequest || this.requestQueue.length === 0) {
      if (this.sentRequest) {
        //console.log(`[QUEUE] Request already in flight for "${this.sentRequest.drawingName}" - waiting`);
      }
      // Reset processing state before returning
      if (this.sentRequest) {
        this.setProcessingQueue(true);
      } else {
        //console.log(`[QUEUE] NO sentRequest and queue empty`);
        this.setProcessingQueue(false);

        // Only redraw if shadow processing is not active - check inUse flag
        if (!this.shadowProcessing.shadowDrawingManager.inUse) {
            //console.log(`[QUEUE] No shadow processing active - calling redrawCanvas for final display`);
            setTimeout(() => {
                this.redrawCanvas();
                this.scheduleNextUpdate();
            }, 10);
        } else {
            //console.log(`[QUEUE] Shadow processing active - skipping premature redraw`);
            // Resume update scheduling after a brief delay to allow shadow processing to complete
            setTimeout(() => {
                this.scheduleNextUpdate();
            }, 10);
        }
      }
      return;
    }

    console.log(`[QUEUE] processRequestQueue current queue is:`, JSON.stringify(this.requestQueue, null, 2));

 //    this.setProcessingQueue(true); // have non-zero queue length
    // Remove the request from queue and move it to sentRequest
    const request = this.requestQueue.shift();
    console.warn(`[QUEUE] PROCESSING: "${request.drawingName}" (${request.requestType}) - moved from queue to sentRequest`);
    console.warn(`[QUEUE] after setting sentRequest the current queue is:`, JSON.stringify(this.requestQueue, null, 2));
    this.sentRequest = request;
    console.log(`[SENTREQUEST] ASSIGNED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
    console.warn(`[QUEUE] sentRequest is:`, JSON.stringify(this.sentRequest, null, 2));

    try {
      if (request.retryCount > 0) {
       console.warn(`[QUEUE] Processing request for "${request.drawingName}" (retry: ${request.retryCount}/${this.connectionManager.getMaxRetries()})`);
      }

      // Initialize shadow processing for session-starting requests only
      // insertDwg and refresh-insertDwg requests are part of existing sessions
      if (['mainMenu', 'main', 'touch', 'refresh'].includes(request.requestType)) {
        try {
          this.initializeShadowProcessing(request);
        } catch (error) {
          console.error(`[SHADOW] Error initializing shadow processing:`, error);
          alert(`Shadow processing initialization error: ${error.message}`);
          return; // Stop processing this request
        }
      }

      // Track the touchZone filter and cmd for this request being sent
      if (request.touchZoneInfo) {
        if (!this.sentRequests) {
          this.sentRequests = [];
        }
        this.sentRequests.push({
          drawingName: request.drawingName,
          cmd: request.touchZoneInfo.cmd,
          filter: request.touchZoneInfo.filter,
          timestamp: Date.now()
        });
        console.log(`[QUEUE] Tracking sent request: cmd="${request.touchZoneInfo.cmd}", filter="${request.touchZoneInfo.filter}"`);
      }
      // Use ConnectionManager to send command
      console.log(`[QUEUE] Sending command: ${request.cmd}`);

      const responseText = await this.connectionManager.send(request.cmd);

      // Create response-like object for compatibility with existing code
      const response = {
        ok: true,
        status: 200,
        text: async () => responseText
      };

      console.warn(`[QUEUE] Received response for "${request.drawingName}": status ${response.status}, queue length: ${this.requestQueue.length}`);

      if (!response.ok) {
        throw new Error(`Server returned ${response.status} for drawing "${request.drawingName}"`);
      }

      // Log the raw JSON that we already have
      console.log(`[QUEUE] Received raw JSON data for "${request.drawingName}":`);
      console.log(responseText);

      // Check if response should be discarded
      if (request.discardResponse) {
        //console.log(`[QUEUE] Discarding response for "${request.drawingName}" - marked for discard due to user activity`);
        // Clear the sent request and continue processing
        //console.log(`[SENTREQUEST] CLEARED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
        this.sentRequest = null;
        setTimeout(() => {
           this.processRequestQueue();
        }, 10);
        return;
      }

     // Don't clear sentRequest here - will be cleared after processing is complete

      let lastRequest = request.requestType;
      /***
      // Prefilter JSON to fix newlines in strings before parsing
      // prehaps add this back later to catch all control chars
      function prefilterJSON(jsonString) {
        let result = '';
        let inString = false;
        let escaping = false;
        
        for (let i = 0; i < jsonString.length; i++) {
          const char = jsonString[i];
          
          if (escaping) {
            result += char;
            escaping = false;
            continue;
          }
          
          if (char === '\\') {
            result += char;
            escaping = true;
            continue;
          }
          
          if (char === '"') {
            inString = !inString;
            result += char;
            continue;
          }
          
          if (inString && char === '\n') {
            result += '\\n';  // Replace literal newline with escaped newline
          } else {
            result += char;
          }
        }
        
        return result;
      }
      
      // Parse the JSON for processing
      const cleanedResponseText = prefilterJSON(responseText);
      const data = JSON.parse(cleanedResponseText);
      console.log('[QUEUE] parsedText ', JSON.stringify(data,null,2));
      **/
      const data = JSON.parse(responseText);
      // Handle different response types for 
      let cmd;
      if (data.cmd) {
        cmd = data.cmd;
        let msgType = cmd[0];
        if ((msgType.startsWith("{,") || msgType.startsWith("{;"))) {
          console.log('[QUEUE] Got a menu response ', JSON.stringify(data,null,2));
          lastRequest = 'mainMenu'  // kluge to handle mainmenu update response to a button press Only from pfodDevice with cmds
        }
      } else {
        console.log('[QUEUE] No cmd field in server response ', JSON.stringify(data));
      }


      if (lastRequest === 'mainMenu') {
        var result = this.processMenuResponse(data, request);
        if (!result) {
          console.error(`[QUEUE] Invalid mainMenu response format. Got: ${cmd}`);
        }

        // Continue processing immediately - no timeout needed
    console.warn(`[QUEUE] after process mainMenu the current queue is:`, JSON.stringify(this.requestQueue, null, 2));
        // Clear sentRequest after mainMenu processing is complete
        console.log(`[QUEUE] COMPLETED: "${request.drawingName}" (${request.requestType}) - clearing sentRequest after mainMenu processing`);
        console.log(`[SENTREQUEST] CLEARED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
        this.sentRequest = null;
        this.processRequestQueue();
        return;
        // else continue to process touch
      }

      // Check if server returned empty cmd response for a drawing request
      if (this.isEmptyCmd(data.cmd) && (lastRequest === 'insertDwg')) {
        console.warn(`[QUEUE] WARNING: Requested drawing "${request.drawingName}" but server returned empty cmd "{}". Drawing not found on server.`);
      }


      // Check if this response should be discarded due to newer drag requests in queue
      if (request.touchZoneInfo && request.touchZoneInfo.filter === TouchZoneFilters.DRAG) {
        const cmd = request.touchZoneInfo.cmd;
        const hasNewerDragRequest = this.requestQueue.some(queuedRequest =>
          queuedRequest.touchZoneInfo &&
          queuedRequest.touchZoneInfo.filter === TouchZoneFilters.DRAG &&
          queuedRequest.touchZoneInfo.cmd === cmd
        );

        if (hasNewerDragRequest) {
          console.log(`[QUEUE] Discarding response for DRAG cmd="${cmd}" - newer request exists in queue`);
          // Remove the processed request from the queue first
//          this.sentRequest = null;
//          this.requestQueue.shift();
          console.warn(`[QUEUE] after newerDragRequest the current queue is:`, JSON.stringify(this.requestQueue, null, 2));

      //    this.processRequestQueue();
          // Continue processing next request
          setTimeout(() => {
            if (this.sentRequest || this.requestQueue.length !== 0) {
              this.processRequestQueue();
            }
          }, 10);
          return;
        } 
      }

      // Handle the response data
      if (this.touchState.isDown) {
        // Mouse is down - queue the response to prevent flashing
        console.log(`[QUEUE] Mouse is down (touchState.isDown=${this.touchState.isDown}) - queuing response for "${request.drawingName}" to prevent flashing`);
        // Remove the processed request from the queue first
//         this.sentRequest = null;
//         this.requestQueue.shift();
         console.warn(`[QUEUE] after isDown sentRequest the current queue is:`, JSON.stringify(this.requestQueue, null, 2));


        // For DRAG responses, keep only the latest one
        if (request.touchZoneInfo && request.touchZoneInfo.filter === TouchZoneFilters.DRAG) {
          const cmd = request.touchZoneInfo.cmd;
          // Remove any existing DRAG response for the same cmd
          this.pendingResponseQueue = this.pendingResponseQueue.filter(pendingResponse =>
            !(pendingResponse.request.touchZoneInfo &&
              pendingResponse.request.touchZoneInfo.filter === TouchZoneFilters.DRAG &&
              pendingResponse.request.touchZoneInfo.cmd === cmd)
          );
          console.log(`[QUEUE] Keeping only latest DRAG response for cmd="${cmd}"`);
        }

        // Add this response to the pending queue
        this.pendingResponseQueue.push({
          request: request,
          data: data
        });
        console.log(`[QUEUE] Added to pending queue. Total pending responses: ${this.pendingResponseQueue.length}`);
      } else {
        // Mouse is up - process immediately
        // No need to restore - we'll do a full merge with the new response data


        console.log(`[QUEUE] Processing data for drawing "${request.drawingName}" (type: ${request.requestType})`);
        // check for {|+ menu return to load/reload dwg
        var result = this.processMenuResponse(data, request);
        if (result) {
          return; // have processed this
        } // else continue
        // Insert name property from request since responses no longer include it
        // For touch requests (touchAction/touchActionInput), don't assign drawing name to update merged data only
        if (request.requestType === 'touch') {
          console.log(`[QUEUE] Touch request - updating merged data only, no individual drawing updates`);
          data.name = null; // No drawing name = update merged data only
        } else {
          data.name = request.drawingName;
        }
//         this.sentRequest = null;
//         this.requestQueue.shift();
         console.warn(`[QUEUE] after mouse up the current queue is:`, JSON.stringify(this.requestQueue, null, 2));


        // All responses are processed through unified shadow system (always active)
        try {
          console.log(`[SHADOW] Processing ${request.requestType} response for "${request.drawingName}"`);

          // Process the response immediately to discover insertDwg items and queue nested requests
          // For touch requests, don't assign drawing name to prevent individual drawing updates
          if (request.requestType === 'touch') {
            data.name = null; // No drawing name = update merged data only
          } else {
            data.name = request.drawingName;
          }
          this.processDrawingData(data, null, request.requestType);

          // Store the processed response
          this.shadowProcessing.responses.set(request.drawingName, { data, request });

          // Check if we need to apply collected responses
          this.checkAndApplyShadowUpdates();

          // Clear the sent request and continue processing
          //console.log(`[QUEUE] COMPLETED: "${request.drawingName}" (${request.requestType}) - clearing sentRequest`);
          //console.log(`[SENTREQUEST] CLEARED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
          this.sentRequest = null;
          //console.log(`[QUEUE] After completion - queue length: ${this.requestQueue.length}, sentRequest: null`);

          // Check shadow processing again now that sentRequest is cleared
          this.checkAndApplyShadowUpdates();

          setTimeout(() => {
             this.processRequestQueue();
          }, 10);
          return;
        } catch (error) {
          console.error(`[SHADOW] Error in shadow processing:`, error);
          alert(`Shadow processing error: ${error.message}`);
          // Clean up shadow processing on error
          this.cleanupShadowProcessing();
          return; // Stop processing on error
        }
      }

      // Legacy queue completion logic removed - now handled by shadow processing atomic updates

    } catch (error) {
      let dwgName = " ";
      if  (request.drawingName !== undefined && request.drawingName !== null) {
        dwgName = request.drawingName;
      }
      console.error(`[QUEUE] Error processing request for "${dwgName}":`, error);

      // Additional diagnostics for debugging
      console.log(`[QUEUE] Debugging state for "${dwgName}":`);
      console.log(`- Main drawing name: ${this.shadowProcessing.shadowDrawingManager.getCurrentDrawingName()}`);
      console.log(`- Drawing in drawings array: ${this.shadowProcessing.shadowDrawingManager.drawings.includes(request.drawingName)}`);
      console.log(`- Drawing in drawingsData: ${this.shadowProcessing.shadowDrawingManager.drawingsData[request.drawingName] ? 'yes' : 'no'}`);
      console.log(`- unindexedItems collection exists: ${this.shadowProcessing.shadowDrawingManager.unindexedItems[request.drawingName] ? 'yes' : 'no'}`);
      console.log(`- indexedItems collection exists: ${this.shadowProcessing.shadowDrawingManager.indexedItems[request.drawingName] ? 'yes' : 'no'}`);
      console.log(`- touchZonesByCmd collection exists: ${this.shadowProcessing.shadowDrawingManager.touchZonesByCmd[request.drawingName] ? 'yes' : 'no'}`);

      // Try to fix any missing collections
      if (!this.shadowProcessing.shadowDrawingManager.unindexedItems[request.drawingName] || !this.shadowProcessing.shadowDrawingManager.indexedItems[request.drawingName]) {
        console.log(`[QUEUE] Attempting to fix missing collections for "${dwgName}"`);
        this.shadowProcessing.shadowDrawingManager.ensureItemCollections(request.drawingName);
      }

      // Increment retry count
      request.retryCount++;

      if (request.retryCount <= this.connectionManager.getMaxRetries()) {
        //console.log(`[QUEUE] Retrying request for "${request.drawingName}" (attempt ${request.retryCount} of ${this.connectionManager.getMaxRetries()})`);
        // Put the request back at the front of the queue for retry
        this.requestQueue.unshift(request);
        //console.log(`[SENTREQUEST] CLEARED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
        this.sentRequest = null;
        setTimeout(() => {
           this.processRequestQueue();
        }, 10);
        return;

      } else {
        console.error(`[QUEUE] Maximum retries (${this.connectionManager.getMaxRetries()}) reached for "${request.drawingName}". Removing from queue.`);

        // Display error message for main drawing or initial connection (null drawing name)
        const currentDrawingName = this.shadowProcessing.shadowDrawingManager.getCurrentDrawingName();
        const isMainOrInitial = (request.drawingName === null || request.drawingName === currentDrawingName);

        if (isMainOrInitial) {
          // Show alert dialog with Close button that reloads page
          console.log(`[ALERT] Triggering No Connection alert for "${request.drawingName}" (main or initial connection)`);
          this.showNoConnectionAlert();
        } else {
          // For inserted drawings, just log the error but continue processing
          console.warn(`[QUEUE] ERROR: Failed to load inserted drawing "${request.drawingName}" after ${this.connectionManager.getMaxRetries()} attempts - continuing without it`);
        }

        // Clear the failed request (it's already been removed from sentRequest)
        console.log(`[SENTREQUEST] CLEARED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
        this.sentRequest = null;
 //       setTimeout(() => {
 //          this.processRequestQueue();
 //       }, 10);

        // For inserted drawings, if we're at the end of the queue, proceed with redraw
        if (this.requestQueue.length === 0 && !this.sentRequest) {
          console.log(`[QUEUE] Queue empty after failed requests. Drawing with available data.`);
            this.setProcessingQueue(false);
          this.redrawCanvas();
          // Resume update scheduling after failed request cleanup
          this.scheduleNextUpdate();

        }
      }
    } finally {
      // If there are more requests in the queue, continue processing
  //    if (this.requestQueue.length > 0 && !this.sentRequest) {
        // Add a small delay between requests
        console.warn(`[QUEUE] Finally post processRequestQueue.`);
        setTimeout(() => {
            if (this.sentRequest || this.requestQueue.length !== 0) {
              this.processRequestQueue();
            }
        }, 10);
  //    }
    }
  }


  // Queue an update for any drawing (main or inserted)
  async queueDrawingUpdate(drawingName) {
    try {
      console.log(`[QUEUE_DWG] Preparing fetch for drawing "${drawingName}" at ${new Date().toISOString()}`);

      const savedVersion = localStorage.getItem(`${drawingName}_version`);
      const savedData = localStorage.getItem(`${drawingName}_data`);
      let cmd;
      // Add version to command only if we have both version and data
      if (savedVersion) { // && savedData) {
        cmd = '{' + savedVersion + ':' + drawingName + '}';
        console.log(`Using saved version: ${savedVersion}`);
      } else {
        console.log('No valid saved version+data pair - requesting fresh data (dwg:start)');
        cmd = '{' + drawingName + '}';
      }

      /**
      // Use /pfodWeb endpoint with cmd parameter in {drawingName} format
      let endpoint = `/pfodWeb?cmd=${encodeURIComponent('{' + drawingName + '}')}`;

      // Add version query parameter if available and valid AND there's corresponding data
      if (savedVersion !== null && savedData) {
        endpoint += `&version=${encodeURIComponent(savedVersion)}`;
        console.log(`[QUEUE_DWG] Using saved version "${savedVersion}" for "${drawingName}"`);
      } else {
        if (savedVersion !== null && !savedData) {
          console.log(`[QUEUE_DWG] Found valid version "${savedVersion}" without data for "${drawingName}" - keeping version but requesting full drawing data`);
          // Don't remove the version - it's valid (including empty string), just request fresh data
        } else {
          console.log(`[QUEUE_DWG] No saved version for "${drawingName}", requesting full drawing data`);
        }
      }
      **/
      // Add to the request queue
      this.addToRequestQueue(drawingName, cmd, null, null, 'refresh');
      console.log(`[QUEUE_DWG] Added "${drawingName}" to request queue`);
    } catch (error) {
      console.error(`[QUEUE_DWG] Failed to queue drawing "${drawingName}":`, error);
    }
  }

  // Process all pending responses that were queued while mouse was down
  processPendingResponses() {
    if (this.pendingResponseQueue.length === 0) {
      console.log(`[QUEUE] No pending responses to process - ensuring refresh timer is restarted`);
      this.scheduleNextUpdate();
      return;
    }

    console.log(`[QUEUE] Processing ${this.pendingResponseQueue.length} pending responses after mouse release`);
    const hadPendingResponses = this.pendingResponseQueue.length > 0;

    // Process responses in order of receipt
    while (this.pendingResponseQueue.length > 0) {
      const pendingResponse = this.pendingResponseQueue.shift();
      const request = pendingResponse.request;
      const data = pendingResponse.data;

      console.log(`[QUEUE] Processing queued response for "${request.drawingName}"`);

      // Check if we have touchAction backup data - if so, we need to restore before processing response
      if (window.pfodWebMouse.touchActionBackups) {
        console.log(`[QUEUE] TouchAction backup exists - processing response against backup data`);
        console.log(`[QUEUE] Response should restore original state before applying new data`);
        console.log(`[QUEUE] Backup indexed items keys: [${Object.keys(window.pfodWebMouse.touchActionBackups.allIndexedItemsByNumber).join(', ')}]`);
        // Log the visible state of items 7, 8, 9 in the backup
        [7, 8, 9].forEach(idx => {
          const backupItem = window.pfodWebMouse.touchActionBackups.allIndexedItemsByNumber[idx];
          console.log(`[QUEUE] Backup item ${idx}: ${backupItem ? `visible=${backupItem.visible}` : 'not found'}`);
        });
      } else {
        console.log(`[QUEUE] No touchAction backup - processing response normally`);
      }

      // Insert name property from request since responses no longer include it
      data.name = request.drawingName;

      // Process the response data using shadow drawing manager to preserve backup state
      this.processDrawingData(data, null, request.requestType);

      // Log the state after processing the response
      if (this.shadowProcessing.shadowDrawingManager) {
        console.log(`[QUEUE] After processing response, shadow manager indexed items: [${Object.keys(this.shadowProcessing.shadowDrawingManager.allIndexedItemsByNumber || {}).join(', ')}]`);
        [7, 8, 9].forEach(idx => {
          const shadowItem = this.shadowProcessing.shadowDrawingManager.allIndexedItemsByNumber[idx];
          console.log(`[QUEUE] After response, shadow item ${idx}: ${shadowItem ? `visible=${shadowItem.visible}` : 'not found'}`);
        });
      }
    }

    console.log(`[QUEUE] Finished processing all pending responses`);
    //this.sentRequest = null;

    // Apply shadow updates to redraw manager and redraw after processing all responses
    if (hadPendingResponses) {
      console.log(`[QUEUE] Finished processing pending responses - checking if shadow updates should be applied`);
      if (!this.touchState.isDown) {
        // Clear sentRequest if still set so queue can continue processing insertDwg requests
        if (this.sentRequest) {
          console.log(`[QUEUE] Clearing sentRequest "${this.sentRequest.drawingName}" to allow queue processing`);
          console.log(`[SENTREQUEST] CLEARED: "${this.sentRequest.drawingName}" (${this.sentRequest.requestType}) - after processing pending responses`);
          this.sentRequest = null;
        }

        // Check if we should apply shadow updates now or wait for more related requests
        console.log(`[QUEUE] Checking for more related requests before applying shadow updates`);
        this.checkAndApplyShadowUpdates();
      }
    }
    setTimeout(() => {
         this.processRequestQueue();
         // Ensure rescheduling after mouse up if queue is empty and no request in flight
         if (this.requestQueue.length === 0 && !this.sentRequest) {
           this.scheduleNextUpdate();
         }
    }, 10);
  }

  // Check if all responses are collected and apply them atomically
  checkAndApplyShadowUpdates() {
    console.log(`[SHADOW] === checkAndApplyShadowUpdates() called ===`);
    console.log(`[SHADOW] Current responses collected: ${this.shadowProcessing.responses.size}`);
    console.log(`[SHADOW] Response drawings: [${Array.from(this.shadowProcessing.responses.keys()).join(', ')}]`);

    // Skip if no active session
    if (!this.shadowProcessing.requestType) {
      console.log(`[SHADOW] No active session - skipping`);
      return;
    }

    // Check abandonment conditions based on request type
    if (this.shouldAbandonShadowProcessing()) {
      console.log(`[SHADOW] Abandoning ${this.shadowProcessing.requestType} processing - ${this.shadowProcessing.responses.size} responses discarded`);
      this.cleanupShadowProcessing();
      return;
    }

    // All responses have already been processed individually as they were received

    // Check if there are more related requests in queue - wait for them
    const hasMoreRelated = this.hasMoreRelatedRequests();
    const hasRelatedInFlight = this.hasRelatedRequestInFlight();

    console.log(`[SHADOW] Check results - hasMoreRelated: ${hasMoreRelated}, hasRelatedInFlight: ${hasRelatedInFlight}`);

    if (hasMoreRelated || hasRelatedInFlight) {
      console.log(`[SHADOW] Waiting for more ${this.shadowProcessing.requestType} responses - queue: ${hasMoreRelated}, in-flight: ${hasRelatedInFlight}`);
      return;
    }

    // All responses collected - apply them atomically
    console.log(`[SHADOW] All responses collected - applying shadow updates atomically`);
    this.applyShadowUpdates();
  }

  // Apply collected shadow updates atomically
  applyShadowUpdates() {
    console.log(`[SHADOW] Applying shadow updates atomically - copying processed data to redraw`);

    try {
      // Copy processed shadow data to isolated redraw drawing manager
      // processDrawingData has already been called and processed data in shadow copy
      if (this.shadowProcessing.shadowDrawingManager) {
        console.log(`[SHADOW] Updating redraw with processed shadow data`);

        // Check if any responses are touch requests - if so, skip merge
        const isTouchRequest = Array.from(this.shadowProcessing.responses.values())
          .some(response => response.request.requestType === 'touch');

        if (isTouchRequest) {
          console.log(`[SHADOW] Touch request detected - skipping merge operation, using shadow data as-is`);
        } else {
          // Create merged collections using DrawingMerger after all individual drawings are processed
          console.log(`[SHADOW] Normal request - performing merge operation`);
          const drawingMerger = new window.DrawingMerger(this.shadowProcessing.shadowDrawingManager);
          drawingMerger.mergeAllDrawings();
        }

        // Atomically update redraw drawing manager with processed shadow copy (triggers redraw)
        this.redraw.updateFromShadow(this.shadowProcessing.shadowDrawingManager);
      }

      // Clean up shadow processing session before resuming updates
      this.cleanupShadowProcessing();

      // Resume update scheduling now that shadow updates are applied
      this.scheduleNextUpdate();

    } catch (error) {
      console.error(`[SHADOW] Error applying shadow updates:`, error);
      alert(`Error applying shadow updates: ${error.message}`);
      // Clean up on error
      this.cleanupShadowProcessing();
    }
  }

  // Initialize shadow processing for a new session
  initializeShadowProcessing(request) {
    // Skip if already processing same request type
    if (this.shadowProcessing.requestType === request.requestType) {
      console.log(`[SHADOW] Shadow processing already active for ${request.requestType}`);
      return;
    }

    // Clean up any previous shadow processing
    if (this.shadowProcessing.requestType) {
      console.log(`[SHADOW] Cleaning up previous ${this.shadowProcessing.requestType} session before starting ${request.requestType}`);
      this.cleanupShadowProcessing();
    }

    // Initialize new shadow processing session
    this.shadowProcessing.requestType = request.requestType;
    this.shadowProcessing.responses.clear();

    // Create shadow copy of current drawing data
    this.createShadowCopy();

    console.log(`[SHADOW] Starting shadow processing session for ${request.requestType}`);
  }

  // Create shadow copy of current drawing data
  createShadowCopy() {
    try {
      // Create new shadow DrawingManager instance
      this.shadowProcessing.shadowDrawingManager = new window.DrawingManager();

      // Copy ALL redraw drawing manager data to shadow for processing
      this.redraw.copyToShadow(this.shadowProcessing.shadowDrawingManager);

    } catch (error) {
      console.error(`[SHADOW] Failed to create shadow copy:`, error);
      // Fall back to empty shadow manager
      this.shadowProcessing.shadowDrawingManager = new window.DrawingManager();
    }
  }

  // Clean up shadow processing session
  cleanupShadowProcessing() {
    // Reset shadow manager to new instance instead of null to avoid null access errors
    this.shadowProcessing.shadowDrawingManager = new window.DrawingManager();
    this.shadowProcessing.responses.clear();
    this.shadowProcessing.requestType = null; // This is the flag for active/inactive
    console.log(`[SHADOW] Shadow processing session cleaned up`);
  }

  // Check if shadow processing should be abandoned based on request type priorities
  shouldAbandonShadowProcessing() {
    const requestType = this.shadowProcessing.requestType;

    // Priority order: mainMenu > main > touch > refresh
    // Higher priority requests abandon lower priority ones

    // Refresh requests (lowest priority) - abandoned by mouse down or any higher priority request
    if (requestType === 'refresh') {
      return this.touchState.isDown || this.requestQueue.some(req => ['mainMenu', 'main', 'touch'].includes(req.requestType));
    }

    // Touch requests - abandoned by main or mainMenu requests
    if (requestType === 'touch') {
      return this.requestQueue.some(req => ['mainMenu', 'main'].includes(req.requestType));
    }

    // Main requests - abandoned only by mainMenu requests
    if (requestType === 'main') {
      return this.requestQueue.some(req => req.requestType === 'mainMenu');
    }

    // MainMenu requests (highest priority) - never abandoned
    if (requestType === 'mainMenu') {
      return false;
    }

    // Default - abandon unknown request types
    console.warn(`[SHADOW] Unknown request type for abandonment check: ${requestType}`);
    return true;
  }

  // Check if there are more requests related to current shadow processing
  hasMoreRelatedRequests() {
    const requestType = this.shadowProcessing.requestType;
    const relatedRequests = this.requestQueue.filter(req =>
      req.requestType === requestType ||
      req.requestType === 'insertDwg' ||
      (requestType === 'refresh' && req.requestType === 'refresh-insertDwg'));

    console.log(`[SHADOW_CHECK] hasMoreRelatedRequests() - shadow type: ${requestType}`);
    console.log(`[SHADOW_CHECK] Queue length: ${this.requestQueue.length}, related requests: ${relatedRequests.length}`);
    console.log(`[SHADOW_CHECK] All queue request types: [${this.requestQueue.map(req => req.drawingName + '(' + req.requestType + ')').join(', ')}]`);
    console.log(`[SHADOW_CHECK] Related request types: [${relatedRequests.map(req => req.drawingName + '(' + req.requestType + ')').join(', ')}]`);

    return relatedRequests.length > 0;
  }

  // Check if there's a related request in flight
  hasRelatedRequestInFlight() {
    const requestType = this.shadowProcessing.requestType;
    const hasRelated = this.sentRequest && (
      this.sentRequest.requestType === requestType ||
      this.sentRequest.requestType === 'insertDwg' ||
      (requestType === 'refresh' && this.sentRequest.requestType === 'refresh-insertDwg'));

    console.log(`[SHADOW_CHECK] hasRelatedRequestInFlight() - shadow type: ${requestType}`);
    console.log(`[SHADOW_CHECK] sentRequest: ${this.sentRequest ? this.sentRequest.drawingName + '(' + this.sentRequest.requestType + ')' : 'null'}`);
    console.log(`[SHADOW_CHECK] hasRelated: ${hasRelated}`);

    return hasRelated;
  }

  // Update collection shadow processors removed - using unified shadow processing system

  // Process drawing data (converted from global function)
  // touchZones are processed by adding current transform and then storing in touchZonesByCmd[dwgName]
  // in merge all touchZones are merged together into allTouchZonesByCmd
  // in redraw all the touchZones are drawn after unindexed and indexed items, if in debug mode
  processDrawingData(data, savedData, requestType = 'unknown') {
    // DrawingDataProcessor ALWAYS works on shadowDrawingManager only
    // Pass shadow drawing manager locally to avoid changing global references
    return this.drawingDataProcessor.processDrawingData(data, this.shadowProcessing.shadowDrawingManager, savedData, requestType);
  }


  // Handle insertDwg items by adding them to the request queue
  handleInsertDwg(item) {
    const drawingName = item.drawingName;
    const xOffset = parseFloat(item.xOffset || 0);
    const yOffset = parseFloat(item.yOffset || 0);

    console.log(`[INSERT_DWG] Handling insertDwg for drawing "${drawingName}" with offset (${xOffset}, ${yOffset})`);

    // Verify this is a valid insertDwg item
    if (!item.type || (item.type !== 'insertDwg' && item.type.toLowerCase() !== 'insertdwg')) {
      console.error(`[INSERT_DWG] Invalid item type: ${item.type}. Expected 'insertDwg'`);
      console.log(`[INSERT_DWG] Full item:`, JSON.stringify(item));
    }

    // Ensure the target drawing has its item collections properly initialized
    this.shadowProcessing.shadowDrawingManager.ensureItemCollections(drawingName);

    if (!drawingName) {
      console.error('[INSERT_DWG] InsertDwg item missing drawingName:', item);
      return {
        error: 'Missing drawing name',
        item: item
      };
    }

    // Check if we're trying to insert the current drawing (prevent infinite recursion)
    const mainDrawingName = this.shadowProcessing.shadowDrawingManager.drawings.length > 0 ? this.shadowProcessing.shadowDrawingManager.drawings[0] : '';
    if (drawingName === mainDrawingName) {
      console.warn(`[INSERT_DWG] Error: Cannot insert drawing "${drawingName}" into itself`);
      return {
        error: 'Self-insertion not allowed',
        drawingName: mainDrawingName
      };
    }

    // Check if this drawing is already in the drawings array
    if (this.shadowProcessing.shadowDrawingManager.drawings.includes(drawingName)) {
      console.log(`[INSERT_DWG] Drawing "${drawingName}" is already in drawings list.`);

      // Even if drawing is already in the drawings list, explicitly check if we need to request it
      if (!this.shadowProcessing.shadowDrawingManager.drawingsData[drawingName] || !this.shadowProcessing.shadowDrawingManager.drawingsData[drawingName].data) {
        console.log(`[INSERT_DWG] Drawing "${drawingName}" in list but data missing - will request it`);
        // Add to the request queue if not already in queue
        if (!this.requestQueue.some(req => req.drawingName === drawingName)) {
          const cmd = '{' + drawingName + '}';

          console.warn(`[INSERT_DWG] Adding "${drawingName}" to request queue (already in drawings)`);
          this.addToRequestQueue(drawingName, cmd, null, null, 'insertDwg');
        } else {
          console.log(`[INSERT_DWG] "${drawingName}" already in request queue`);
        }
      }

      return {
        drawingName: drawingName,
        dataAvailable: this.shadowProcessing.shadowDrawingManager.drawingsData[drawingName] && this.shadowProcessing.shadowDrawingManager.drawingsData[drawingName].data ? true : false,
        alreadyInList: true
      };
    }

    // Ensure collections exist for this drawing
    this.shadowProcessing.shadowDrawingManager.ensureItemCollections(drawingName);

    // Add this drawing to the DrawingManager
    this.shadowProcessing.shadowDrawingManager.addInsertedDrawing(
      drawingName,
      xOffset,
      yOffset,
      item.transform || {
        x: 0,
        y: 0,
        scale: 1.0
      },
      mainDrawingName // Parent drawing name
    );

    console.log(`[INSERT_DWG] Created entry for drawing "${drawingName}" in drawingsData`);
    console.log(`[INSERT_DWG] Request timestamp: ${new Date().toISOString()}`);

    // Add to the request queue
    if (!this.requestQueue.some(req => req.drawingName === drawingName)) {
      const cmd = '{' + drawingName + '}';

      // Determine the appropriate request type based on current shadow processing context
      let requestType = 'insertDwg';
      if (this.shadowProcessing.requestType === 'refresh') {
        requestType = 'refresh-insertDwg';
        console.warn(`[INSERT_DWG] Adding "${drawingName}" to request queue (refresh-triggered insert)`);
      } else {
        console.warn(`[INSERT_DWG] Adding "${drawingName}" to request queue (new insert)`);
      }

      this.addToRequestQueue(drawingName, cmd, null, null, requestType);
    } else {
      console.log(`[INSERT_DWG] "${drawingName}" already in request queue`);
    }

    // Return immediately so that the placeholder can be drawn
    return {
      drawingName: drawingName,
      dataAvailable: false,
      newlyAdded: true
    };
  }



  // Remove an inserted drawing and its touchZones, plus any child drawings
  removeInsertedDrawing(drawingName) {
    if (!drawingName) {
      console.error('No drawing name provided to removeInsertedDrawing');
      return;
    }

    console.log(`[REMOVE_DWG] Removing inserted drawing: ${drawingName}`);

    // Remove any pending requests for this drawing from the queue
    const initialQueueLength = this.requestQueue.length;
    this.requestQueue = this.requestQueue.filter(request => request.drawingName !== drawingName);
    let removedCount = initialQueueLength - this.requestQueue.length;

    // Also check and clear if the currently sent request is for this drawing
    if (this.sentRequest && this.sentRequest.drawingName === drawingName) {
      console.log(`[REMOVE_DWG] Clearing in-flight request for ${drawingName}`);
      console.log(`[SENTREQUEST] CLEARED: "${request.drawingName}" (${request.requestType}) at ${new Date().toISOString()}`);
      this.sentRequest = null;
      removedCount++;
    }

    if (removedCount > 0) {
      console.log(`[REMOVE_DWG] Removed ${removedCount} request(s) for ${drawingName} (${initialQueueLength - this.requestQueue.length} from queue, ${this.sentRequest ? 0 : (removedCount - (initialQueueLength - this.requestQueue.length))} in-flight)`);
    }

    // First identify any child drawings that have this drawing as their parent
    const childDrawings = this.shadowProcessing.shadowDrawingManager.getChildDrawings(drawingName);

    // Recursively remove all child drawings first
    childDrawings.forEach(childName => {
      console.log(`[REMOVE_DWG] Removing child drawing ${childName} of ${drawingName}`);
      this.removeInsertedDrawing(childName);
    });

    // Remove associated touchZones (if touchZonesByCmd is available)
    if (typeof this.touchZonesByCmd !== 'undefined') {
      this.removeTouchZonesByDrawing(drawingName);
    }

    // Remove the drawing using the manager
    this.shadowProcessing.shadowDrawingManager.removeInsertedDrawing(drawingName);

    console.log(`[REMOVE_DWG] Completed removal of inserted drawing: ${drawingName}`);
  }

  // Remove touchZones associated with a specific drawing
  removeTouchZonesByDrawing(drawingName) {
    if (!drawingName) {
      console.error('No drawing name provided to removeTouchZonesByDrawing');
      return;
    }

    console.log(`Removing touchZones for drawing: ${drawingName}`);

    // Create a new array of keys to remove
    const keysToRemove = [];

    // Find all touchZones belonging to this drawing
    for (const cmd in this.touchZonesByCmd) {
      const touchZone = this.touchZonesByCmd[cmd];
      if (touchZone.parentDrawingName === drawingName) {
        keysToRemove.push(cmd);
        console.log(`Marked touchZone for removal: cmd=${cmd}, drawing=${drawingName}`);
      }
    }

    // Remove identified touchZones
    keysToRemove.forEach(cmd => {
      delete this.touchZonesByCmd[cmd];
      console.log(`Removed touchZone: cmd=${cmd}`);
    });

    console.log(`Removed ${keysToRemove.length} touchZones for drawing: ${drawingName}`);
  }

  // Build connection info message
  getConnectionInfoMessage() {
    let connectionInfo = '';

    console.log('[CONNECTION_INFO] Protocol:', this.protocol);
    console.log('[CONNECTION_INFO] Adapter:', this.connectionManager?.adapter);

    if (this.protocol === 'http' && this.targetIP) {
      connectionInfo = `HTTP to ${this.targetIP}`;
    } else if (this.protocol === 'serial') {
      const portName = this.connectionManager?.adapter?.portName || 'COM?';
      connectionInfo = `Serial: ${portName} @ ${this.baudRate} baud`;
    } else if (this.protocol === 'ble') {
      // Try multiple ways to get device name
      let deviceName = this.connectionManager?.adapter?.device?.name;
      if (!deviceName) {
        deviceName = this.connectionManager?.adapter?.deviceName;
      }
      if (!deviceName) {
        deviceName = 'Unknown Device';
      }
      connectionInfo = `BLE: ${deviceName}`;
    } else {
      connectionInfo = 'Unknown Connection';
    }

    console.log('[CONNECTION_INFO] Final message:', connectionInfo);
    return connectionInfo;
  }

  // Show "No Connection" alert dialog after max retries
  showNoConnectionAlert() {
    console.log('[ALERT] Showing No Connection alert after max retry attempts');

    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'no-connection-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 999998;
      display: flex;
      justify-content: center;
      align-items: center;
    `;

    // Create alert dialog
    const alertBox = document.createElement('div');
    alertBox.style.cssText = `
      background-color: white;
      padding: 30px 40px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      text-align: center;
      max-width: 500px;
      font-family: Arial, sans-serif;
    `;

    // Create message
    const message = document.createElement('p');
    message.textContent = 'No Connection';
    message.style.cssText = `
      font-size: 24px;
      font-weight: bold;
      margin: 0 0 15px 0;
      color: #d32f2f;
    `;

    // Create connection details
    const details = document.createElement('p');
    const connectionInfo = this.getConnectionInfoMessage();
    details.textContent = `Failed to connect to: ${connectionInfo}`;
    details.style.cssText = `
      font-size: 14px;
      margin: 0 0 20px 0;
      color: #666;
      font-family: monospace;
    `;

    // Create Close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.style.cssText = `
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 10px 30px;
      font-size: 16px;
      border-radius: 5px;
      cursor: pointer;
      outline: none;
    `;

    // Make button respond to hover
    closeButton.onmouseover = () => {
      closeButton.style.backgroundColor = '#1976D2';
    };
    closeButton.onmouseout = () => {
      closeButton.style.backgroundColor = '#2196F3';
    };

    // Close button handler - reload page
    const reloadPage = () => {
      console.log('[ALERT] Close button clicked - reloading page');
      window.location.reload();
    };

    closeButton.onclick = reloadPage;

    // Handle Enter key
    const handleKeyPress = (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        reloadPage();
      }
    };
    document.addEventListener('keydown', handleKeyPress);

    // Focus the button so Enter works immediately
    setTimeout(() => {
      closeButton.focus();
    }, 100);

    // Assemble dialog
    alertBox.appendChild(message);
    alertBox.appendChild(details);
    alertBox.appendChild(closeButton);
    overlay.appendChild(alertBox);
    document.body.appendChild(overlay);
  }

  // Handle drawing error (not found, etc) - instance method for multi-viewer support
  handleDrawingError(errorData) {
    console.error(`Drawing error: ${errorData.error} - ${errorData.message}`);

    // Completely remove any canvas container that might interfere
    if (this.canvasContainer) {
      this.canvasContainer.style.display = 'none';
    }

    // Create a brand new error message div directly in the body
    // First, remove any existing error message
    const existingError = document.getElementById('error-message');
    if (existingError) {
      document.body.removeChild(existingError);
    }

    // Create the new error element
    const errorMessageElement = document.createElement('div');
    errorMessageElement.id = 'error-message';

    // Apply inline styles directly
    errorMessageElement.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 999999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
            color: #333;
            text-align: center;
        `;

    // Set the HTML content
    errorMessageElement.innerHTML = `
            <div style="
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                max-width: 80%;
                margin: 0 auto;
                text-align: center;
            ">
                <h2 style="
                    color: #d32f2f;
                    margin-bottom: 20px;
                    font-size: 28px;
                    font-weight: bold;
                ">Drawing Error</h2>
                <p style="
                    font-size: 20px;
                    margin-bottom: 20px;
                    color: #333;
                ">${errorData.message}</p>
                <p style="
                    font-size: 18px;
                    margin-bottom: 30px;
                    color: #666;
                ">Please check the drawing name and try again.</p>
            </div>
        `;

    // Add to the document body
    document.body.appendChild(errorMessageElement);

    // For debugging
    console.log('Error message created and added to body');

    // Remove any canvas, just to be sure
    if (this.canvas) {
      this.canvas.style.display = 'none';
    }

    // Disable updates
    this.isUpdating = false;
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }

    // Log to console
    console.warn("ERROR DISPLAYED TO USER:", errorData.message);

    // Try to adjust the page title to indicate the error
    document.title = "Error: Drawing Not Found";
  }


}


// TouchZone special values - these remain global as they're constants
const TouchZoneSpecialValues = {
  TOUCHED_COL: 65534, // Only used in touchZone actions to specify touched col value
  TOUCHED_ROW: 65532, // Only used in touchZone actions to specify touched row value
};

// Dynamic script loader
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

// Load all dependencies in order
async function loadDependencies() {
  const dependencies = [
    './version.js',
    './connectionManager.js',
    './DrawingManager.js',
    './displayTextUtils.js',
    './redraw.js',
    './drawingMerger.js',
    './webTranslator.js',
    './drawingDataProcessor.js',
    './pfodWebMouse.js'
  ];

  for (const dep of dependencies) {
    await loadScript(dep);
  }

  // Make JS_VERSION available globally after dependencies are loaded
  if (typeof JS_VERSION !== 'undefined') {
    window.JS_VERSION = JS_VERSION;
    console.log('[PFODWEB_DEBUG] JS_VERSION loaded and made globally available:', JS_VERSION);
  } else {
    console.warn('[PFODWEB_DEBUG] Warning: JS_VERSION not defined after loading dependencies');
  }
}

// Global viewer instance
let drawingViewer = null;

// Event Listeners
window.addEventListener('DOMContentLoaded', async () => {
  console.log('[PFODWEB_DEBUG] DOMContentLoaded event fired');

  console.log('[PFODWEB_DEBUG] URL when DOMContentLoaded:', window.location.href);
  console.log('[PFODWEB_DEBUG] Referrer when DOMContentLoaded:', document.referrer);
  // await loadDependencies(); // Commented out in bundled version - all scripts already inlined
  await initializeApp();
});
window.addEventListener('resize', () => {
  if (drawingViewer) {
    drawingViewer.handleResize();
  }
});


// Touch and mouse event handlers - now handled in DrawingViewer.setupEventListeners()

// Touch state is now handled as instance properties in DrawingViewer class
// See this.touchState in DrawingViewer constructor

// Handle browser refresh button and navigation away
window.addEventListener('beforeunload', async function(event) {
  // Store the current URL pattern
  localStorage.setItem('lastUrlPattern', window.location.pathname);

  // Clean up connection if it exists
  if (drawingViewer && drawingViewer.connectionManager) {
    console.log('[CLEANUP] Disconnecting before page unload...');
    try {
      await drawingViewer.connectionManager.disconnect();
    } catch (error) {
      console.error('[CLEANUP] Error during disconnect:', error);
    }
  }
});

// Handle returning from browser refresh
window.addEventListener('DOMContentLoaded', function() {
  const lastUrlPattern = localStorage.getItem('lastUrlPattern');
  if (lastUrlPattern && lastUrlPattern.includes('/update')) {
    // If we were on an update URL, make sure we load the drawing correctly
    const pathSegments = lastUrlPattern.split('/').filter(segment => segment.length > 0);
    if (pathSegments.length > 0) {
      const currentDrawingName = pathSegments[0];
      // Make sure the drawing is the first in the array
      if (!this.shadowProcessing.shadowDrawingManager.drawings.includes(currentDrawingName)) {
        this.shadowProcessing.shadowDrawingManager.drawings.unshift(currentDrawingName);
      }
    }
  }
});

// Continue initialization after connection prompt
function continueInitialization() {
  console.log('[PFODWEB_DEBUG] continueInitialization() called after connection prompt');

  // Always clean up any existing drawingViewer when navigating to this page
  // This handles the case where user goes back from this page and then navigates here again
  if (drawingViewer) {
    console.log('[PFODWEB_DEBUG] Cleaning up existing DrawingViewer from previous session');
    if (drawingViewer.connectionManager) {
      drawingViewer.connectionManager.disconnect().catch(err => {
        console.error('[PFODWEB_DEBUG] Error disconnecting previous connection:', err);
      });
    }
    drawingViewer = null;
  }

  // Create the DrawingViewer instance
  drawingViewer = new DrawingViewer();

  // Make drawingViewer globally accessible for pfodWebMouse
  window.drawingViewer = drawingViewer;

  try {
    // Initialize the viewer - queue initial request to get drawing name from server
    drawingViewer.queueInitialRequest();

    // Redraw instance already created with canvas and context - no init needed
    // Data is managed locally in redraw

    // The drawing name will be extracted and drawing loaded via the request queue
  } catch (error) {
    console.error('Failed to initialize application:', error);
    // Show error to user
    document.body.innerHTML = `<div style="padding: 20px; text-align: center; font-family: Arial;">
            <h2>Error Loading Drawing</h2>
            <p>Failed to get drawing name from server: ${error.message}</p>
        </div>`;
  }
}

// Helper function to validate IP address
function isValidIPAddress(ip) {
  if (!ip || typeof ip !== 'string') return false;
  const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipRegex.test(ip)) return false;
  const parts = ip.split('.');
  return parts.every(part => {
    const num = parseInt(part, 10);
    return num >= 0 && num <= 255;
  });
}

// Initialize the application
async function initializeApp() {
  console.log('[PFODWEB_DEBUG] initializeApp() called');
  console.log('[PFODWEB_DEBUG] Current URL:', window.location.href);
  console.log('[PFODWEB_DEBUG] Referrer:', document.referrer);
  console.log('[PFODWEB_DEBUG] Document ready state:', document.readyState);
  console.log('Initializing canvas drawing viewer');

  // Check if connection parameters are provided
  const urlParams = new URLSearchParams(window.location.search);

  // Check for protocol-specific parameters
  const hasTargetIP = urlParams.has('targetIP');
  const hasSerial = urlParams.has('serial');
  const hasBLE = urlParams.has('ble');

  // If targetIP is provided, validate it
  if (hasTargetIP) {
    const targetIP = urlParams.get('targetIP');

    // Check if targetIP is empty or invalid
    if (!targetIP || targetIP.trim() === '' || !isValidIPAddress(targetIP)) {
      console.log('[PFODWEB_DEBUG] targetIP parameter provided but empty or invalid:', targetIP);
      console.log('[PFODWEB_DEBUG] Showing HTTP connection prompt for user to enter valid IP');

      // Pre-select HTTP radio button
      document.getElementById('prompt-protocol-http').checked = true;
      // Update UI to show HTTP settings
      if (typeof updatePromptUI === 'function') {
        updatePromptUI();
      }
      // Clear any existing IP value and focus on the input field
      const ipInput = document.getElementById('prompt-ip');
      if (ipInput) {
        ipInput.value = '';
        ipInput.focus();
      }
      // Validate the connect button state
      if (typeof validateConnectButton === 'function') {
        validateConnectButton();
      }
      document.getElementById('connection-prompt').style.display = 'flex';
      return;
    }

    // Valid targetIP provided, use it directly and continue
    console.log('[PFODWEB_DEBUG] Valid HTTP connection with targetIP=' + targetIP + ' - proceeding directly');
    continueInitialization();
    return;
  }

  // If serial parameter is in URL, show connection prompt with Serial section pre-selected
  if (hasSerial) {
    console.log('[PFODWEB_DEBUG] Serial parameter found - showing Serial connection prompt');
    // Pre-select Serial radio button
    document.getElementById('prompt-protocol-serial').checked = true;
    // Update UI to show Serial settings
    if (typeof updatePromptUI === 'function') {
      updatePromptUI();
    }
    // If serial has a value, try to pre-fill the baud rate
    const baudRate = urlParams.get('serial');
    if (baudRate && baudRate !== '') {
      const baudSelect = document.getElementById('prompt-baud');
      // Try to set the value - if invalid, it won't match any option
      baudSelect.value = baudRate;
      // If the value didn't match any option, the select will have an empty value
      console.log('[PFODWEB_DEBUG] Set baud rate to:', baudRate, 'Actual value:', baudSelect.value);
    }
    // Validate the connect button state after pre-filling
    if (typeof validateConnectButton === 'function') {
      validateConnectButton();
    }
    document.getElementById('connection-prompt').style.display = 'flex';
    return;
  }

  // If ble parameter is in URL, show connection prompt with BLE section pre-selected
  if (hasBLE) {
    console.log('[PFODWEB_DEBUG] BLE parameter found - showing BLE connection prompt');
    // Pre-select BLE radio button
    document.getElementById('prompt-protocol-ble').checked = true;
    // Update UI to show BLE settings
    if (typeof updatePromptUI === 'function') {
      updatePromptUI();
    }
    document.getElementById('connection-prompt').style.display = 'flex';
    return;
  }

  // No parameters - check if designer mode
  const hasDesigner = urlParams.has('designer');

  if (hasDesigner) {
    // Designer mode - use default server connection without prompt
    console.log('[PFODWEB_DEBUG] Designer mode - using default server connection');
    continueInitialization();
  } else {
    // Show connection prompt with HTTP pre-selected (default)
    console.log('[PFODWEB_DEBUG] No connection parameters - showing connection prompt');
    // Validate the connect button state (HTTP is selected by default, so button should be enabled)
    if (typeof validateConnectButton === 'function') {
      validateConnectButton();
    }
    document.getElementById('connection-prompt').style.display = 'flex';
  }
}

// Make continueInitialization available globally so connection prompt can call it
window.continueInitialization = continueInitialization;


// Global touch event handling functions moved to pfodWebMouse.js

// Make DrawingViewer available globally for browser use
window.DrawingViewer = DrawingViewer;


/* ========================================
 * Inlined from: DrawingManager.js
 * ======================================== */
/*   
   DrawingManager.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// DrawingManager.js - Centralized manager for all drawing data
// Replaces the global drawingData variable with a class that manages data for each drawing



class DrawingManager {
    constructor() {
        // Flag to track if this DrawingManager instance is actively in use
        this.inUse = false;

        // Store for drawing items
        this.touchZonesByCmd = {}; // Format: {drawingName: {cmd: item}}
        this.touchActionsByCmd = {}; // Format: {drawingName: {cmd: actionArray}}
        this.touchActionInputsByCmd = {}; // Format: {drawingName: {cmd: {prompt, textIdx}}}
        this.allTouchZonesByCmd = {}; // // Format: {cmd: item}
        this.allTouchActionsByCmd = {};
        this.allTouchActionInputsByCmd = {};
        this.unindexedItems = {}; // Format: {drawingName: [items]}
        this.indexedItems = {}; // Format: {drawingName: {idx: item}}
        this.allUnindexedItems = [];
        this.allIndexedItemsByNumber = {};
        
        // Track all drawings including main and inserted ones
        this.drawings = []; // Array of drawing names in order, with main drawing first
        this.drawingsData = {}; // Format: {drawingName: {xOffset, yOffset, transform, data, parentDrawing}}
        
        // Flag to track if all drawings have been received
        this.allDrawingsReceived = false; // this is not actually used!!
        
        // Only store the last transform for drawing updates
        this.savedTransforms = {}; // Format: {drawingName: {x, y, scale}}
        
        // Track response status for each drawing
        this.drawingResponseStatus = {}; // Format: {drawingName: boolean} - true if response received, false if pending
        
        // Try to restore merged data from localStorage on construction
        this.loadMergedDataFromStorage();
    }
    
    // Initialize the manager with a drawing name
    initialize(drawingName) {
        // Add the main drawing as the first entry in the drawings array
        if (!this.drawings.includes(drawingName)) {
            this.drawings.unshift(drawingName);
        }
        
        if (!this.touchZonesByCmd[drawingName]) {
            this.touchZonesByCmd[drawingName] = {};
        }
        if (!this.touchActionsByCmd[drawingName]) {
            this.touchActionsByCmd[drawingName] = {};
        }
        if (!this.touchActionInputsByCmd[drawingName]) {
            this.touchActionInputsByCmd[drawingName] = {};
        }    
        if (!this.allTouchZonesByCmd) {
            this.allTouchZonesByCmd = {};
        }    
        // Initialize collections for the drawing if they don't exist
        if (!this.unindexedItems[drawingName]) {
            this.unindexedItems[drawingName] = [];
        }
        if (!this.indexedItems[drawingName]) {
            this.indexedItems[drawingName] = {};
        }
        
        console.log(`DrawingManager initialized with drawing: ${drawingName}`);
        return this;
    }
    
    // Get the saved transform for a drawing
    // This is only used for restoring the last saved transform for updates
    getSavedTransform(drawingName = null) {
        const name = drawingName || (this.getMainDrawingName());
        // Return default transform if not found
        return this.savedTransforms[name] || { x: 0, y: 0, scale: 1.0 };
    }
    
    // Save the current transform for a drawing
    // This is used only to store the final transform for the next update
    saveTransform(drawingName, transform) {
        this.savedTransforms[drawingName] = { ...transform };
        return this;
    }
    
    // Get the drawing data for a specific drawing or the current one
    getDrawingData(drawingName = null) {
        const name = drawingName || (this.getMainDrawingName());
        return this.drawingsData[name]?.data;
    }
    
    // Get the current main drawing data
    getCurrentDrawingData() {
        // Main drawing is always the first in the drawings array
        const mainDrawing = this.getMainDrawingName();
        return this.drawingsData[mainDrawing]?.data;
    }
    
    // Set drawing data for a drawing
    setDrawingData(drawingName, data) {
        // Ensure drawingsData entry exists
        if (!this.drawingsData[drawingName]) {
            this.drawingsData[drawingName] = {
                xOffset: 0,
                yOffset: 0,
                transform: { x: 0, y: 0, scale: 1.0 },
                data: null,
                parentDrawing: null
            };
            
            // If this is a new drawing, add it to the drawings array
            if (!this.drawings.includes(drawingName)) {
                this.drawings.push(drawingName);
            }
        }
        
        // Update the data
        this.drawingsData[drawingName].data = data;
        this.drawingsData[drawingName].name = drawingName;
        this.drawingResponseStatus[drawingName] = true;
        
        // Ensure there are item collections for this drawing
        this.ensureItemCollections(drawingName);
        
        console.log(`DrawingManager: Set data for drawing ${drawingName}`);
        return this;
    }
    
    // Update drawing data (partial update)
    updateDrawingData(drawingName, updates) {
        if (!this.drawingsData[drawingName]) {
            this.drawingsData[drawingName] = {
                xOffset: 0,
                yOffset: 0,
                transform: { x: 0, y: 0, scale: 1.0 },
                data: {},
                parentDrawing: null
            };
            
            // If this is a new drawing, add it to the drawings array
            if (!this.drawings.includes(drawingName)) {
                this.drawings.push(drawingName);
            }
        }
        
        const currentData = this.drawingsData[drawingName].data || {};
        this.drawingsData[drawingName].data = { ...currentData, ...updates };
        this.drawingResponseStatus[drawingName] = true;
        
        console.log(`DrawingManager: Updated data for drawing ${drawingName}`);
        return this;
    }
    
    // Add an item to a drawing
    addItem(drawingName, item) {
        // Ensure the item collections exist
        this.ensureItemCollections(drawingName);
        
        // Apply current transform to the item
        if (!item.transform) {
            item.transform = {...this.getTransform(drawingName)};
        }
        
        // Handle indexed vs. unindexed items
        if (item.idx && item.idx !== 'null') {
            const idx = item.idx;
            this.indexedItems[drawingName][idx] = item;
            return this;
        }
        
        // For non-indexed items
        this.unindexedItems[drawingName].push(item);
        return this;
    }
    
    // Process a touchZone item
    addTouchZone(drawingName, touchZone) {
        // Ensure the item has a drawing name
        touchZone.drawingName = drawingName;
        const cmd = touchZone.cmd || '';
        if (cmd.trim().length == 0) {
            console.warn(`Error empty touchzone cmd in drawing "${drawingName}" ${JSON.stringify(touchZone)}`);
            return this;
        }
 
        // Check if there's already an existing item (could be index item) with this cmd
        const existingItem = this.touchZonesByCmd[drawingName] && this.touchZonesByCmd[drawingName][cmd];
        
        if (existingItem) {
            // Preserve transform and visibility state from existing item (likely an index item)
            touchZone.transform = existingItem.transform;
            touchZone.visible = existingItem.visible !== undefined ? existingItem.visible : touchZone.visible;
            console.log(`[DRAWING_MANAGER] Preserving state from existing item for cmd="${cmd}": visible=${touchZone.visible}, transform=(${touchZone.transform.x},${touchZone.transform.y},${touchZone.transform.scale})`);
        } else {
            // Apply current transform if not already set
            if (!touchZone.transform) {
                touchZone.transform = {...this.getTransform(drawingName)};
            }
        }
        
        // Add to the touchZones map - cmd is unique reference
        this.touchZonesByCmd[drawingName][touchZone.cmd] = touchZone;
        
        return this;
    }

    // Process a touchAction item
    addTouchAction(drawingName, touchAction) {
        console.log(`[DRAWING_MANAGER] Adding touchAction: cmd=${touchAction.cmd || ''}, drawingName=${drawingName}`);
        const cmd = touchAction.cmd || '';
        
        if (cmd.trim().length === 0) {
            console.warn(`[DRAWING_MANAGER] TouchAction has empty cmd, ignoring:`, JSON.stringify(touchAction));
            return false;
        }
        
        // Check if there's a touchZone with the same cmd in this drawing
        if (!this.touchZonesByCmd[drawingName] || !this.touchZonesByCmd[drawingName][cmd]) {
            console.warn(`[DRAWING_MANAGER] TouchAction cmd=${cmd} has no corresponding touchZone. TouchActions must be positioned AFTER their corresponding touchZone in the items list. Please move this touchAction to come after the touchZone with cmd="${cmd}".`);
            return false;
        }
        
        // Ensure the collections exist
        this.ensureItemCollections(drawingName);
        
        // Initialize actions array if it doesn't exist for this cmd
        if (!this.touchActionsByCmd[drawingName][cmd]) {
            this.touchActionsByCmd[drawingName][cmd] = [];
        }
        
        // Append the action items to existing actions array instead of replacing
        if (touchAction.action && Array.isArray(touchAction.action)) {
            this.touchActionsByCmd[drawingName][cmd].push(...touchAction.action);
        }
        
        console.log(`[DRAWING_MANAGER] TouchAction added successfully: cmd=${cmd}, actions=${(touchAction.action || []).length}, drawingName=${drawingName}`);
        return true;
    }

    // Get touchActions for a specific cmd
    getTouchAction(drawingName, cmd) {
        if (!this.touchActionsByCmd[drawingName]) return [];
        return this.touchActionsByCmd[drawingName][cmd] || [];
    }

    // Add touchActionInput for a specific cmd
    addTouchActionInput(drawingName, touchActionInput) {
        console.log(`[DRAWING_MANAGER] Adding touchActionInput: cmd=${touchActionInput.cmd || ''}, drawingName=${drawingName}`);
        const cmd = touchActionInput.cmd || '';
        
        if (cmd.trim().length === 0) {
            console.warn(`[DRAWING_MANAGER] TouchActionInput has empty cmd, ignoring:`, JSON.stringify(touchActionInput));
            return false;
        }
        
        // Check if there's a touchZone with the same cmd in this drawing
        if (!this.touchZonesByCmd[drawingName] || !this.touchZonesByCmd[drawingName][cmd]) {
            console.warn(`[DRAWING_MANAGER] TouchActionInput cmd=${cmd} has no corresponding touchZone, ignoring:`, JSON.stringify(touchActionInput));
            return false;
        }
        
        // Ensure the collections exist
        this.ensureItemCollections(drawingName);
        
        // Store the touchActionInput - overwrites any existing touchActionInput with same cmd
        this.touchActionInputsByCmd[drawingName][cmd] = {
            prompt: touchActionInput.prompt || '',
            textIdx: touchActionInput.textIdx,
            fontSize: touchActionInput.fontSize !== undefined ? touchActionInput.fontSize : 0,
            color: touchActionInput.color !== undefined ? touchActionInput.color : 0,
            backgroundColor: touchActionInput.backgroundColor !== undefined ? touchActionInput.backgroundColor : 0
        };
        
        // Force touchZone filter to TOUCH when touchActionInput is present, but only if not TOUCH_DISABLED
        const touchZone = this.touchZonesByCmd[drawingName][cmd];
        if (touchZone && touchZone.filter !== TouchZoneFilters.TOUCH && touchZone.filter !== TouchZoneFilters.TOUCH_DISABLED) {
            console.log(`[DRAWING_MANAGER] Forcing touchZone filter from ${touchZone.filter} to TOUCH for cmd=${cmd} due to touchActionInput`);
            touchZone.filter = TouchZoneFilters.TOUCH;
        }
        
        console.log(`[DRAWING_MANAGER] TouchActionInput added successfully: cmd=${cmd}, prompt="${touchActionInput.prompt}", textIdx=${touchActionInput.textIdx}, drawingName=${drawingName}`);
        return true;
    }

    // Get touchActionInput for a specific cmd
    getTouchActionInput(drawingName, cmd) {
        if (!this.touchActionInputsByCmd[drawingName]) return null;
        return this.touchActionInputsByCmd[drawingName][cmd] || null;
    }
    
    // Get all unindexed items for a drawing
    getTouchZonesByCmd(drawingName = null) {
        const name = drawingName || (this.getMainDrawingName());
        return this.touchZonesByCmd[name] || [];
    }
    
    // Clear items for a drawing
    clearItems(drawingName) {
        this.unindexedItems[drawingName] = [];
        this.indexedItems[drawingName] = {};
        this.touchZonesByCmd[drawingName] = {};
        this.touchActionsByCmd[drawingName] = {};
        this.touchActionInputsByCmd[drawingName] = {};
        return this;
    }
    
    // Get all unindexed items for a drawing
    getUnindexedItems(drawingName = null) {
        const name = drawingName || (this.getMainDrawingName());
        return this.unindexedItems[name] || [];
    }
    
    // Get all indexed items for a drawing
    getIndexedItems(drawingName = null) {
        const name = drawingName || (this.getMainDrawingName());
        return this.indexedItems[name] || {};
    }
    
    // Add an inserted drawing
    addInsertedDrawing(drawingName, xOffset, yOffset, transform, parentDrawing) {
        // Add to tracking array if not already present
        if (!this.drawings.includes(drawingName)) {
            this.drawings.push(drawingName);
        }
        
        // Initialize data structure for the inserted drawing
        this.drawingsData[drawingName] = {
            xOffset: xOffset,
            yOffset: yOffset,
            transform: transform || { x: 0, y: 0, scale: 1.0 },
            data: null,
            parentDrawing: parentDrawing
        };
        
        // Initialize saved transform
        this.savedTransforms[drawingName] = { x: 0, y: 0, scale: 1.0 };
        
        // Set response status to false (pending) when request is queued
        this.drawingResponseStatus[drawingName] = false;
        
        // Ensure the item collections exist for this drawing
        this.ensureItemCollections(drawingName);
        
        return this;
    }
 /**   
    // Set data for an inserted drawing
    setInsertedDrawingData(drawingName, data) {
        if (this.drawingsData[drawingName]) {
            this.drawingsData[drawingName].data = data;
            
            // Set response status to true when response is received
            this.drawingResponseStatus[drawingName] = true;
            console.log(`[DRAWING_MANAGER] Set response status to TRUE for "${drawingName}"`);
        } else {
            console.warn(`[DRAWING_MANAGER] Cannot set data for "${drawingName}" - not found in drawingsData`);
        }
        return this;
    }
 **/   
    // Remove an inserted drawing
    removeInsertedDrawing(drawingName) {
         console.log(`[DRAWING_MANAGER] Remove inserted drawing: "${drawingName}" `);
        // Cannot remove the main drawing (first in the array)
        if (this.getMainDrawingName() === drawingName) {
            console.warn(`[DRAWING_MANAGER] Cannot remove main drawing "${drawingName}"`);
            return this;
        }
        
        // Remove from drawings array
        const index = this.drawings.indexOf(drawingName);
        if (index !== -1) {
            this.drawings.splice(index, 1);
        }
        
        // Remove the drawing data
        delete this.drawingsData[drawingName];
        
        // Remove the drawing's item collections
        delete this.unindexedItems[drawingName];
        delete this.indexedItems[drawingName];
        
        // Remove saved transform
        delete this.savedTransforms[drawingName];
        
        // Remove response status
        delete this.drawingResponseStatus[drawingName];
        
        return this;
    }
    
    // Remove touchZone and associated touchActions by cmd, and also erase insertDwg items
    eraseByCmd(drawingName, cmd, dwgName = null) {
        console.log(`[DRAWING_MANAGER] Erasing touchZone and associated actions for cmd="${cmd}" in drawing="${drawingName}"`);
        if (!dwgName) {
        // Remove touchZone
        if (this.touchZonesByCmd[drawingName] && this.touchZonesByCmd[drawingName][cmd]) {
            delete this.touchZonesByCmd[drawingName][cmd];
            console.log(`[DRAWING_MANAGER] Removed touchZone for cmd="${cmd}"`);
        }
        
        // Remove associated touchActions
        if (this.touchActionsByCmd[drawingName] && this.touchActionsByCmd[drawingName][cmd]) {
            delete this.touchActionsByCmd[drawingName][cmd];
            console.log(`[DRAWING_MANAGER] Removed touchActions for cmd="${cmd}"`);
        }
        
        // Remove associated touchActionInputs
        if (this.touchActionInputsByCmd[drawingName] && this.touchActionInputsByCmd[drawingName][cmd]) {
            delete this.touchActionInputsByCmd[drawingName][cmd];
            console.log(`[DRAWING_MANAGER] Removed touchActionInput for cmd="${cmd}"`);
        }
        } else {
          // Also erase any insertDwg items with drawingName matching the cmd
          this.eraseInsertDwgByCmd(drawingName, cmd);
        }
        
        return this;
    }
    
    // Remove insertDwg items and recursively cleanup associated data
    eraseInsertDwgByCmd(parentDrawingName, targetDrawingName) {
        console.log(`[DRAWING_MANAGER] Erasing insertDwg for drawing="${targetDrawingName}" from parent="${parentDrawingName}"`);
        
        // Remove insertDwg items from unindexed items where drawingName matches cmd
        if (this.unindexedItems[parentDrawingName]) {
            const originalLength = this.unindexedItems[parentDrawingName].length;
            this.unindexedItems[parentDrawingName] = this.unindexedItems[parentDrawingName].filter(item => {
                if (item.type === 'insertDwg' && item.drawingName === targetDrawingName) {
                    console.log(`[DRAWING_MANAGER] Removing insertDwg item for "${targetDrawingName}" from unindexed items`);
                    return false; // Remove this item
                }
                return true; // Keep this item
            });
            const newLength = this.unindexedItems[parentDrawingName].length;
            if (originalLength !== newLength) {
                console.log(`[DRAWING_MANAGER] Removed ${originalLength - newLength} insertDwg items from unindexed items`);
            }
        }
        
        // Recursively remove all drawings that were inserted by the target drawing
        if (this.unindexedItems[targetDrawingName]) {
            const insertDwgItems = this.unindexedItems[targetDrawingName].filter(item => 
                item.type === 'insertDwg'
            );
            
            insertDwgItems.forEach(item => {
                console.log(`[DRAWING_MANAGER] Recursively removing nested insertDwg: "${item.drawingName}"`);
                this.eraseInsertDwgByCmd(targetDrawingName, item.drawingName);
            });
        }
        
        // Remove the inserted drawing from our tracking and cleanup all associated data
        if (this.drawings.includes(targetDrawingName)) {
            this.removeInsertedDrawing(targetDrawingName);
            console.log(`[DRAWING_MANAGER] Removed inserted drawing "${targetDrawingName}" from drawings array and cleaned up data`);
        }
        
        // Clear localStorage for the erased drawing
        try {
            localStorage.removeItem(`${targetDrawingName}_version`);
            localStorage.removeItem(`${targetDrawingName}_data`);
            console.log(`[DRAWING_MANAGER] Cleared localStorage for "${targetDrawingName}"`);
        } catch (error) {
            console.error(`[DRAWING_MANAGER] Error clearing localStorage for "${targetDrawingName}":`, error);
        }
        
        return this;
    }
    
    // Hide touchZone and insertDwg items by cmd
    hideByCmd(drawingName, cmd, dwgName = null) {
        console.log(`[DRAWING_MANAGER] Hiding items with cmd="${cmd}" in drawing="${drawingName}"`);
        if (!dwgName) {
        // Hide touchZone
        if (this.touchZonesByCmd[drawingName] && this.touchZonesByCmd[drawingName][cmd]) {
            this.touchZonesByCmd[drawingName][cmd].visible = false;
            console.log(`[DRAWING_MANAGER] Hidden touchZone for cmd="${cmd}"`);
        }
        } else {
        // Hide insertDwg items with cmd matching the hide command
        if (this.unindexedItems[drawingName]) {
            console.log(`[DRAWING_MANAGER] Checking ${this.unindexedItems[drawingName].length} unindexed items for insertDwg to hide with cmd="${cmd}"`);
            this.unindexedItems[drawingName].forEach((item, index) => {
                if (item.type === 'insertDwg') {
                    console.log(`[DRAWING_MANAGER] Found insertDwg item ${index}: cmd="${item.cmd}", target cmd="${cmd}", match=${item.cmd === cmd}`);
                    if (item.cmd === cmd) {
                        item.visible = false;
                        console.log(`[DRAWING_MANAGER] Hidden insertDwg item with cmd="${cmd}"`);
                    }
                }
            });
        }
        }
        
        return this;
    }
    
    // Unhide touchZone and insertDwg items by cmd
    unhideByCmd(drawingName, cmd, dwgName = null) {
        console.log(`[DRAWING_MANAGER] Unhiding items with cmd="${cmd}" in drawing="${drawingName}"`);
        if (!dwgName) {
        // Unhide touchZone
        if (this.touchZonesByCmd[drawingName] && this.touchZonesByCmd[drawingName][cmd]) {
            this.touchZonesByCmd[drawingName][cmd].visible = true;
            console.log(`[DRAWING_MANAGER] Unhidden touchZone for cmd="${cmd}"`);
        }
        } else {
        // Unhide insertDwg items with cmd matching the unhide command
        if (this.unindexedItems[drawingName]) {
            this.unindexedItems[drawingName].forEach(item => {
                if (item.type === 'insertDwg' && item.cmd === cmd) {
                    item.visible = true;
                    console.log(`[DRAWING_MANAGER] Unhidden insertDwg item with cmd="${cmd}"`);
                }
            });
        }
        }
        return this;
    }
    
    // Get all child drawings for a parent drawing
    getChildDrawings(parentDrawingName) {
        const childDrawings = [];
        
        for (const childName in this.drawingsData) {
            if (this.drawingsData[childName].parentDrawing === parentDrawingName) {
                childDrawings.push(childName);
            }
        }
        
        return childDrawings;
    }
    
    // Save the current transform for a drawing
    saveTransform(drawingName, transform) {
        this.savedTransforms[drawingName] = { ...transform };
        return this;
    }
    
    // Get the saved transform for a drawing
    getTransform(drawingName) {
        return this.savedTransforms[drawingName] || { x: 0, y: 0, scale: 1.0 };
    }
    
    // Get all data needed for the mergeAndRedraw module
    getMergeAndRedrawState() {
        // Get the main drawing name (first in the array)
        const mainDrawingName = this.getMainDrawingName();
        
        return {
            unindexedItems: this.unindexedItems,
            indexedItems: this.indexedItems,
            touchZonesByCmd: this.touchZonesByCmd,
            touchActionsByCmd: this.touchActionsByCmd,
            touchActionInputsByCmd: this.touchActionInputsByCmd,
            allTouchZonesByCmd: this.allTouchZonesByCmd,
            currentDrawingName: mainDrawingName,
            drawings: this.drawings,
            drawingsData: this.drawingsData,
            allDrawingsReceived: this.allDrawingsReceived, // this is not actually used!!
            drawingResponseStatus: this.drawingResponseStatus
        };
    }
    
    // Return initial transform state based on command type
    // This doesn't store any state, just returns the appropriate initial transform
    getInitialTransform(drawingName, command) {
        const name = drawingName || (this.getMainDrawingName());
        
        if (command === 'start') {
            // For 'start' commands, always use initial state
            console.log(`[TRANSFORM] Using initial transform (0,0,1.0) for drawing start: ${name}`);
            return { x: 0, y: 0, scale: 1.0 };
        } else if (command === 'update' && this.savedTransforms[name]) {
            // For 'update' commands, use the saved transform if available
            const savedTransform = {...this.savedTransforms[name]};
            console.log(`[TRANSFORM] Using saved transform for update: x=${savedTransform.x}, y=${savedTransform.y}, scale=${savedTransform.scale}`);
            return savedTransform;
        } else {
            // Default fallback
            console.log(`[TRANSFORM] No saved transform found, using default (0,0,1.0)`);
            return { x: 0, y: 0, scale: 1.0 };
        }
    }
    
    // Load drawing data from localStorage (if available)
    loadFromLocalStorage(drawingName) {
        try {
            const savedVersion = localStorage.getItem(`${drawingName}_version`);
            const savedData = localStorage.getItem(`${drawingName}_data`);
            
            if (savedData) {
                const drawingData = JSON.parse(savedData);
                
                // Ensure the drawing is in the drawings array
                if (!this.drawings.includes(drawingName)) {
                        this.drawings.push(drawingName);
                }
                
                // Create or update drawingsData entry
                if (!this.drawingsData[drawingName]) {
                    this.drawingsData[drawingName] = {
                        xOffset: 0,
                        yOffset: 0,
                        transform: { x: 0, y: 0, scale: 1.0 },
                        data: null,
                        parentDrawing: null
                    };
                }
                
                // Update the data
                this.drawingsData[drawingName].data = drawingData;
                this.drawingResponseStatus[drawingName] = true;
                
                console.log(`DrawingManager: Loaded drawing ${drawingName} from localStorage (version: ${savedVersion})`);
                return drawingData;
            }
        } catch (error) {
            console.error(`Error loading drawing ${drawingName} from localStorage:`, error);
        }
        
        return null;
    }
    
    // Save drawing data to localStorage
    saveToLocalStorage(drawingName) {
        const drawingData = this.drawingsData[drawingName]?.data;
        
        if (!drawingData) {
            console.warn(`Cannot save drawing ${drawingName} to localStorage: No data available.`);
            return this;
        }
        
        try {
            // Save the version separately
            console.log(`[DRAWINGMANAGER_DEBUG] About to save version for ${drawingName}: drawingData.version = "${drawingData.version}"`);
            if (drawingData.version) {
                localStorage.setItem(`${drawingName}_version`, drawingData.version);
                console.log(`[DRAWINGMANAGER_DEBUG] Saved version "${drawingData.version}" to localStorage`);
            } else {
                console.log(`[DRAWINGMANAGER_DEBUG] NOT saving version - drawingData.version is falsy: "${drawingData.version}"`);
            }
            
            // Save the drawing data
            localStorage.setItem(`${drawingName}_data`, JSON.stringify(drawingData));
            console.log(`DrawingManager: Saved drawing ${drawingName} to localStorage (version: ${drawingData.version})`);
        } catch (error) {
            console.error(`Error saving drawing ${drawingName} to localStorage:`, error);
        }
        
        return this;
    }
    
    // Helper method to ensure item collections exist for a drawing
    ensureItemCollections(drawingName) {
        if (!this.unindexedItems[drawingName]) {
            this.unindexedItems[drawingName] = [];
        }
        if (!this.indexedItems[drawingName]) {
            this.indexedItems[drawingName] = {};
        }
        if (!this.touchZonesByCmd[drawingName]) {
            this.touchZonesByCmd[drawingName] = {};
        }
        if (!this.touchActionsByCmd[drawingName]) {
            this.touchActionsByCmd[drawingName] = {};
        }
        if (!this.touchActionInputsByCmd[drawingName]) {
            this.touchActionInputsByCmd[drawingName] = {};
        }
    }
    
    getMainDrawingName() {
         const mainDrawingName = this.drawings.length > 0 ? this.drawings[0] : '';
         return mainDrawingName;
    }

    getCurrentDrawingName() {
         return this.getMainDrawingName();
    }

    // Create a structured response for sharing state with other modules
    getState() {
        // Main drawing is always the first in the array
        const mainDrawingName = this.getMainDrawingName();
        
        return {
            currentDrawingName: mainDrawingName,
            drawings: this.drawings,
            drawingsData: this.drawingsData,
            unindexedItems: this.unindexedItems,
            indexedItems: this.indexedItems,
            allDrawingsReceived: this.allDrawingsReceived,
            savedTransforms: this.savedTransforms,
            drawingResponseStatus: this.drawingResponseStatus
        };
    }
    
    // Get the response status for a drawing
    getDrawingResponseStatus(drawingName) {
        // Add debug logging to help troubleshoot
        console.log(`[DRAWING_MANAGER] Checking response status for "${drawingName}": ${this.drawingResponseStatus[drawingName]}`);
        
        // If it's undefined, treat as false - if it's truthy, treat as true
        return !!this.drawingResponseStatus[drawingName];
    }
    
    // Load merged data from localStorage based on main drawing organization
    loadMergedDataFromStorage() {
        console.log('[DRAWING_MANAGER] Loading merged data from localStorage...');
        
        try {
            // Look for any main drawing storage keys
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('pfodWeb_mainDwg_')) {
                    const mainDrawingName = key.replace('pfodWeb_mainDwg_', '');
                    console.log(`[DRAWING_MANAGER] Found stored data for main drawing: ${mainDrawingName}`);
                }
            }
        } catch (error) {
            console.error('[DRAWING_MANAGER] Error loading merged data from localStorage:', error);
        }
    }
    
    // Save merged data to localStorage organized by main drawing
    saveMergedDataToStorage(mainDrawingName) {
        if (!mainDrawingName) {
            console.warn('[DRAWING_MANAGER] Cannot save merged data: No main drawing name provided');
            return;
        }
        
        try {
            const storageKey = `pfodWeb_mainDwg_${mainDrawingName}`;
            
            // Get all inserted drawings for this main drawing
            const insertedDrawings = [];
            for (const drawingName in this.drawingsData) {
                if (this.drawingsData[drawingName].parentDrawing === mainDrawingName) {
                    insertedDrawings.push(drawingName);
                }
            }
            
            // Create storage structure for this main drawing
            const mainDrawingStorage = {
                mainDrawingName: mainDrawingName,
                insertedDrawings: insertedDrawings,
                mergedData: {
                    touchZonesByCmd: this.touchZonesByCmd[mainDrawingName] || {},
                    touchActionsByCmd: this.touchActionsByCmd[mainDrawingName] || {},
                    touchActionInputsByCmd: this.touchActionInputsByCmd[mainDrawingName] || {},
                    unindexedItems: this.unindexedItems[mainDrawingName] || [],
                    indexedItems: this.indexedItems[mainDrawingName] || {},
                    allTouchZonesByCmd: this.allTouchZonesByCmd || {}
                },
                individualDrawings: {}
            };
            
            // Store individual drawing data for main drawing and its inserted drawings
            if (this.drawingsData[mainDrawingName]?.data) {
                mainDrawingStorage.individualDrawings[mainDrawingName] = {
                    rawData: this.drawingsData[mainDrawingName].data,
                    version: this.drawingsData[mainDrawingName].data.version
                };
            }
            
            // Store data for inserted drawings
            insertedDrawings.forEach(drawingName => {
                if (this.drawingsData[drawingName]?.data) {
                    mainDrawingStorage.individualDrawings[drawingName] = {
                        rawData: this.drawingsData[drawingName].data,
                        version: this.drawingsData[drawingName].data.version
                    };
                }
            });
            
            // Save to localStorage
            localStorage.setItem(storageKey, JSON.stringify(mainDrawingStorage));
            console.log(`[DRAWING_MANAGER] Saved merged data for main drawing "${mainDrawingName}" to localStorage`);
            
        } catch (error) {
            console.error(`[DRAWING_MANAGER] Error saving merged data for "${mainDrawingName}":`, error);
        }
    }
    
    // Load merged data for a specific main drawing from localStorage
    loadMergedDataForMainDrawing(mainDrawingName) {
        if (!mainDrawingName) {
            return null;
        }
        
        try {
            const storageKey = `pfodWeb_mainDwg_${mainDrawingName}`;
            const savedData = localStorage.getItem(storageKey);
            
            if (savedData) {
                const mainDrawingStorage = JSON.parse(savedData);
                
                // Restore the main drawing in the drawings array
                if (!this.drawings.includes(mainDrawingName)) {
                    this.drawings.unshift(mainDrawingName);
                }
                
                // Restore merged data for the main drawing
                this.touchZonesByCmd[mainDrawingName] = mainDrawingStorage.mergedData.touchZonesByCmd || {};
                this.touchActionsByCmd[mainDrawingName] = mainDrawingStorage.mergedData.touchActionsByCmd || {};
                this.touchActionInputsByCmd[mainDrawingName] = mainDrawingStorage.mergedData.touchActionInputsByCmd || {};
                this.unindexedItems[mainDrawingName] = mainDrawingStorage.mergedData.unindexedItems || [];
                this.indexedItems[mainDrawingName] = mainDrawingStorage.mergedData.indexedItems || {};
                this.allTouchZonesByCmd = mainDrawingStorage.mergedData.allTouchZonesByCmd || {};
                
                // Restore individual drawing data
                for (const drawingName in mainDrawingStorage.individualDrawings) {
                    const drawingInfo = mainDrawingStorage.individualDrawings[drawingName];
                    
                    // Add to drawings array if not present
                    if (!this.drawings.includes(drawingName)) {
                        this.drawings.push(drawingName);
                    }
                    
                    // Create drawingsData entry
                    if (!this.drawingsData[drawingName]) {
                        this.drawingsData[drawingName] = {
                            xOffset: 0,
                            yOffset: 0,
                            transform: { x: 0, y: 0, scale: 1.0 },
                            data: null,
                            parentDrawing: drawingName === mainDrawingName ? null : mainDrawingName
                        };
                    }
                    
                    // Restore the drawing data
                    this.drawingsData[drawingName].data = drawingInfo.rawData;
                    this.drawingResponseStatus[drawingName] = true;
                    
                    // Ensure item collections exist
                    this.ensureItemCollections(drawingName);
                }
                
                console.log(`[DRAWING_MANAGER] Loaded merged data for main drawing "${mainDrawingName}" from localStorage`);
                return mainDrawingStorage;
            }
        } catch (error) {
            console.error(`[DRAWING_MANAGER] Error loading merged data for "${mainDrawingName}":`, error);
        }
        
        return null;
    }
    
    // Get the version number for a specific drawing from localStorage
    getStoredVersion(drawingName) {
        if (!drawingName) return null;
        
        // First check if we have it in memory
        if (this.drawingsData[drawingName]?.data?.version) {
            return this.drawingsData[drawingName].data.version;
        }
        
        // Try to find it in localStorage by checking all main drawing storage
        try {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('pfodWeb_mainDwg_')) {
                    const savedData = localStorage.getItem(key);
                    if (savedData) {
                        const mainDrawingStorage = JSON.parse(savedData);
                        if (mainDrawingStorage.individualDrawings[drawingName]) {
                            return mainDrawingStorage.individualDrawings[drawingName].version;
                        }
                    }
                }
            }
        } catch (error) {
            console.error(`[DRAWING_MANAGER] Error getting stored version for "${drawingName}":`, error);
        }
        
        return null;
    }
}

// Make DrawingManager available globally for class definition access
// IMPORTANT: Only pfodWeb should create instances of DrawingManager
// Other modules should use the instance provided by pfodWeb
window.DrawingManager = DrawingManager;


/* ========================================
 * Inlined from: displayTextUtils.js
 * ======================================== */
/*   
   displayTextUtils.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// Utility functions for display text formatting
// Extracted from add-item.js and redraw.js to be reusable across server and client code

// JavaScript implementation of printFloatDecimals based on C++ version
// prints just number rounded to decPlaces, -ve decPlaces round to left of decimal point
function printFloatDecimals(f, decPlaces) {
    if (f === undefined || f === null) {
        return '';
    }
    
    let isNegative = false;
    if (f < 0) {
        f = -f;
        isNegative = true;
    }
    
    let result = '';
    
    if (decPlaces <= 0) {
        let iValue = Math.floor(f);
        if ((f - iValue) !== 0) {
            // round
            iValue = Math.floor(f + 0.5);
        }
        
        if (decPlaces === 0) {
            result = iValue.toString();
        } else {
            // decPlaces < 0
            // limit divider to be < number so always get something
            let divider = 1;
            for (let i = 0; i < (-decPlaces) && (divider < iValue); i++) {
                divider = divider * 10;
            }
            if (divider > iValue) {
                divider = Math.floor(divider / 10);
            }
            let idValue = Math.floor(iValue / divider) * divider;
            if ((idValue - iValue) !== 0) {
                // need to round
                iValue = iValue + Math.floor(divider / 2);
                iValue = Math.floor(iValue / divider);
                idValue = iValue * divider;
            }
            result = idValue.toString();
        }
    } else {
        // decPlaces > 0
        result = f.toFixed(decPlaces);
    }
    
    return isNegative ? '-' + result : result;
}

// Utility function to add formatted value to text (used by labels)
// Returns the text with formatted value and units appended if value exists
function addFormattedValueToText(text, item) {
    if (item.value !== undefined && item.value !== null && item.value !== '') {
        const decimals = (item.decimals !== undefined && item.decimals !== null) ? parseInt(item.decimals) : 2;
        const units = item.units || '';
        const formattedValue = printFloatDecimals(parseFloat(item.value), decimals);
        return text + formattedValue + units;
    }
    return text;
}

function generateItemDisplayText(item) {
    if (item.type === 'label') {
        // Label text generation: text + formatted value + units (if value exists)
        const text = item.text || '';
        return addFormattedValueToText(text, item);
    } else if (item.type === 'value') {
        // Value text generation: text + scaled/formatted intValue + units
        const textPrefix = item.text || '';
        const intValue = parseFloat(item.intValue || 0);
        const max = parseFloat(item.max || 1);
        const min = parseFloat(item.min || 0);
        const displayMax = parseFloat(item.displayMax || 1.0);
        const displayMin = parseFloat(item.displayMin || 0.0);
        const decimals = (item.decimals !== undefined && item.decimals !== null) ? parseInt(item.decimals) : 2;
        const units = item.units || '';
        
        // Scale the value (same logic as pfodWebMouse)
        let maxMin = max - min;
        if (maxMin === 0) maxMin = 1;  // Prevent division by zero
        const scaledValue = (intValue - min) * (displayMax - displayMin) / maxMin + displayMin;
        
        // Format and combine
        const formattedValue = printFloatDecimals(scaledValue, decimals);
        const displayText = textPrefix + formattedValue + units;
        
        return displayText;
    } else {
        // For other item types, just return the basic text
        return item.text || item.textFormat || '';
    }
}

// Font size calculation for touchActionInput dialogs
// fontSize 0 = 14px for dialog boxes, with baseFontSize = 14
function getActualFontSizeForDialog(relativeFontSize) {
    const baseFontSize = 14;
    const factor = 1.1225;
    
    // Ensure we have an integer
    const intFontSize = Math.round(relativeFontSize);
    
    if (intFontSize === 0) {
        return baseFontSize; // 14px
    } else if (intFontSize > 0) {
        return baseFontSize * Math.pow(factor, intFontSize);
    } else {
        return baseFontSize / Math.pow(factor, Math.abs(intFontSize));
    }
}

// Color conversion function for touchActionInput dialogs
// Converts color index to hex color value
function convertColorToHex(colorIndex) {
    // Check if colorUtils is available and has the conversion function
    if (typeof getColorValue === 'function') {
        return getColorValue(colorIndex);
    }
    
    // Fallback color mapping for basic colors
    const colorMap = {
        0: '#000000',   // Black
        1: '#800000',   // Maroon
        2: '#008000',   // Green
        3: '#808000',   // Olive
        4: '#000080',   // Navy
        5: '#800080',   // Purple
        6: '#008080',   // Teal
        7: '#C0C0C0',   // Silver
        8: '#808080',   // Gray
        9: '#FF0000',   // Red
        10: '#00FF00',  // Lime
        11: '#FFFF00',  // Yellow
        12: '#0000FF',  // Blue
        13: '#FF00FF',  // Fuchsia
        14: '#00FFFF',  // Aqua
        15: '#FFFFFF'   // White
    };
    
    return colorMap[colorIndex] || '#000000';
}

// Export for browser (client-side) - no longer needed server-side
if (typeof window !== 'undefined') {
    window.printFloatDecimals = printFloatDecimals;
    window.addFormattedValueToText = addFormattedValueToText;
    window.generateItemDisplayText = generateItemDisplayText;
    window.getActualFontSizeForDialog = getActualFontSizeForDialog;
    window.convertColorToHex = convertColorToHex;
}


/* ========================================
 * Inlined from: redraw.js
 * ======================================== */
/*   
   redraw.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// Redraw module - handles all canvas drawing operations
// Supports multiple independent viewer instances

// Convert relative fontSize to actual pixel size
// fontSize 0 = 2.9, +1 = 2.9*1.1225, -1 = 2.9/1.1225, etc.
// +6 doubles size, -6 halves size
// relativeFontSize must be an integer
function getActualFontSize(relativeFontSize) {
    const baseFontSize = 2.9;
    const factor = 1.1225;
    
    // Ensure we have an integer
    const intFontSize = Math.round(relativeFontSize);
    
    if (intFontSize === 0) {
        return baseFontSize;
    } else if (intFontSize > 0) {
        return baseFontSize * Math.pow(factor, intFontSize);
    } else {
        return baseFontSize / Math.pow(factor, Math.abs(intFontSize));
    }
}

// Import formatting utilities
// Note: printFloatDecimals and addFormattedValueToText are now in displayTextUtils.js

// Get appropriate black or white color based on background contrast
function getBlackWhite(color) {
    // Convert color to RGB values
    function getRGB(color) {
        // Handle hex colors
        if (typeof color === 'string' && color.startsWith('#')) {
            const hex = color.slice(1);
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return [r, g, b];
        }
        
        // Handle color numbers - convert to hex first, then to RGB using xtermColorToHex
        const hexColor = xtermColorToHex(color);
        const hex = hexColor.slice(1);
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        return [r, g, b];
    }
    
    const [r, g, b] = getRGB(color);
    
    // Use the same algorithm as Java code: y = (299 * R + 587 * G + 114 * B) / 1000
    const y = (299 * r + 587 * g + 114 * b) / 1000;
    
    // If y >= 128, background is light, use black text. Otherwise use white text.
    return y >= 128 ? 0 : 15; // BLACK (0) : WHITE (15)
}

// Convert xterm 256 color index to RGB hex color
function xtermColorToHex(colorIndex) {
    // Handle non-numeric input or out of range - use black
    if (typeof colorIndex !== 'number' || colorIndex > 255 || colorIndex < 0) {
        return '#000000';
    }
    
    // Clamp input to valid range
    colorIndex = Math.max(0, Math.min(255, Math.floor(colorIndex)));
    
    let r, g, b;
    
    if (colorIndex < 16) {
        // Standard colors (0-15)
        const standardColors = [
            [0, 0, 0],       // 0: Black
            [128, 0, 0],     // 1: Maroon
            [0, 128, 0],     // 2: Green
            [128, 128, 0],   // 3: Olive
            [0, 0, 128],     // 4: Navy
            [128, 0, 128],   // 5: Purple
            [0, 128, 128],   // 6: Teal
            [192, 192, 192], // 7: Silver
            [128, 128, 128], // 8: Grey
            [255, 0, 0],     // 9: Red
            [0, 255, 0],     // 10: Lime
            [255, 255, 0],   // 11: Yellow
            [0, 0, 255],     // 12: Blue
            [255, 0, 255],   // 13: Fuchsia
            [0, 255, 255],   // 14: Aqua
            [255, 255, 255]  // 15: White
        ];
        [r, g, b] = standardColors[colorIndex];
        
    } else if (colorIndex >= 16 && colorIndex <= 231) {
        // 216 color cube (16-231)
        const cubeIndex = colorIndex - 16;
        const cubeValues = [0, 95, 135, 175, 215, 255];
        
        const rIndex = Math.floor(cubeIndex / 36);
        const gIndex = Math.floor((cubeIndex % 36) / 6);
        const bIndex = cubeIndex % 6;
        
        r = cubeValues[rIndex];
        g = cubeValues[gIndex];
        b = cubeValues[bIndex];
        
    } else {
        // Grayscale ramp (232-255)
        const grayIndex = colorIndex - 232;
        const grayValue = 8 + grayIndex * 10;
        r = g = b = grayValue;
    }
    
    const toHex = (value) => {
        const hex = value.toString(16).toUpperCase();
        return hex.length === 1 ? '0' + hex : hex;
    };
    
    return '#' + toHex(r) + toHex(g) + toHex(b);
}

// Convert color value to hex - only supports integers (0-255)
function convertColorToHex(color, backgroundColorNumber = null) {
    // Handle Black/White mode (color -1)
    if (color === -1 && backgroundColorNumber !== null) {
        const blackWhiteColor = getBlackWhite(backgroundColorNumber);
        return xtermColorToHex(blackWhiteColor);
    }
    
    // Support both integer colors and string numbers
    if (typeof color === 'number') {
        return xtermColorToHex(color);
    }
    if (typeof color === 'string' && !isNaN(color)) {
        hexColor = isNaN(parseInt(color))? 0 : parseInt(color);
        return xtermColorToHex(hexColor);
    }
    // Any non-integer color defaults to black
    return '#000000';
}

class Redraw {
    constructor(canvas, ctx, initialDimensions = null) {
        // Instance variables for multi-viewer isolation
        this.canvas = canvas;
        this.ctx = ctx;

        // Local drawing manager for redraw operations
        this.redrawDrawingManager = new window.DrawingManager();

        // Original data holder - stores pristine copy for restoration
        this.originalDataManager = new window.DrawingManager();

        // Drawing state
        this.currentBackgroundColor = 0; // Store current drawing background color for Black/White mode

        // Canvas caching for optimization
        this.cachedCanvasWidth = 0;
        this.cachedCanvasHeight = 0;
        this.hasCompletedFirstDraw = false;

        // Track last dimensions for resize optimization
        // Initialize from loaded dimensions if provided
        if (initialDimensions) {
            this.lastLogicalWidth = initialDimensions.logicalWidth;
            this.lastLogicalHeight = initialDimensions.logicalHeight;
            this.lastWindowWidth = initialDimensions.windowWidth;
            this.lastWindowHeight = initialDimensions.windowHeight;
            console.log(`[REDRAW] Initialized with dimensions: logical=${this.lastLogicalWidth}x${this.lastLogicalHeight}, window=${this.lastWindowWidth}x${this.lastWindowHeight}`);
        } else {
            this.lastLogicalWidth = null;
            this.lastLogicalHeight = null;
            this.lastWindowWidth = null;
            this.lastWindowHeight = null;
        }
    }

    // Redraw uses its own local data - no external configuration needed

        // Get global display transform for merged canvas
    getGlobalTransform() {
        return this.redrawDrawingManager.globalTransform || { x: 0, y: 0, scale: 1.0 };
    }

    // Helper methods to access drawing manager state
    // Helper methods to access drawing manager data
    /**
    getUnindexedItems(drawingName) {
        return this.redrawDrawingManager.unindexedItems[drawingName] || [];
    }

    getIndexedItems(drawingName) {
        return this.redrawDrawingManager.indexedItems[drawingName] || {};
    }
    getTouchZonesByCmd(drawingName) {
        return this.redrawDrawingManager.touchZonesByCmd[drawingName] || {};
    }
    
    getTouchActionsByCmd(drawingName) {
        return this.redrawDrawingManager.touchActionsByCmd[drawingName] || {};
    }

    getDrawingResponseStatus(drawingName) {
        return this.redrawDrawingManager.drawingResponseStatus[drawingName] || false;
    }

    getCurrentTransform(drawingName) {
        return this.redrawDrawingManager.getCurrentTransform(drawingName);
    }

    getCurrentDrawingName() {
        return this.redrawDrawingManager.drawings.length > 0 ? this.redrawDrawingManager.drawings[0] : '';
    }

    // Get all touch zones by cmd - this replaces global touchZonesByCmd access
    getAllTouchZonesByCmd() {
        return this.redrawDrawingManager.allTouchZonesByCmd || {};
    }

    // Get merged touchActions for mouse operations
    getAllTouchActionsByCmd() {
        return this.redrawDrawingManager.allTouchActionsByCmd || {};
    }

    // Get merged touchActionInputs for mouse operations 
    getAllTouchActionInputsByCmd() {
        return this.redrawDrawingManager.allTouchActionInputsByCmd || {};
    }


    // Set global display transform for merged canvas
    setGlobalTransform(transform) {
        this.redrawDrawingManager.globalTransform = { ...transform };
    }

    // Get merged unindexed items for mouse operations
    getAllUnindexedItems() {
        return this.redrawDrawingManager.allUnindexedItems || [];
    }

    // Get merged indexed items for mouse operations
    getAllIndexedItemsByNumber() {
        return this.redrawDrawingManager.allIndexedItemsByNumber || {};
    }
**/


        // This would need to be implemented based on how transforms are stored

    getCurrentDrawingName() {
        return this.redrawDrawingManager.drawings.length > 0 ? this.redrawDrawingManager.drawings[0] : '';
    }

    // Copy ALL data TO shadow drawing manager for processing (moved from mergeAndRedraw.js)
    copyToShadow(shadowDrawingManager) {
        if (shadowDrawingManager && this.redrawDrawingManager) {
            // Set inUse flag before copying
            shadowDrawingManager.inUse = true;
            // Deep copy ALL collections and properties
            shadowDrawingManager.touchZonesByCmd = JSON.parse(JSON.stringify(this.redrawDrawingManager.touchZonesByCmd || {}));
            shadowDrawingManager.touchActionsByCmd = JSON.parse(JSON.stringify(this.redrawDrawingManager.touchActionsByCmd || {}));
            shadowDrawingManager.touchActionInputsByCmd = JSON.parse(JSON.stringify(this.redrawDrawingManager.touchActionInputsByCmd || {}));
            shadowDrawingManager.allTouchActionsByCmd = JSON.parse(JSON.stringify(this.redrawDrawingManager.allTouchActionsByCmd || {}));
            shadowDrawingManager.allTouchActionInputsByCmd = JSON.parse(JSON.stringify(this.redrawDrawingManager.allTouchActionInputsByCmd || {}));
            shadowDrawingManager.allTouchZonesByCmd = JSON.parse(JSON.stringify(this.redrawDrawingManager.allTouchZonesByCmd || {}));
            shadowDrawingManager.allUnindexedItems = JSON.parse(JSON.stringify(this.redrawDrawingManager.allUnindexedItems || []));
            shadowDrawingManager.allIndexedItemsByNumber = JSON.parse(JSON.stringify(this.redrawDrawingManager.allIndexedItemsByNumber || {}));
            shadowDrawingManager.unindexedItems = JSON.parse(JSON.stringify(this.redrawDrawingManager.unindexedItems || {}));
            shadowDrawingManager.indexedItems = JSON.parse(JSON.stringify(this.redrawDrawingManager.indexedItems || {}));
            shadowDrawingManager.drawings = JSON.parse(JSON.stringify(this.redrawDrawingManager.drawings || []));
            shadowDrawingManager.drawingsData = JSON.parse(JSON.stringify(this.redrawDrawingManager.drawingsData || {}));
            shadowDrawingManager.savedTransforms = JSON.parse(JSON.stringify(this.redrawDrawingManager.savedTransforms || {}));
            shadowDrawingManager.drawingResponseStatus = JSON.parse(JSON.stringify(this.redrawDrawingManager.drawingResponseStatus || {}));

            // Copy scalar properties
            shadowDrawingManager.currentDrawingName = this.redrawDrawingManager.currentDrawingName;
            shadowDrawingManager.allDrawingsReceived = this.redrawDrawingManager.allDrawingsReceived;
            shadowDrawingManager.globalTransform = JSON.parse(JSON.stringify(this.getGlobalTransform()));

            console.log(`[REDRAW] Copied ALL data TO shadow`);
        }
    }

    // Update redraw drawing manager FROM processed shadow (moved from mergeAndRedraw.js)
    updateFromShadow(shadowDrawingManager) {
        if (shadowDrawingManager.inUse) {
            // Save current state to original data holder before updating
//            this.saveToOriginalData();

            // Deep copy ALL processed shadow data to redraw drawing manager
            this.redrawDrawingManager.touchZonesByCmd = JSON.parse(JSON.stringify(shadowDrawingManager.touchZonesByCmd || {}));
            this.redrawDrawingManager.touchActionsByCmd = JSON.parse(JSON.stringify(shadowDrawingManager.touchActionsByCmd || {}));
            this.redrawDrawingManager.touchActionInputsByCmd = JSON.parse(JSON.stringify(shadowDrawingManager.touchActionInputsByCmd || {}));
            this.redrawDrawingManager.allTouchActionsByCmd = JSON.parse(JSON.stringify(shadowDrawingManager.allTouchActionsByCmd || {}));
            this.redrawDrawingManager.allTouchActionInputsByCmd = JSON.parse(JSON.stringify(shadowDrawingManager.allTouchActionInputsByCmd || {}));
            this.redrawDrawingManager.allTouchZonesByCmd = JSON.parse(JSON.stringify(shadowDrawingManager.allTouchZonesByCmd || {}));
            this.redrawDrawingManager.allUnindexedItems = JSON.parse(JSON.stringify(shadowDrawingManager.allUnindexedItems || []));
            this.redrawDrawingManager.allIndexedItemsByNumber = JSON.parse(JSON.stringify(shadowDrawingManager.allIndexedItemsByNumber || {}));
            this.redrawDrawingManager.unindexedItems = JSON.parse(JSON.stringify(shadowDrawingManager.unindexedItems || {}));
            this.redrawDrawingManager.indexedItems = JSON.parse(JSON.stringify(shadowDrawingManager.indexedItems || {}));
            this.redrawDrawingManager.drawings = JSON.parse(JSON.stringify(shadowDrawingManager.drawings || []));
            this.redrawDrawingManager.drawingsData = JSON.parse(JSON.stringify(shadowDrawingManager.drawingsData || {}));
            this.redrawDrawingManager.savedTransforms = JSON.parse(JSON.stringify(shadowDrawingManager.savedTransforms || {}));
            this.redrawDrawingManager.drawingResponseStatus = JSON.parse(JSON.stringify(shadowDrawingManager.drawingResponseStatus || {}));

            // Copy scalar properties
            this.redrawDrawingManager.currentDrawingName = shadowDrawingManager.currentDrawingName;
            this.redrawDrawingManager.allDrawingsReceived = shadowDrawingManager.allDrawingsReceived;
            this.redrawDrawingManager.globalTransform = JSON.parse(JSON.stringify(shadowDrawingManager.globalTransform));

            // Trigger redraw with updated data
            this.performRedraw();

            // Clear the inUse flag to indicate shadow processing is complete
            shadowDrawingManager.inUse = false;

            console.log(`[REDRAW] Updated FROM processed shadow and redrawn`);
        }
    }

    // Save current data to original data holder (reuses copyToShadow)
//    saveToOriginalData() {
//        this.copyToShadow(this.originalDataManager);
//    }

    // Restore data from original data holder (reuses updateFromShadow)
//    restoreFromOriginalData() {
//        this.updateFromShadow(this.originalDataManager);
//    }

    // Create backup of current redraw data for touchAction restoration
    makeBackup() {
        console.log(`[TOUCH_ACTION] Starting backup creation, this.redrawDrawingManager exists: ${!!this.redrawDrawingManager}`);

        if (!this.redrawDrawingManager) {
            console.error(`[TOUCH_ACTION] this.redrawDrawingManager is undefined - cannot create backup!`);
            return null;
        }

        const transformBackup = JSON.parse(JSON.stringify(this.getGlobalTransform()));
        console.log(`[TOUCH_ACTION] Got transformBackup`);

        // Backup merged collections that will be restored
        const allTouchZonesByCmdBackup = JSON.parse(JSON.stringify(this.redrawDrawingManager.allTouchZonesByCmd));
        console.log(`[TOUCH_ACTION] Got allTouchZonesBackup`);
        const allUnindexedItemsBackup = JSON.parse(JSON.stringify(this.redrawDrawingManager.allUnindexedItems));
        console.log(`[TOUCH_ACTION] Got allUnindexedItemsBackup`);
        const allIndexedItemsByNumberBackup = JSON.parse(JSON.stringify(this.redrawDrawingManager.allIndexedItemsByNumber));
        console.log(`[TOUCH_ACTION] Got allIndexedItemsByNumberBackup`);
        const allTouchActionsByCmdBackup = JSON.parse(JSON.stringify(this.redrawDrawingManager.allTouchActionsByCmd));
        console.log(`[TOUCH_ACTION] Got touchActionsBackup`);
        const allTouchActionInputsByCmdBackup = JSON.parse(JSON.stringify(this.redrawDrawingManager.allTouchActionInputsByCmd));
        console.log(`[TOUCH_ACTION] Got touchActionInputsBackup`);

        const currentDrawingNameBackup = this.getCurrentDrawingName();
        console.log(`[TOUCH_ACTION] Got currentDrawingNameBackup: ${currentDrawingNameBackup}`);

        console.warn(`[TOUCH_ACTION] Creating INITIAL backup: ${Object.keys(allTouchZonesByCmdBackup).length} merged touchZones, ${allUnindexedItemsBackup.length} merged unindexed items, ${Object.keys(allIndexedItemsByNumberBackup).length} merged indexed items, ${Object.keys(allTouchActionsByCmdBackup).length} touchActions, ${Object.keys(allTouchActionInputsByCmdBackup).length} touchActionInputs, transform (${transformBackup.x}, ${transformBackup.y}, ${transformBackup.scale}), currentDrawing: ${currentDrawingNameBackup}`);

        // Return the backup object
        return {
            transform: transformBackup,
            currentDrawingName: currentDrawingNameBackup,
            allTouchZonesByCmd: allTouchZonesByCmdBackup,
            allUnindexedItems: allUnindexedItemsBackup,
            allIndexedItemsByNumber: allIndexedItemsByNumberBackup,
            allTouchActionsByCmd: allTouchActionsByCmdBackup,
            allTouchActionInputsByCmd: allTouchActionInputsByCmdBackup
        };
    }


    // Public interface for touch action redraws with pseudo response merging
    redrawForTouchAction(pseudoResponse) {
        console.log(`[REDRAW] TouchAction redraw - processing pseudo response and merging`);
        console.log(`[REDRAW] TouchAction merging pseudo response with ${pseudoResponse.items?.length || 0} items`);

        // Process the pseudo response directly on current redrawDrawingManager
        if (window.drawingViewer && window.drawingViewer.drawingDataProcessor) {
            window.drawingViewer.drawingDataProcessor.processDrawingData(pseudoResponse, this.redrawDrawingManager, null, 'touchAction');
        }

        // Use DrawingMerger to merge all drawings including the pseudo updates
        const drawingMerger = new window.DrawingMerger(this.redrawDrawingManager);
        drawingMerger.mergeAllDrawings();

        // Trigger redraw with updated data
        this.performRedraw();
    }

    // Public interface for normal redraws
//    redrawForNormal() {
//        console.log(`[REDRAW] Normal redraw - restoring original data`);

//        // Restore original data before redrawing
//        this.restoreFromOriginalData();
//    }

    // Direct redraw with working copy - used by touchActions to avoid extra processing
    redrawWithWorkingCopy(workingCopy) {
        console.log(`[REDRAW] Direct redraw with working copy - avoiding extra processing`);
        console.log(`[REDRAW] Working copy data: unindexed=${workingCopy.allUnindexedItems.length}, indexed=${Object.keys(workingCopy.allIndexedItemsByNumber).length}, touchZones=${Object.keys(workingCopy.allTouchZonesByCmd).length}`);

        // Get background color from current drawing data
        const mainDrawingName = this.getCurrentDrawingName();
        const mainDrawingData = mainDrawingName ? this.redrawDrawingManager.drawingsData[mainDrawingName] : null;
        const backgroundColor = mainDrawingData?.data?.color || 0;
        console.log(`[REDRAW] Using background color: ${backgroundColor} for drawing: ${mainDrawingName}`);

        // Call direct redraw implementation
        console.log(`[REDRAW] Calling redrawCanvasImpl with working copy data`);
        this.redrawCanvasImpl(workingCopy.allUnindexedItems, workingCopy.allIndexedItemsByNumber, workingCopy.allTouchZonesByCmd, backgroundColor);
        console.log(`[REDRAW] redrawCanvasImpl completed`);
    }

    performRedraw() {
        // Get main drawing name and background color
        const mainDrawingName = this.redrawDrawingManager.drawings.length > 0 ? this.redrawDrawingManager.drawings[0] : '';
        const mainDrawingData = mainDrawingName ? this.redrawDrawingManager.drawingsData[mainDrawingName] : null;

        console.log(`[REDRAW] performRedraw - mainDrawingName: ${mainDrawingName}`);
        console.log(`[REDRAW] performRedraw - mainDrawingData:`, mainDrawingData);
        console.log(`[REDRAW] performRedraw - drawingsData keys:`, Object.keys(this.redrawDrawingManager.drawingsData || {}));

        const backgroundColor = mainDrawingData?.data?.color || 0;
        console.log(`[REDRAW] performRedraw - backgroundColor: ${backgroundColor}`);

        this.redrawCanvasImpl(this.redrawDrawingManager.allUnindexedItems,
            this.redrawDrawingManager.allIndexedItemsByNumber, this.redrawDrawingManager.allTouchZonesByCmd, backgroundColor);
    }


        // Public interface for canvas redraw
    redrawCanvas(allUnindexedItems,allIndexedItemsByNumber,allTouchZonesByCmd,isTouchAction = false) {
      // Add stack trace for non-touchAction redraws to identify what's calling them
   //   if (!isTouchAction) {
   //     console.log(`[MERGE_REDRAW] Non-touchAction redraw called. Stack trace:`, new Error().stack);
   //   }
      
      // Only check processing state if this is NOT a touchAction
      if (!isTouchAction) {
        // Use atomic function calls for real-time state instead of stale snapshots
        const isProcessing = this.drawingViewer ? this.drawingViewer.isProcessingQueue() : false;
        const queueLength = this.drawingViewer ? this.drawingViewer.requestQueue.length : 0;
        const sentRequest = this.drawingViewer ? this.drawingViewer.sentRequest : null;
        
        // Check if mouse is down - prevent full redraws during drag operations
        // Access mouse state through the drawingViewer which has direct access
        const isMouseDown = this.drawingViewer && this.drawingViewer.touchState && this.drawingViewer.touchState.isDown;
        console.log(`[MERGE_REDRAW] DEBUG Redraw check - processing: ${isProcessing}, queue: ${queueLength}, sentRequest: ${sentRequest?.drawingName || 'none'}, mouseDown: ${isMouseDown}, drawingViewer exists: ${!!this.drawingViewer}, touchState exists: ${!!(this.drawingViewer && this.drawingViewer.touchState)}`);
        
        if (queueLength > 0 || sentRequest) {// || isProcessing || isMouseDown) { // removed V1.1.3
          console.log(`[MERGE_REDRAW] Skipping redraw - processing: ${isProcessing}, queue length: ${queueLength}, sentRequest: ${sentRequest?.drawingName || 'none'}, mouseDown: ${isMouseDown}`);
           return;
        }
      }
        // Use DrawingManager state to get the current drawing data
        const mainDrawingName = this.redrawDrawingManager.drawings.length > 0 ? this.redrawDrawingManager.drawings[0] : '';

        const currentDrawingData = this.redrawDrawingManager.drawingsData[mainDrawingName];
        if (!currentDrawingData) return;
        
        console.log(`[MERGE_REDRAW] Starting redraw for canvas: ${mainDrawingName}, size=${this.canvas.width}x${this.canvas.height} at ${new Date().toISOString()}`);
        
        // For touchAction redraws, skip merge and use existing state
        if (isTouchAction) {
          console.log(`[MERGE_REDRAW] TouchAction redraw - using existing state, skipping merge operation`);
          console.log(`[TOUCHACTION_REDRAW_DEBUG] TouchAction redraw inputs - unindexed: ${allUnindexedItems.length}, indexed keys: [${Object.keys(allIndexedItemsByNumber).join(', ')}], touchZones: [${Object.keys(allTouchZonesByCmd).join(', ')}]`);
          console.log(`[TOUCHACTION_REDRAW_DEBUG] currentDrawingData.name: ${currentDrawingData?.name}`);
          return this.redrawCanvasImpl(allUnindexedItems, allIndexedItemsByNumber, allTouchZonesByCmd, currentDrawingData.color);
        }
                
        // We'll rebuild these collections during the redraw (only for normal redraws)
        this.redrawDrawingManager.allUnindexedItems = [];
        this.redrawDrawingManager.allIndexedItemsByNumber = {}; // Key: numeric index, Value: array of items with that index

        // Mark processed drawings to avoid infinite loops
        let processedDrawings = new Set();

        console.log(`[MERGE_REDRAW] Starting to merge drawing items with unindexed and indexed items from DrawingManager`);
        
        // Clear old touchZones from previous drawing - moved here before merge operation
        this.redrawDrawingManager.allTouchZonesByCmd = {};
        
        // Set up initial transform state for the main drawing
        const initialTransform = {
            x: 0,
            y: 0,
            scale: 1.0
        };
        
        // Create the main clip region (full canvas logical size)
        const logicalCanvasWidth = currentDrawingData.data ? currentDrawingData.data.x || 50 : 50;
        const logicalCanvasHeight = currentDrawingData.data ? currentDrawingData.data.y || 50 : 50;
        const mainClipRegion = {
            x: 0,
            y: 0,
            width: logicalCanvasWidth,
            height: logicalCanvasHeight
        };
        console.log(`[MERGE_REDRAW] Created main clip region: (${mainClipRegion.x}, ${mainClipRegion.y}, ${mainClipRegion.width}, ${mainClipRegion.height})`);
        
        // Start by processing the main drawing  This will add a background rectangle
        console.log(`[MERGE_REDRAW] Processing main drawing "${mainDrawingName}" with mergeDrawingItems`);
        const mainDwg = {
                type: 'insertDwg',
                xOffset: 0,
                yOffset: 0,
                color: currentDrawingData.color,
                parentDrawingName: mainDrawingName, // itself
                drawingName: mainDrawingName,
                transform: { x: 0, y: 0, scale: 1.0 }
            };
        this.mergeDrawingItems(mainDwg, this.redrawDrawingManager.allUnindexedItems, this.redrawDrawingManager.allIndexedItemsByNumber,this.redrawDrawingManager.allTouchZonesByCmd, processedDrawings, mainClipRegion);
        
        // Update the main drawing's backup arrays with merged items (with correct transforms)
        // This ensures touchActions can find items with the correct transforms for pseudo items
        if (mainDrawingName) {
            // Update main drawing's indexed items with merged versions (correct transforms)
            if (!this.redrawDrawingManager.indexedItems[mainDrawingName]) {
                this.redrawDrawingManager.indexedItems[mainDrawingName] = {};
            }
            for (const idx in this.redrawDrawingManager.allIndexedItemsByNumber) {
                const mergedItem = this.redrawDrawingManager.allIndexedItemsByNumber[idx];
                this.redrawDrawingManager.indexedItems[mainDrawingName][idx] = {...mergedItem};
                console.log(`[MERGE_REDRAW] Updated main drawing indexed item idx=${idx} with merged transform for touchAction backup`);
            }
            
            // Update main drawing's touchZones with merged versions (correct transforms)  
            if (!this.redrawDrawingManager.touchZonesByCmd[mainDrawingName]) {
                this.redrawDrawingManager.touchZonesByCmd[mainDrawingName] = {};
            }
            for (const cmd in this.redrawDrawingManager.allTouchZonesByCmd) {
                const mergedTouchZone = this.redrawDrawingManager.allTouchZonesByCmd[cmd];
                this.redrawDrawingManager.touchZonesByCmd[mainDrawingName][cmd] = {...mergedTouchZone};
                console.log(`[MERGE_REDRAW] Updated main drawing touchZone cmd="${cmd}" with merged transform for touchAction backup`);
            }
        }
        
        // Report the merged results
        console.log(`[MERGE_REDRAW] After merging all drawings: ${this.redrawDrawingManager.allUnindexedItems.length} unindexed items, ${Object.keys(this.redrawDrawingManager.allIndexedItemsByNumber).length} different indices, ${Object.keys(this.redrawDrawingManager.allTouchZonesByCmd).length} touchZones`)
        for (let i = 0; i < this.redrawDrawingManager.allUnindexedItems.length; i++) {
            const item = this.redrawDrawingManager.allUnindexedItems[i];
            console.log(`[MERGE_REDRAW] DEBUG: Unindexed item ${i}: type=${item.type}, drawingName=${item.drawingName || 'none'}, transform=(${item.transform?.x},${item.transform?.y}), scale=${item.transform?.scale}`);
            console.log(`[MERGE_REDRAW] DEBUG: Unindexed item ${i}: `,JSON.stringify(item,null,2));
        }
        
        // Only add items to draw if specifically needed for debugging
        // We don't add test rectangles for empty drawings, as they should be allowed to be empty
  //      if (this.redrawDrawingManager.allUnindexedItems.length === 0) {
  //          console.log(`[MERGE_REDRAW] No items to draw. Canvas will remain empty.`);
  //          // The test rectangle code has been removed intentionally to allow for empty canvases
  //      }
        
        // Debug: print allIndexedItems ordered by index
        const sortedIndexes = Object.keys(this.redrawDrawingManager.allIndexedItemsByNumber).map(Number).sort((a, b) => a - b);
        if (sortedIndexes.length > 0) {
            console.log(`[MERGE_REDRAW] allIndexedItems ordered by index:`);
            sortedIndexes.forEach(index => {
                const item = this.redrawDrawingManager.allIndexedItemsByNumber[index];
                console.log(`  Index ${index}: Type: ${item.type || 'unknown'}, Drawing: ${item.drawingName || 'unknown'}`);
               console.log(`[MERGE_REDRAW] DEBUG: Indexed item: `,JSON.stringify(item,null,2));
            });
        } else {
            console.log(`[MERGE_REDRAW] No indexed items found.`);
        }
       
        if (Object.keys(this.redrawDrawingManager.allTouchZonesByCmd).length > 0) {
          for (const cmd in this.redrawDrawingManager.allTouchZonesByCmd) {
            const touchZone = this.redrawDrawingManager.allTouchZonesByCmd[cmd];
            console.log(`[MERGE_REDRAW] DEBUG: touchZone item: `,JSON.stringify(touchZone,null,2));
          }
        } else {
           console.log(`[MERGE_REDRAW] No touchZone items found.`);
        }

        // Now call redraw to handle the actual drawing
        return this.redrawCanvasImpl(this.redrawDrawingManager.allUnindexedItems, this.redrawDrawingManager.allIndexedItemsByNumber, this.redrawDrawingManager.allTouchZonesByCmd, currentDrawingData.color);
    }

    // Resize canvas to fit the container
    resizeCanvas(touchState) {
        // Get drawing data from local redraw drawing manager
        const mainDrawingName = this.redrawDrawingManager.drawings.length > 0 ? this.redrawDrawingManager.drawings[0] : '';
        const logicalDrawingData = mainDrawingName ? this.redrawDrawingManager.drawingsData[mainDrawingName] : null;

        console.log(`[RESIZE_DEBUG] resizeCanvas() called for drawing: "${mainDrawingName}"`);
        console.log(`[RESIZE_DEBUG] URL: ${window.location.href}`);

        if (!logicalDrawingData || !logicalDrawingData.data) {
            console.warn('No drawing data available for resizing');
            return;
        }

        // Check if mouse is down - skip resize operations during drag
        const isMouseDown = touchState && touchState.isDown;

        if (isMouseDown) {
            this.redrawForTouchAction();
            return;
        }

        // Get the logical canvas dimensions (1-255 range)
        const logicalWidth = Math.min(Math.max(logicalDrawingData.data.x, 1), 255);
        const logicalHeight = Math.min(Math.max(logicalDrawingData.data.y, 1), 255);

        // Get window dimensions to check if they've changed too
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        console.log(`[RESIZE_DEBUG] Current dimensions: logical=${logicalWidth}x${logicalHeight}, window=${windowWidth}x${windowHeight}`);
        console.log(`[RESIZE_DEBUG] Previous dimensions: logical=${this.lastLogicalWidth}x${this.lastLogicalHeight}, window=${this.lastWindowWidth}x${this.lastWindowHeight}`);
        console.log(`[RESIZE_DEBUG] Drawing data x=${logicalDrawingData.data.x}, y=${logicalDrawingData.data.y}`);

        // Calculate what the canvas size should be based on logical dimensions
        const aspectRatio = logicalWidth / logicalHeight;
        let displayHeight = windowHeight;
        let displayWidth = displayHeight * aspectRatio;

        // If width exceeds screen, scale down to fit width
        if (displayWidth > windowWidth) {
            displayWidth = windowWidth;
            displayHeight = displayWidth / aspectRatio;
        }

        // Account for borders and margin
        displayWidth -= 26;
        displayHeight -= 26;

        // Calculate expected canvas size
        const expectedCanvasWidth = Math.floor(displayWidth);
        const expectedCanvasHeight = Math.floor(displayHeight);

        // Check if dimensions haven't changed
        if ((this.lastLogicalWidth === logicalWidth &&
            this.lastLogicalHeight === logicalHeight &&
            this.lastWindowWidth === windowWidth &&
            this.lastWindowHeight === windowHeight &&
            this.canvas.width === expectedCanvasWidth &&
            this.canvas.height === expectedCanvasHeight) || isMouseDown) {

            console.log(`[RESIZE] Skipping resize - dimensions unchanged`);
            // Still update scale factors
            this.canvas.scaleX = this.canvas.width / logicalWidth;
            this.canvas.scaleY = this.canvas.height / logicalHeight;
//            if (!isMouseDown) {
//                this.redrawForNormal();
//            }
            return;
        }

        // Store current dimensions for future comparison
        this.lastLogicalWidth = logicalWidth;
        this.lastLogicalHeight = logicalHeight;
        this.lastWindowWidth = windowWidth;
        this.lastWindowHeight = windowHeight;

        console.log(`[RESIZE] Proceeding with resize: logical=${logicalWidth}x${logicalHeight}, canvas=${expectedCanvasWidth}x${expectedCanvasHeight}`);

        // Set canvas size
        this.canvas.width = expectedCanvasWidth;
        this.canvas.height = expectedCanvasHeight;
        this.canvas.scaleX = expectedCanvasWidth / logicalWidth;
        this.canvas.scaleY = expectedCanvasHeight / logicalHeight;

        console.log(`Canvas physical size: ${this.canvas.width}x${this.canvas.height}`);
        console.log(`Scale factors: X=${this.canvas.scaleX}, Y=${this.canvas.scaleY}`);

        // Redraw with new size
        console.log(`[RESIZE] redrawCanvas after resize`);
//        this.redrawForNormal();
    }

    // Get current state for debugging
    getState() {
        return {
            canvasSize: { width: this.canvas?.width, height: this.canvas?.height },
            hasCompletedFirstDraw: this.hasCompletedFirstDraw,
            currentDrawingName: this.getCurrentDrawingName()
        };
    }

    // Main canvas redraw implementation
    redrawCanvasImpl(allUnindexedItems, allIndexedItemsByNumber, allTouchZonesByCmd, backgroundColor = 0) {
        console.log(`[REDRAW] Starting redraw for canvas, size=${this.canvas.width}x${this.canvas.height} at ${new Date().toISOString()}`);
        console.log(`[REDRAW_DEBUG] Redraw inputs - unindexed: ${allUnindexedItems.length}, indexed keys: [${Object.keys(allIndexedItemsByNumber).join(', ')}], touchZones: [${Object.keys(allTouchZonesByCmd).join(', ')}]`);
        
        // Check if canvas size has changed or this is the first draw
        const sizeChanged = !this.hasCompletedFirstDraw || this.cachedCanvasWidth !== this.canvas.width || this.cachedCanvasHeight !== this.canvas.height;
        
        console.log(`[REDRAW] Proceeding with redraw, using passed drawing data and merged items`);
        
        // Clear canvas - use cached dimensions after first draw if size hasn't changed
        const rawBackgroundColor = backgroundColor;
        this.currentBackgroundColor = rawBackgroundColor; // Store for Black/White color mode
        const backgroundColorHex = convertColorToHex(rawBackgroundColor);
        console.log(`[REDRAW] Setting canvas background color to: ${backgroundColorHex} (from raw: ${rawBackgroundColor})`);
        this.ctx.fillStyle = backgroundColorHex;
        this.ctx.strokeStyle = backgroundColorHex;
        this.ctx.lineWidth = 2; 
        if (this.hasCompletedFirstDraw && !sizeChanged) {
            // Use cached dimensions if they exist and size hasn't changed
            //this.drawRoundedRectangle(0, 0, this.cachedCanvasWidth, this.cachedCanvasHeight, 10, true);
            console.log(`[REDRAW] Using cached dimensions: ${this.cachedCanvasWidth}x${this.cachedCanvasHeight}`);
        } else {
            // Use current canvas dimensions and update cache
            this.cachedCanvasWidth = this.canvas.width;
            this.cachedCanvasHeight = this.canvas.height;
            this.hasCompletedFirstDraw = true;
            //this.drawRoundedRectangle(0, 0, this.cachedCanvasWidth, this.cachedCanvasHeight, 10, true);
            console.log(`[REDRAW] Canvas size changed or first draw - updated cached dimensions to ${this.cachedCanvasWidth}x${this.cachedCanvasHeight}`);
        }
        this.ctx.fillRect(0, 0, this.cachedCanvasWidth, this.cachedCanvasHeight);
//        this.ctx.strokeStyle = "#FFFFFF";
//        this.drawRoundedRectangle(0, 0, this.cachedCanvasWidth, this.cachedCanvasHeight, 20, false);
//        this.ctx.strokeStyle = "#000000";
//        this.drawRoundedRectangle(2, 2, this.cachedCanvasWidth-4, this.cachedCanvasHeight-4, 20, false);
        
        this.ctx.strokeStyle = backgroundColor;

        console.log(`[REDRAW] Drawing ${allUnindexedItems.length} merged unindexed items`);
        
        // Debug: log each unindexed item
        for (let i = 0; i < allUnindexedItems.length; i++) {
            const item = allUnindexedItems[i];
            console.log(`[REDRAW] DEBUG: Unindexed item ${i}: type=${item.type}, drawingName=${item.drawingName || 'none'}, transform=(${item.transform?.x},${item.transform?.y}), scale=${item.transform?.scale}`);
        }
        
        // Handle case where no items to draw
        if (allUnindexedItems.length === 0) {
            console.log(`[REDRAW] No unindexed items to draw.`);
        }
        
        // Draw all merged unindexed items in order
        allUnindexedItems.forEach((item, index) => {
            const drawingSource = item.parentDrawingName || 'unknown';
            console.log(`[REDRAW] Drawing unindexed item ${index} of type ${item.type} from ${drawingSource} with color ${item.color}`);
            if (item.transform) {
                console.log(`[REDRAW] Item transform: x=${item.transform.x}, y=${item.transform.y}, scale=${item.transform.scale}`);
            } else {
                console.log(`[REDRAW] Item has no transform!`);
            }
            this.drawItem(item);
        });

        // Draw all indexed items in order of their indices
        const sortedIndices = Object.keys(allIndexedItemsByNumber)
            .map(idx => parseInt(idx))
            .filter(idx => !isNaN(idx))
            .sort((a, b) => a - b);

        console.log(`[REDRAW] Drawing items with ${sortedIndices.length} different indices`);
        sortedIndices.forEach(idx => {
            const itemWithIndex = allIndexedItemsByNumber[idx];
            const drawingSource = itemWithIndex.parentDrawingName || 'unknown';
            console.log(`[REDRAW] Drawing indexed item ${idx} of type ${itemWithIndex.type} from ${drawingSource}`);
            console.log(`[REDRAW_INDEXED_DEBUG] Item ${idx} full data:`, JSON.stringify(itemWithIndex, null, 2));
            if (itemWithIndex.transform) {
                console.log(`[REDRAW] Indexed item transform: x=${itemWithIndex.transform.x}, y=${itemWithIndex.transform.y}, scale=${itemWithIndex.transform.scale}`);
            } else {
                console.log(`[REDRAW] Indexed item has no transform!`);
            }
            this.drawItem(itemWithIndex);
        });

        Object.keys(allTouchZonesByCmd).forEach(cmd => {
            const touchZone = allTouchZonesByCmd[cmd];
            const drawingSource = touchZone.parentDrawingName || 'unknown';
            console.log(`[REDRAW] Drawing touchZone item ${cmd} from ${drawingSource}`);
            if (touchZone.transform) {
                console.log(`[REDRAW] TouchZone transform: x=${touchZone.transform.x}, y=${touchZone.transform.y}, scale=${touchZone.transform.scale}`);
            } else {
                console.log(`[REDRAW] TouchZone item has no transform!`);
            }
            this.drawItem(touchZone);
        });

        
        console.log(`[REDRAW] Canvas redraw completed at ${new Date().toISOString()}`);
        console.log(`[REDRAW] Final item counts: ${allUnindexedItems.length} unindexed, ${sortedIndices.length} different indices`);
    }


    // Draw a single item implementation
    drawItem(itemToDraw) {
        if (!itemToDraw || !itemToDraw.type) {
            console.error('Invalid item with missing or undefined type:', itemToDraw);
            return;
        }
        const item = {...itemToDraw};
        // protect transform
        const itemTransform = {...itemToDraw.transform};
        item.transform = itemTransform;
        const itemClipRegion = {...itemToDraw.clipRegion};
        item.clipRegion = itemClipRegion;

        try {
            console.log(`[DRAWING] Drawing item of type: ${item.type}`, JSON.stringify(item));
            
            // Check if item is visible
            if (item.visible === false) {
                console.log(`Skipping draw for invisible item of type: ${item.type}, idx: ${item.idx || 'none'}, cmd: ${item.cmd || 'none'}`);
                return;
            }
            
            // Skip items that should have been processed in pfodWeb.js
            if (item.type === 'hide' || item.type === 'unhide' || item.type == 'push' || item.type == 'pop' || item.type == 'erase') {
                console.warn(`WARNING: ${item.type} item should be processed in pfodWeb.js and not passed to drawing layer!`);
                return;
            }
            
            // Save canvas state (including clipping)
            this.ctx.save();
            
            // Apply clipping if clipRegion is provided and has valid properties
            if (item.clipRegion && typeof item.clipRegion.x === 'number' && typeof item.clipRegion.width === 'number') {
                // Use pre-calculated clip region
                console.log(`Using pre-calculated clip region: (${item.clipRegion.x}, ${item.clipRegion.y}, ${item.clipRegion.width}, ${item.clipRegion.height})`);
                
                // Convert logical coordinates to canvas pixel coordinates
                const scaledX = item.clipRegion.x * this.canvas.scaleX;
                const scaledY = item.clipRegion.y * this.canvas.scaleY;
                const scaledWidth = item.clipRegion.width * this.canvas.scaleX;
                const scaledHeight = item.clipRegion.height * this.canvas.scaleY;
                
                // Apply clipping rectangle
                this.ctx.beginPath();
                this.ctx.rect(Math.round(scaledX), Math.round(scaledY), Math.round(scaledWidth), Math.round(scaledHeight));
                this.ctx.clip();
                
                // Optionally draw the clip region for debugging
               // this.ctx.strokeStyle = 'rgba(0,255,0,0.3)'; // Use green for clip regions
               // this.ctx.strokeRect(Math.round(scaledX), Math.round(scaledY), Math.round(scaledWidth), Math.round(scaledHeight));
                
                console.log(`Applied pre-calculated clip region: (${scaledX}, ${scaledY}, ${scaledWidth}, ${scaledHeight})`);
            }
            
            // Set default color for drawing
            if (item.color === undefined) {
              item.color = -1;
            }
            const hexColor = convertColorToHex(item.color, this.currentBackgroundColor);
            this.ctx.fillStyle = hexColor;
            this.ctx.strokeStyle = hexColor;
            // Dispatch to specific drawing functions based on type
            switch (item.type.toLowerCase()) {
                case 'line':
                    this.drawLine(item);
                    break;
                case 'rectangle':
                    console.log('Drawing rectangle item with:', 
                        `xOffset: ${item.xOffset} yOffset: ${item.yOffset}`,
                        `xSize: ${item.xSize} ySize: ${item.ySize}`,
                        `centered: ${item.centered}`,
                        `style: ${item.style}`,
                        `corners: ${item.corners}`
                    );
                    this.drawRectangle(item);
                    break;
                case 'label':
                    console.log('Drawing label item with:',
                        `text: "${item.text}"`,
                        `xOffset: ${item.xOffset} yOffset: ${item.yOffset}`,
                        `xSize: ${item.xSize} ySize: ${item.ySize}`,
                        `fontSize: ${item.fontSize}`,
                        `align: ${item.align}`,
                        `bold: ${item.bold} italic: ${item.italic} underline: ${item.underline}`
                    );
                    this.drawLabel(item);
                    break;
                case 'value':
                    console.log('Drawing value item with:',
                        `text: "${item.text}"`,
                        `intValue: ${item.intValue}`,
                        `min: ${item.min} max: ${item.max}`,
                        `displayMin: ${item.displayMin} displayMax: ${item.displayMax}`,
                        `decimals: ${item.decimals} units: "${item.units}"`,
                        `xOffset: ${item.xOffset} yOffset: ${item.yOffset}`,
                        `fontSize: ${item.fontSize} align: ${item.align}`
                    );
                    this.drawValue(item);
                    break;
                case 'circle':
                    console.log('Drawing circle item with:',
                        `xOffset: ${item.xOffset} yOffset: ${item.yOffset}`,
                        `radius: ${item.radius}`,
                        `filled: ${item.filled}`
                    );
                    this.drawCircle(item);
                    break;
                case 'arc':
                    console.log('Drawing arc item with:',
                        `xOffset: ${item.xOffset} yOffset: ${item.yOffset}`,
                        `radius: ${item.radius}`,
                        `start: ${item.start}° angle: ${item.angle}°`,
                        `filled: ${item.filled}`
                    );
                    this.drawArc(item);
                    break;
                case 'touchzone':
                    console.log('Drawing touchZone item with:',
                        `cmd: ${item.cmd}`,
                        `xOffset: ${item.xOffset} yOffset: ${item.yOffset}`,
                        `xSize: ${item.xSize} ySize: ${item.ySize}`,
                        `centered: ${item.centered}`,
                        `filter: ${item.filter}`,
                        `idx: ${item.idx}`
                    );
                    this.drawTouchZone(item);
                    break;
                case 'insertdwg':
                    // Draw the inserted drawing directly as a rectangle with background color
                    console.log(`Drawing insertdwg item: ${item.drawingName}`);
                    this.drawInsertDwg(item);
                    break;
                case 'index':
                    // Index type is a placeholder that doesn't draw anything
                    console.log(`Skipping draw for index item with idx=${item.idx} - this is a placeholder that maintains transform/clipping data only`);
                    break;
                default:
                    console.error(`ERROR: Unknown item type: ${item.type} - not supported by drawing layer!`);
            }
        } catch (error) {
            console.error(`Error drawing item of type ${item.type}:`, error);
        }
        
        // Restore canvas state (also removes clipping)
        this.ctx.restore();
    }

    //========== drawInsertDwg ==========
    // Draw an insertDwg item as a background rectangle
    drawInsertDwg(item) {
        console.error('drawInsertDwg called. Should not be drawing insertDwg:', JSON.stringify(item,null,2));
/**        
        if (!item || !item.drawingName) {
            console.error('Invalid insertDwg item or missing drawingName:', item);
            return;
        }
            
        // Get the transform for positioning
        const transform = item.transform || { x: 0, y: 0, scale: 1.0 };
        
        // Get drawing dimensions and color from DrawingManager
        let drawingWidth = 50;  // Default width
        let drawingHeight = 50; // Default height
        let backgroundColor = 7; // Default light gray (silver) for missing drawings
        
        const drawingData = this.redrawDrawingManager.drawingsData[item.drawingName];
        if (drawingData && drawingData.data) {
            // Use actual drawing data
            drawingWidth = drawingData.data.x || drawingWidth;
            drawingHeight = drawingData.data.y || drawingHeight;
            backgroundColor = drawingData.data.color || backgroundColor;
            
            console.log(`[DRAWING] insertDwg Using actual drawing data: ${drawingWidth}x${drawingHeight}, color: ${backgroundColor}`);
        } else {
            console.log(`[DRAWING] insertDwg '${item.drawingName}' not loaded - skipping drawing`);
            return; // Skip drawing insertDwg if not loaded
        }
**/
        /**
        // Use the drawing bounds if available
        if (item.drawingBounds) {
            drawingWidth = item.drawingBounds.width;
            drawingHeight = item.drawingBounds.height;
            
            // CRITICAL FIX: Apply the transform scale to the drawing bounds
            if (transform && transform.scale) {
                console.log(`Applying scale ${transform.scale} to drawing bounds`);
                drawingWidth *= transform.scale;
                drawingHeight *= transform.scale;
            }
            
            console.log(`[DRAWING] Using drawing bounds from item: ${drawingWidth}x${drawingHeight}`);
        }
        **/
        /**
        console.log(`[DRAWING] Using transform for insertDwg '${item.drawingName}': (${transform.x}, ${transform.y}, ${transform.scale})`);
        
        // Create a rectangle to represent the inserted drawing's background
        const rectItem = {
            xSize: drawingWidth,
            ySize: drawingHeight,
            xOffset: 0,
            yOffset: 0,
            color: backgroundColor,
            filled: 'true',
            centered: 'false',
            transform: transform,
            drawingBounds: item.drawingBounds,
        };
        
        // Store original colors
        const originalFill = this.ctx.fillStyle;
        const originalStroke = this.ctx.strokeStyle;
        
        // Set color for the inserted drawing background
        const hexBackgroundColor = convertColorToHex(backgroundColor);
        this.ctx.fillStyle = hexBackgroundColor;
        this.ctx.strokeStyle = hexBackgroundColor;
        
        // Draw the rectangle
        console.log(`[DRAWING] Drawing insertDwg background rectangle: ${drawingWidth}x${drawingHeight} at (${transform.x}, ${transform.y}), scale: ${transform.scale}`);
            
        this.drawRectangle(rectItem);
        
        // Restore original colors
        this.ctx.fillStyle = originalFill;
        this.ctx.strokeStyle = originalStroke;
        **/
    }

    // Draw a label
    drawLabel(item) {
        console.log('[DRAWING_LABEL] Drawing label - Raw item:', JSON.stringify(item));

        // Check if label should be visible
        if (item.visible === false) {
            console.log('[DRAWING_LABEL] label not visible, skipping drawing');
            return;
        }

        const transform = item.transform || { x: 0, y: 0, scale: 1.0 };
        const xOffset = parseFloat(item.xOffset || 0);
        const yOffset = parseFloat(item.yOffset || 0);
        // Generate label text: if label has a value, combine text+FloatDecimals(value,decimals)+units
        const text = addFormattedValueToText(item.text || '', item);
        const relativeFontSize = parseInt(item.fontSize || 0);
        const fontSize = getActualFontSize(relativeFontSize);
        const bold = item.bold === 'true' || item.bold === true;
        const italic = item.italic === 'true' || item.italic === true;
        const underline = item.underline === 'true' || item.underline === true;
        const align = item.align || 'left';

        // Calculate actual position with transform
        const actualX = (xOffset * transform.scale) + transform.x;
        const actualY = (yOffset * transform.scale) + transform.y;
        const actualFontSize = fontSize * transform.scale;

        // Convert to canvas coordinates
        const canvasX = actualX * this.canvas.scaleX;
        const canvasY = actualY * this.canvas.scaleY;
        const canvasFontSize = actualFontSize * this.canvas.scaleX;

        console.log(`[DRAWING_LABEL] Drawing label at canvas coordinates (${canvasX}, ${canvasY}), fontSize: ${canvasFontSize}`);

        // Set font style
        let fontStyle = '';
        if (italic) fontStyle += 'italic ';
        if (bold) fontStyle += 'bold ';
        fontStyle += `${canvasFontSize}px Arial`;

        this.ctx.font = fontStyle;
        this.ctx.textBaseline = 'middle';

        // Set text alignment and calculate text position
        let textX = canvasX;
        
        if (align === 'right') {
            // For right alignment, the xOffset represents where the right edge should be
            this.ctx.textAlign = 'right';
            textX = canvasX; // xOffset position is where right edge will be
        } else if (align === 'center') {
            // For center alignment, the xOffset represents the center point
            this.ctx.textAlign = 'center';
            textX = canvasX; // xOffset position is where center will be
        } else {
            // For left alignment (default), the xOffset represents where the left edge should be
            this.ctx.textAlign = 'left';
            textX = canvasX; // xOffset position is where left edge will be
        }

        // Split text by newlines and draw each line separately
        const lines = text.split('\n');
        const lineHeight = canvasFontSize * 1.0; // 1.0x font size for line spacing
        
        // Calculate starting Y position for multi-line text (center the block vertically)
        const totalHeight = (lines.length - 1) * lineHeight;
        let startY = canvasY - (totalHeight / 2);
        
        lines.forEach((line, index) => {
            const lineY = startY + (index * lineHeight);
            
            // Draw the line at the calculated position
            this.ctx.fillText(line, textX, lineY);

            // Draw underline for this line if specified
            if (underline) {
                const textMetrics = this.ctx.measureText(line);
                const underlineY = lineY + canvasFontSize / 2;
                let underlineX = textX;
                let underlineWidth = textMetrics.width;

                if (align === 'center') {
                    underlineX = textX - textMetrics.width / 2;
                } else if (align === 'right') {
                    underlineX = textX - textMetrics.width;
                }

                this.ctx.beginPath();
                this.ctx.moveTo(underlineX, underlineY);
                this.ctx.lineTo(underlineX + underlineWidth, underlineY);
                this.ctx.stroke();
            }
        });

        console.log(`[DRAWING_LABEL] Label drawn: "${text}" at (${canvasX}, ${canvasY})`);
    }

    // Draw a value
    drawValue(item) {
        console.log('[DRAWING_VALUE] Drawing value - Raw item:', JSON.stringify(item));

        // Check if value should be visible
        if (item.visible === false) {
            console.log('[DRAWING_VALUE] value not visible, skipping drawing');
            return;
        }

        const transform = item.transform || { x: 0, y: 0, scale: 1.0 };
        const xOffset = parseFloat(item.xOffset || 0);
        const yOffset = parseFloat(item.yOffset || 0);
        const textPrefix = item.text || '';
        const relativeFontSize = parseInt(item.fontSize || 0);
        const fontSize = getActualFontSize(relativeFontSize);
        const bold = item.bold === 'true' || item.bold === true;
        const italic = item.italic === 'true' || item.italic === true;
        const underline = item.underline === 'true' || item.underline === true;
        const align = item.align || 'left';
        const intValue = parseFloat(item.intValue || 0);
        const max = parseFloat(item.max || 1);
        const min = parseFloat(item.min || 0);
        const displayMax = parseFloat(item.displayMax || 1.0);
        const displayMin = parseFloat(item.displayMin || 0.0);
        const decimals = (item.decimals !== undefined && item.decimals !== null) ? parseInt(item.decimals) : 2;
        const units = item.units || '';

        // Calculate scaled value using the mapping function
        let maxMin = max - min;
        if (maxMin === 0) {
            maxMin = 1;
        }
        const scaledValue = (intValue - min) * (displayMax - displayMin) / maxMin + displayMin;

        // Format the scaled value to specified decimals (supports negative decimals)
        const formattedValue = printFloatDecimals(scaledValue, decimals);

        // Create the final display text
        const displayText = textPrefix + formattedValue + units;

        console.log(`[DRAWING_VALUE] Calculated scaled value: ${intValue} -> ${scaledValue} (${formattedValue}) -> "${displayText}"`);

        // Calculate actual position with transform
        const actualX = (xOffset * transform.scale) + transform.x;
        const actualY = (yOffset * transform.scale) + transform.y;
        const actualFontSize = fontSize * transform.scale;

        // Convert to canvas coordinates
        const canvasX = actualX * this.canvas.scaleX;
        const canvasY = actualY * this.canvas.scaleY;
        const canvasFontSize = actualFontSize * this.canvas.scaleX;

        console.log(`[DRAWING_VALUE] Drawing value at canvas coordinates (${canvasX}, ${canvasY}), fontSize: ${canvasFontSize}`);

        // Set font style
        let fontStyle = '';
        if (italic) fontStyle += 'italic ';
        if (bold) fontStyle += 'bold ';
        fontStyle += `${canvasFontSize}px Arial`;

        this.ctx.font = fontStyle;
        this.ctx.textBaseline = 'middle';

        // Set text alignment and calculate text position
        let textX = canvasX;
        
        if (align === 'right') {
            // For right alignment, the xOffset represents where the right edge should be
            this.ctx.textAlign = 'right';
            textX = canvasX; // xOffset position is where right edge will be
        } else if (align === 'center') {
            // For center alignment, the xOffset represents the center point
            this.ctx.textAlign = 'center';
            textX = canvasX; // xOffset position is where center will be
        } else {
            // For left alignment (default), the xOffset represents where the left edge should be
            this.ctx.textAlign = 'left';
            textX = canvasX; // xOffset position is where left edge will be
        }

        // Split text by newlines and draw each line separately
        const lines = displayText.split('\n');
        const lineHeight = canvasFontSize * 1.0; // 1.0x font size for line spacing
        
        // Calculate starting Y position for multi-line text (center the block vertically)
        const totalHeight = (lines.length - 1) * lineHeight;
        let startY = canvasY - (totalHeight / 2);
        
        lines.forEach((line, index) => {
            const lineY = startY + (index * lineHeight);
            
            // Draw the line at the calculated position
            this.ctx.fillText(line, textX, lineY);

            // Draw underline for this line if specified
            if (underline) {
                const textMetrics = this.ctx.measureText(line);
                const underlineY = lineY + canvasFontSize / 2;
                let underlineX = textX;
                let underlineWidth = textMetrics.width;

                if (align === 'center') {
                    underlineX = textX - textMetrics.width / 2;
                } else if (align === 'right') {
                    underlineX = textX - textMetrics.width;
                }

                this.ctx.beginPath();
                this.ctx.moveTo(underlineX, underlineY);
                this.ctx.lineTo(underlineX + underlineWidth, underlineY);
                this.ctx.stroke();
            }
        });

        console.log(`[DRAWING_VALUE] Value drawn: "${displayText}" at (${canvasX}, ${canvasY})`);
    }

    // Draw a line
    drawLine(item) {
        console.log('[DRAWING_LINE] Drawing line - Raw item:', JSON.stringify(item));

        // Check if touchZone should be visible
        if (item.visible === false) {
            console.log('[DRAWING_LINE] line not visible, skipping drawing');
            return;
        }
        // default for test-modules.html use only
        const transform = item.transform ? {...item.transform} : { x: 0, y: 0, scale: 1.0 };
        const x = parseFloat(item.xSize || 0);         // Vector X component
        const y = parseFloat(item.ySize || 0);         // Vector Y component
        const xOffset = parseFloat(item.xOffset || 0); // Starting X position
        const yOffset = parseFloat(item.yOffset || 0); // Starting Y position
        
        console.log(`[DRAWING_LINE] drawLine: original coords - offset(${xOffset},${yOffset}), vector(${x},${y})`);
        console.log(`[DRAWING_LINE] drawLine: using transform - x=${transform.x}, y=${transform.y}, scale=${transform.scale}`);
        
        // Use offsets and dimensions as-is since scaling is handled in merge step
        const transformedXOffset = xOffset*transform.scale;
        const transformedYOffset = yOffset*transform.scale;
        const transformedX = x*transform.scale;
        const transformedY = y*transform.scale;
        
        console.log(`[DRAWING_LINE] drawLine: after transform scale - offset(${transformedXOffset},${transformedYOffset}), vector(${transformedX},${transformedY})`);
                                  
        // Apply the translation component of the transform
        const translatedStartX = transform.x + transformedXOffset;
        const translatedStartY = transform.y + transformedYOffset;
        const translatedEndX = translatedStartX + transformedX;
        const translatedEndY = translatedStartY + transformedY;
        
        console.log(`drawLine: after transform translation - start(${translatedStartX},${translatedStartY}), end(${translatedEndX},${translatedEndY})`);
        
        // Apply canvas scaling to get actual pixel coordinates
        const scaledStartX = translatedStartX * this.canvas.scaleX;
        const scaledStartY = translatedStartY * this.canvas.scaleY;
        const scaledEndX = translatedEndX * this.canvas.scaleX;
        const scaledEndY = translatedEndY * this.canvas.scaleY;
        console.log(`[DRAWING_LINE] drawLine: after canvas scaling - start(${scaledStartX},${scaledStartY}), end(${scaledEndX},${scaledEndY})`);
         
        // Draw the line
        this.ctx.beginPath();
      //  this.ctx.lineWidth = 2;
        
        this.ctx.moveTo(Math.round(scaledStartX), Math.round(scaledStartY));
        this.ctx.lineTo(Math.round(scaledEndX), Math.round(scaledEndY));
        
        this.ctx.stroke();
        
        console.log(`[DRAWING_LINE] Drawing line from (${translatedStartX},${translatedStartY}) to (${translatedEndX},${translatedEndY})`);
    }
    
    // draw rounded rectangel
    drawRoundedRectangle(roundedX, roundedY, roundedWidth, roundedHeight, radius, filled = false) {
      // uses preset 
      //this.ctx.fillStyle = color;
      //this.ctx.strokeStyle = color;

                 // Create rounded rectangle path
                this.ctx.beginPath();
                
                // Top edge and top-right corner
                this.ctx.moveTo(roundedX + radius, roundedY);
                this.ctx.lineTo(roundedX + roundedWidth - radius, roundedY);
                this.ctx.arc(roundedX + roundedWidth - radius, roundedY + radius, radius, Math.PI * 1.5, 0, false);
                
                // Right edge and bottom-right corner
                this.ctx.lineTo(roundedX + roundedWidth, roundedY + roundedHeight - radius);
                this.ctx.arc(roundedX + roundedWidth - radius, roundedY + roundedHeight - radius, radius, 0, Math.PI * 0.5, false);
                
                // Bottom edge and bottom-left corner
                this.ctx.lineTo(roundedX + radius, roundedY + roundedHeight);
                this.ctx.arc(roundedX + radius, roundedY + roundedHeight - radius, radius, Math.PI * 0.5, Math.PI, false);
                
                // Left edge and top-left corner
                this.ctx.lineTo(roundedX, roundedY + radius);
                this.ctx.arc(roundedX + radius, roundedY + radius, radius, Math.PI, Math.PI * 1.5, false);
                
                this.ctx.closePath();
                
                if (filled) {
                    console.log(`[DRAWING_ROUNDED_RECTANGLE] Filling rounded rectangle at (${roundedX},${roundedY}) with size ${roundedWidth}x${roundedHeight}`);
                    this.ctx.fill();
                } else {
                    console.log(`[DRAWING_ROUNDED_RECTANGLE] Stroking rounded rectangle at (${roundedX},${roundedY}) with size ${roundedWidth}x${roundedHeight}`);
                    this.ctx.stroke();
                }
     }
     
    // Draw a rectangle
    drawRectangle(item) {
        console.log('[DRAWING_RECTANGLE] Drawing rectangle - Raw item:', JSON.stringify(item));
        
        try {
            
            // Get the transform from the item (or use default if not present)
            // default for test-modules.html use only
            const transform = item.transform ? {...item.transform} : { x: 0, y: 0, scale: 1.0 };
            console.log(`[DRAWING_RECTANGLE] drawRectangle: using transform - x=${transform.x}, y=${transform.y}, scale=${transform.scale}`);
            // Check if rectanglee should be visible
            if (item.visible === false) {
                console.log('[DRAWING_RECTANGLE] rectangle not visible, skipping drawing');
                return;
            }
            
            // Default offsets to 0 if not specified
            const xOffset = parseFloat(item.xOffset || 0);
            const yOffset = parseFloat(item.yOffset || 0);
            
            // Default sizes to 1 if not specified
            let xSize = parseFloat(item.xSize);
            let ySize = parseFloat(item.ySize);
            
            // Get the centered flag
            const centered = item.centered === 'true' || item.centered === true;
            
            console.log(`[DRAWING_RECTANGLE] Rectangle original properties: xOffset=${xOffset}, yOffset=${yOffset}, xSize=${xSize}, ySize=${ySize}, centered=${centered}`);
            
            const transformedXOffset = xOffset*transform.scale;
            const transformedYOffset = yOffset*transform.scale;
            const transformedXSize = xSize*transform.scale;
            const transformedYSize = ySize*transform.scale;
            
            console.log(`[DRAWING_RECTANGLE] Rectangle dimensions  xOffset=${transformedXOffset}, yOffset=${transformedYOffset}, xSize=${transformedXSize}, ySize=${transformedYSize}`);
            
            // Calculate the starting point (top-left) and dimensions based on rectangle properties
            let startX, startY, width, height;
            
            // If centered is true, negative values result in the same drawing as positive values
            if (centered) {
                // For centered rectangles, the center point is at the transformed offset
                startX = transformedXOffset - Math.abs(transformedXSize) / 2;
                startY = transformedYOffset - Math.abs(transformedYSize) / 2;
                width = Math.abs(transformedXSize);
                height = Math.abs(transformedYSize);
                console.log(`[DRAWING_RECTANGLE] Centered rectangle: Position set to (${startX},${startY}), size set to ${width}x${height}`);
            } else {
                // For non-centered rectangles, handle negative sizes
                if (transformedXSize >= 0) {
                    startX = transformedXOffset;
                    width = transformedXSize;
                } else {
                    // Negative width - draw rectangle left from offset
                    startX = transformedXOffset + transformedXSize; // Move start point left
                    width = Math.abs(transformedXSize);
                    console.log(`[DRAWING_RECTANGLE] Negative width: Position adjusted to x=${startX}, width=${width}`);
                }
                
                if (transformedYSize >= 0) {
                    startY = transformedYOffset;
                    height = transformedYSize;
                } else {
                    // Negative height - draw rectangle up from offset
                    startY = transformedYOffset + transformedYSize; // Move start point up
                    height = Math.abs(transformedYSize);
                    console.log(`[DRAWING_RECTANGLE] Negative height: Position adjusted to y=${startY}, height=${height}`);
                }
            }
            
            // Apply the translation component of the transform
            const translatedX = transform.x + startX;
            const translatedY = transform.y + startY;
            
            console.log(`[DRAWING_RECTANGLE] Rectangle after transform translation: x=${translatedX}, y=${translatedY}, width=${width}, height=${height}`);
            
            // Use the actual rectangle coordinates for drawing
            let visibleRect = {
                x: translatedX,
                y: translatedY,
                width: width,
                height: height
            };
            
            console.log(`[DRAWING_RECTANGLE] Rectangle drawing coordinates: (${visibleRect.x}, ${visibleRect.y}, ${visibleRect.width}, ${visibleRect.height})`);
            
            // Apply canvas scaling to the visible rectangle to get actual pixel coordinates
            const scaledX = visibleRect.x * this.canvas.scaleX;
            const scaledY = visibleRect.y * this.canvas.scaleY;
            const scaledWidth = visibleRect.width * this.canvas.scaleX;
            const scaledHeight = visibleRect.height * this.canvas.scaleY;
            
            console.log(`[DRAWING_RECTANGLE] Rectangle after canvas scaling: x=${scaledX}, y=${scaledY}, width=${scaledWidth}, height=${scaledHeight}`);
            
            // Round to whole pixels for sharp edges
            const roundedX = Math.round(scaledX);
            const roundedY = Math.round(scaledY);
            
            // Ensure width and height are at least 1 pixel
            const minPixelSize = 2; // Minimum size to ensure visibility
            const roundedWidth = Math.max(Math.round(scaledWidth), minPixelSize);
            const roundedHeight = Math.max(Math.round(scaledHeight), minPixelSize);
            
            console.log(`[DRAWING_RECTANGLE] Rectangle after rounding: x=${roundedX}, y=${roundedY}, width=${roundedWidth}, height=${roundedHeight}`);
            
            // Determine drawing style
            const filled = item.filled === 'true' || item.filled === true;
            console.log(`Rectangle filled: ${filled}`);
            
            // Handle rounded corners if specified
            const rounded = item.rounded === 'true' || item.rounded === true;
            console.log(`[DRAWING_RECTANGLE] Rectangle rounded: ${rounded}`);
            
            // Draw the rectangle
            if (rounded) {
                // Draw rounded rectangle
                const radius = Math.min(roundedWidth, roundedHeight) * 0.2;
                console.log(`[DRAWING_RECTANGLE] Using corner radius: ${radius}px`);
                this.drawRoundedRectangle(roundedX, roundedY, roundedWidth, roundedHeight,radius, filled);
                
            } else {
                // Draw regular rectangle
                if (filled) {
                    console.log(`[DRAWING_RECTANGLE] Filling rectangle at (${roundedX},${roundedY}) with size ${roundedWidth}x${roundedHeight}`);
                    this.ctx.fillRect(roundedX, roundedY, roundedWidth, roundedHeight);
                } else {
                    console.log(`[DRAWING_RECTANGLE] Stroking rectangle at (${roundedX},${roundedY}) with size ${roundedWidth}x${roundedHeight}`);
                    this.ctx.strokeRect(roundedX, roundedY, roundedWidth, roundedHeight);
                }
            }
            
            console.log('[DRAWING_RECTANGLE] Rectangle drawing completed');
        } catch (error) {
            console.error('[DRAWING_RECTANGLE] Error in drawRectangle:', error);
        }
    }

    // Draw a touch zone (for debugging/visualization)
    drawTouchZone(item) {
      if (typeof DEBUG === 'undefined') {
        // assume debugging
      } else {
        if ((DEBUG === false) || (DEBUG === 'false')) {
          return;
        } // continue if not false
      }
      console.log('[DRAWING_TOUCHZONE] Drawing touchZone - Raw item:', JSON.stringify(item));
        
      const rect = this.canvas.getBoundingClientRect();
      let minTouch_mm = 9;
      let minPercent = 2/100;
      let colPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4); // half 9mm to add to both sides
      let rowPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4);
      if ((rect.width * minPercent) > colPixelsHalf9mm) {
        colPixelsHalf9mm = rect.width * minPercent;
      }
      if ((rect.height * minPercent) > rowPixelsHalf9mm) {
        rowPixelsHalf9mm = rect.height * minPercent;
      }
      console.log(`[REDRAW_TOUCHZONE]: enlarge by ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);
      console.log(`[REDRAW_TOUCHZONE] touchZone: canvas ${rect.width} x ${rect.height}`);
        
        try {
            
            // Get the transform from the item (or use default if not present)
            // default for test-modules.html use only
            const transform = item.transform ? {...item.transform} : { x: 0, y: 0, scale: 1.0 };
            console.log(`[DRAWING_TOUCHZONE] drawTouchZone: using transform - x=${transform.x}, y=${transform.y}, scale=${transform.scale}`);
            // Check if touchZone should be visible
            if (item.visible === false) {
                console.log('[DRAWING_TOUCHZONE] TouchZone not visible, skipping drawing');
                return;
            }
            
            // Default offsets to 0 if not specified
            const xOffset = parseFloat(item.xOffset || 0);
            const yOffset = parseFloat(item.yOffset || 0);
            
            // Default sizes to 1 if not specified
            let xSize = parseFloat(item.xSize || 1);
            let ySize = parseFloat(item.ySize || 1);
            
            // Get the centered flag
            const centered = item.centered === 'true' || item.centered === true;
            
            console.log(`[DRAWING_TOUCHZONE] TouchZone original properties: xOffset=${xOffset}, yOffset=${yOffset}, xSize=${xSize}, ySize=${ySize}, centered=${centered}`);
                       
            const transformedXOffset = xOffset*transform.scale;
            const transformedYOffset = yOffset*transform.scale;
            const transformedXSize = xSize*transform.scale;
            const transformedYSize = ySize*transform.scale;
            
            console.log(`[DRAWING_TOUCHZONE] TouchZone after transform scale: xOffset=${transformedXOffset}, yOffset=${transformedYOffset}, xSize=${transformedXSize}, ySize=${transformedYSize}`);
            
            // Calculate the starting point (top-left) and dimensions based on touchZone properties
            let startX, startY, width, height;
            
            // If centered is true, negative values result in the same drawing as positive values
            if (centered) {
                // For centered touchZones, the center point is at the transformed offset
                startX = transformedXOffset - Math.abs(transformedXSize) / 2;
                startY = transformedYOffset - Math.abs(transformedYSize) / 2;
                width = Math.abs(transformedXSize);
                height = Math.abs(transformedYSize);
                console.log(`[DRAWING_TOUCHZONE] Centered touchZone: Position set to (${startX},${startY}), size set to ${width}x${height}`);
            } else {
                // For non-centered touchZones, handle negative sizes
                if (transformedXSize >= 0) {
                    startX = transformedXOffset;
                    width = transformedXSize;
                } else {
                    // Negative width - draw touchZone left from offset
                    startX = transformedXOffset + transformedXSize; // Move start point left
                    width = Math.abs(transformedXSize);
                    console.log(`[DRAWING_TOUCHZONE] Negative width: Position adjusted to x=${startX}, width=${width}`);
                }
                
                if (transformedYSize >= 0) {
                    startY = transformedYOffset;
                    height = transformedYSize;
                } else {
                    // Negative height - draw touchZone up from offset
                    startY = transformedYOffset + transformedYSize; // Move start point up
                    height = Math.abs(transformedYSize);
                    console.log(`[DRAWING_TOUCHZONE] Negative height: Position adjusted to y=${startY}, height=${height}`);
                }
            }
            
            // Apply the translation component of the transform
            const translatedX = transform.x + startX;
            const translatedY = transform.y + startY;
            
            console.log(`[DRAWING_TOUCHZONE] TouchZone after transform translation: x=${translatedX}, y=${translatedY}, width=${width}, height=${height}`);
            
            // Apply canvas scaling to get actual pixel coordinates
            let scaledX = translatedX * this.canvas.scaleX;
            let scaledY = translatedY * this.canvas.scaleY;
            let scaledWidth = width * this.canvas.scaleX;
            let scaledHeight = height * this.canvas.scaleY;
            // add extra  colPixelsHalf9mm,  rowPixelsHalf9mm
            let extra_scaledX = scaledX -colPixelsHalf9mm;
            let extra_scaledY = scaledY - rowPixelsHalf9mm;
            let extra_scaledWidth = scaledWidth + 2 * colPixelsHalf9mm;
            let extra_scaledHeight = scaledHeight + 2 * rowPixelsHalf9mm;
            console.log(`[DRAWING_TOUCHZONE] TouchZone after canvas scaling: x=${scaledX}, y=${scaledY}, width=${scaledWidth}, height=${scaledHeight}`);
            
            // Round to whole pixels for sharp edges
            const roundedX = Math.round(scaledX);
            const roundedY = Math.round(scaledY);
            const minPixelSize = 2; // Minimum size to ensure visibility
            const roundedWidth = Math.max(Math.round(scaledWidth), minPixelSize);
            const roundedHeight = Math.max(Math.round(scaledHeight), minPixelSize);
            
            // Round to whole pixels for sharp edges
            const extra_roundedX = Math.round(extra_scaledX);
            const extra_roundedY = Math.round(extra_scaledY);
            const extra_roundedWidth = Math.max(Math.round(extra_scaledWidth), minPixelSize);
            const extra_roundedHeight = Math.max(Math.round(extra_scaledHeight), minPixelSize);
            
            console.log(`[DRAWING_TOUCHZONE] TouchZone after rounding: x=${roundedX}, y=${roundedY}, width=${roundedWidth}, height=${roundedHeight}`);
            
            // Store original styles
            const originalStroke = this.ctx.strokeStyle;
            const originalFill = this.ctx.fillStyle;
            const originalFont = this.ctx.font;
            const originalTextAlign = this.ctx.textAlign;
            const originalTextBaseline = this.ctx.textBaseline;
            const originalLineWidth = this.ctx.lineWidth;
            const originalLineDash = this.ctx.setLineDash;
            
            // Set touchZone-specific style
            this.ctx.strokeStyle = 'rgba(0, 128, 255, 0.7)';
          //  this.ctx.lineWidth = 2;
            
            // Draw touchZone as dashed rectangle
            this.ctx.beginPath();
            this.ctx.setLineDash([5, 3]); // 5px dash, 3px gap
            this.ctx.strokeRect(roundedX, roundedY, roundedWidth, roundedHeight);
            this.ctx.beginPath();
            const doubleLinePixels = -2; // draw line inside
            this.ctx.strokeRect(roundedX-doubleLinePixels, roundedY-doubleLinePixels, roundedWidth+2*doubleLinePixels, roundedHeight+2*doubleLinePixels);
          //  this.ctx.strokeRect(extra_roundedX, extra_roundedY, extra_roundedWidth, extra_roundedHeight);
            
            this.ctx.setLineDash([]); // Reset to solid line
//            this.ctx.beginPath();
//            this.ctx.strokeRect(roundedX, roundedY, roundedWidth, roundedHeight);
            
//            console.log(`[DRAWING_TOUCHZONE] TouchZone item `, JSON.stringify(item,null,2));
//            console.log(`[DRAWING_TOUCHZONE] TouchZone item.cmdName ${item.cmdName}`);
//            console.log(`[DRAWING_TOUCHZONE] TouchZone item.cmd ${item.cmd}`);

            // Draw command text if present
                this.ctx.fillStyle = 'rgba(0, 128, 255, 0.7)';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'top'; //'middle';
            if (item.cmdName !== undefined) {
                this.ctx.fillText(item.cmdName, roundedX + roundedWidth / 2, roundedY + 5);
            } else {
                this.ctx.fillText(item.cmd, roundedX + roundedWidth / 2, roundedY + 5);
            }  
                // Draw filter text if present
                if (item.filter !== undefined) {
                    const filterText = `f:${item.filter}`;
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    this.ctx.fillText(filterText, roundedX + 5, roundedY + 5);
                }
                
                // Draw idx text if present
                let idxText;
                if ((item.idx !== undefined) && (item.idx > 0)) {
                    if (item.idxName !== undefined) {
                      idxText = `i:${item.idxName}`;
                    } else {
                     idxText = `i:${item.idx}`;
                    }                  
                    this.ctx.font = '10px Arial';
                    this.ctx.textAlign = 'right';
                    this.ctx.textBaseline = 'top';
                    this.ctx.fillText(idxText, roundedX + roundedWidth - 5, roundedY + 5);
                }
           
            
            // Restore original styles
            this.ctx.strokeStyle = originalStroke;
            this.ctx.fillStyle = originalFill;
            this.ctx.font = originalFont;
            this.ctx.textAlign = originalTextAlign;
            this.ctx.textBaseline = originalTextBaseline;
            this.ctx.lineWidth = originalLineWidth;
            this.ctx.setLineDash = originalLineDash;


            
            console.log('[DRAWING_TOUCHZONE] TouchZone drawing completed');
        } catch (error) {
            console.error('[DRAWING_TOUCHZONE] Error in drawTouchZone:', error);
        }
    }

    // Draw a circle
    drawCircle(item) {
        console.log('[DRAWING_CIRCLE] Drawing circle - Raw item:', JSON.stringify(item));

        // Check if circle should be visible
        if (item.visible === false) {
            console.log('[DRAWING_CIRCLE] Circle not visible, skipping drawing');
            return;
        }

        try {
            const transform = item.transform || { x: 0, y: 0, scale: 1.0 };
            const xOffset = parseFloat(item.xOffset || 0);
            const yOffset = parseFloat(item.yOffset || 0);
            const radius = parseFloat(item.radius || 1);
            const filled = item.filled === 'true' || item.filled === true;

            console.log(`[DRAWING_CIRCLE] Circle properties: xOffset=${xOffset}, yOffset=${yOffset}, radius=${radius}, filled=${filled}`);

            // Apply transform to position and radius
            const transformedX = (xOffset * transform.scale) + transform.x;
            const transformedY = (yOffset * transform.scale) + transform.y;
            const transformedRadius = radius * transform.scale;

            console.log(`[DRAWING_CIRCLE] Circle after transform: center=(${transformedX}, ${transformedY}), radius=${transformedRadius}`);

            // Apply canvas scaling
            const canvasX = transformedX * this.canvas.scaleX;
            const canvasY = transformedY * this.canvas.scaleY;
            const canvasRadius = transformedRadius * this.canvas.scaleX;

            console.log(`[DRAWING_CIRCLE] Circle after canvas scaling: center=(${canvasX}, ${canvasY}), radius=${canvasRadius}`);

            // Draw the circle
            this.ctx.beginPath();
            this.ctx.arc(canvasX, canvasY, canvasRadius, 0, 2 * Math.PI);

            if (filled) {
                console.log(`[DRAWING_CIRCLE] Filling circle at (${canvasX}, ${canvasY}) with radius ${canvasRadius}`);
                this.ctx.fill();
            } else {
                console.log(`[DRAWING_CIRCLE] Stroking circle at (${canvasX}, ${canvasY}) with radius ${canvasRadius}`);
                this.ctx.stroke();
            }

            console.log('[DRAWING_CIRCLE] Circle drawing completed');
        } catch (error) {
            console.error('[DRAWING_CIRCLE] Error in drawCircle:', error);
        }
    }

    // Draw an arc
    drawArc(item) {
        console.log('[DRAWING_ARC] Drawing arc - Raw item:', JSON.stringify(item));

        // Check if arc should be visible
        if (item.visible === false) {
            console.log('[DRAWING_ARC] Arc not visible, skipping drawing');
            return;
        }

        try {
            const transform = item.transform || { x: 0, y: 0, scale: 1.0 };
            const xOffset = parseFloat(item.xOffset || 0);
            const yOffset = parseFloat(item.yOffset || 0);
            const radius = parseFloat(item.radius || 1);
            const filled = item.filled === 'true' || item.filled === true;
            const startDegrees = -parseFloat(item.start || 0); // angles go anti-clockwise
            const angleDegrees = parseFloat(item.angle || 90);

            console.log(`[DRAWING_ARC] Arc properties: xOffset=${xOffset}, yOffset=${yOffset}, radius=${radius}, filled=${filled}, start=${startDegrees}°, angle=${angleDegrees}°`);

            // Convert degrees to radians
            // Note: Canvas uses radians where 0 is 3 o'clock, positive is clockwise
            // The specification says +ve is anti-clockwise, -ve is clockwise
            // So we need to negate the angles to match the specification
            const startRadians = (startDegrees * Math.PI) / 180;
            const endRadians = startRadians - ((angleDegrees * Math.PI) / 180);
            const anticlockwise = angleDegrees < 0; // +ve angle = anti-clockwise in specification

            console.log(`[DRAWING_ARC] Arc angles: start=${startRadians}rad, end=${endRadians}rad, anticlockwise=${anticlockwise}`);

            // Apply transform to position and radius
            const transformedX = (xOffset * transform.scale) + transform.x;
            const transformedY = (yOffset * transform.scale) + transform.y;
            const transformedRadius = radius * transform.scale;

            console.log(`[DRAWING_ARC] Arc after transform: center=(${transformedX}, ${transformedY}), radius=${transformedRadius}`);

            // Apply canvas scaling
            const canvasX = transformedX * this.canvas.scaleX;
            const canvasY = transformedY * this.canvas.scaleY;
            const canvasRadius = transformedRadius * this.canvas.scaleX;

            console.log(`[DRAWING_ARC] Arc after canvas scaling: center=(${canvasX}, ${canvasY}), radius=${canvasRadius}`);

            // Draw the arc
            this.ctx.beginPath();
                // For filled arcs, draw from center to create a pie slice
            this.ctx.moveTo(canvasX, canvasY);
            this.ctx.arc(canvasX, canvasY, canvasRadius, startRadians, endRadians, !anticlockwise);
            this.ctx.closePath();
            if (filled) {
                console.log(`[DRAWING_ARC] Filling arc pie slice at (${canvasX}, ${canvasY}) with radius ${canvasRadius}`);
                this.ctx.fill();
            }
            this.ctx.stroke();
            console.log('[DRAWING_ARC] Arc drawing completed');
        } catch (error) {
            console.error('[DRAWING_ARC] Error in drawArc:', error);
        }
    }
}

// Export as global for browser compatibility
window.Redraw = Redraw;


/* ========================================
 * Inlined from: drawingMerger.js
 * ======================================== */
/*
   drawingMerger.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// DrawingMerger class - Handles merging of drawing data from multiple sources
// Separated from redraw functionality for clean architecture
class DrawingMerger {
    constructor(drawingManager) {
        this.drawingManager = drawingManager;
    }

    // Main method to merge all drawing items into collections for rendering
    mergeAllDrawings() {
        // Get main drawing data
        const mainDrawingName = this.drawingManager.drawings.length > 0 ? this.drawingManager.drawings[0] : '';
        if (!mainDrawingName) return null;

        const currentDrawingData = this.drawingManager.drawingsData[mainDrawingName];
        if (!currentDrawingData) return null;

        console.log(`[DRAWING_MERGER] Starting merge for main drawing: ${mainDrawingName}`);

        // Initialize collections
        this.drawingManager.allUnindexedItems = [];
        this.drawingManager.allIndexedItemsByNumber = {};
        this.drawingManager.allTouchZonesByCmd = {};

        // Mark processed drawings to avoid infinite loops
        let processedDrawings = new Set();

        // Set up initial transform and clip region for main drawing
        const initialTransform = { x: 0, y: 0, scale: 1.0 };
        const mainClipRegion = null; // Main drawing has no clipping by default

        // Create main drawing insertDwg item for processing
        const mainDwg = {
            type: 'insertDwg',
            xOffset: 0,
            yOffset: 0,
            color: currentDrawingData.color,
            parentDrawingName: mainDrawingName,
            drawingName: mainDrawingName,
            transform: { x: 0, y: 0, scale: 1.0 }
        };

        // Merge all drawing items
        this.mergeDrawingItems(mainDwg, this.drawingManager.allUnindexedItems,
            this.drawingManager.allIndexedItemsByNumber, this.drawingManager.allTouchZonesByCmd,
            processedDrawings, mainClipRegion);

        console.log(`[DRAWING_MERGER] Merge complete: ${this.drawingManager.allUnindexedItems.length} unindexed items, ${Object.keys(this.drawingManager.allIndexedItemsByNumber).length} different indices, ${Object.keys(this.drawingManager.allTouchZonesByCmd).length} touchZones`);

        return currentDrawingData;
    }
    
    getDrawingResponseStatus(drawingName) {
        return this.drawingManager.drawingResponseStatus[drawingName] || false;
    }

        // Calculate clipping region for a drawing
    calculateItemClipRegion(transform, drawingWidth, drawingHeight, parentClipRegion) {
      /**
        const x = transform.x;
        const y = transform.y;
        const scale = transform.scale;
        const width = drawingWidth * scale;
        const height = drawingHeight * scale;

        let clipRegion = { x, y, width, height };

        // Apply parent clipping if it exists
        if (parentClipRegion) {
            clipRegion.x = Math.max(clipRegion.x, parentClipRegion.x);
            clipRegion.y = Math.max(clipRegion.y, parentClipRegion.y);
            clipRegion.width = Math.min(clipRegion.width, parentClipRegion.width);
            clipRegion.height = Math.min(clipRegion.height, parentClipRegion.height);
        }

        return clipRegion;
        **/
        return parentClipRegion; // do not limit insertDwgs
    }

    /**
    transform calculations
    each items has a base offset and a scale and a clip region
    when the item is drawn, first the item's offset x scale is added to the base to the the position
    then the size is scaled by scale and the item drawn
    insertDwg's offset are different they do not change the position of the the background rectangle
    rather they move the insertDwg's items up and to left by offset * scale (for +ve offsets)
    clip regions are only updated when insertDwg processed
    
    the insertDwg arg contains the current transformation offset and scale
    the insertDwg xOffset,yOffset move the dwg items up and left by offset * scale (for +ve offsets)
    scale insertDwg by ratio of cols i.e. a 20xh inserted in a 40xhh will be scaled down by 2 i.e. x 20/40
    **/
    // Merge drawing items from a specific drawing with transforms and clipping
    // dwgTransform is the parent transform and scaling for this deg
    mergeDrawingItems(insertDwg, allUnindexedItems, allIndexedItemsByNumber, allTouchZonesByCmd, processedDrawings, parentClipRegion = null) {
       // console.log(`[MERGE_DWG] Using parent transform: (${parentTransform.x}, ${parentTransform.y}, ${parentTransform.scale}) for drawing "${drawingName}"`);
        // parent transform is base offset + scale
        // all added item first have their offset scaled by scale and then base offset added
        
        let drawingName = insertDwg.drawingName;
        console.warn(`[MERGE_DWG] Merging Drawing "${drawingName}".`);
        console.log(`[MERGE_DWG] Beginning merge process for drawing "${drawingName}" ${JSON.stringify(insertDwg)}`);        
        // Get drawing data for dimensions and color
        const drawingData = this.drawingManager.drawingsData[drawingName];
        if (!drawingData || !drawingData.data) {
            console.log(`[DRAWING_MERGER] Drawing "${drawingName}" data not available.`);
            return;
        }
        let clipRegion = parentClipRegion;
        if (parentClipRegion) {
            console.log(`[DRAWING_MERGER] Using parent clip region: (${parentClipRegion.x}, ${parentClipRegion.y}, width:${parentClipRegion.width}, height:${parentClipRegion.height})`);
        } else {
            console.log(`[DRAWING_MERGER] No parent clip region provided, using drawing bounds for clipping`);
            clipRegion = {
            x: 0,
            y: 0,
            width: drawingData.data.x,
            height: drawingData.data.y
          };
        }
        parentClipRegion = clipRegion;
        // Get drawing dimensions and properties
        const drawingWidth = drawingData.data.x || 50;
        const drawingHeight = drawingData.data.y || 50;
        const backgroundColor = drawingData.data.color || 'white';
        
        console.log(`[DRAWING_MERGER] Drawing "${drawingName}" has dimensions ${drawingWidth}x${drawingHeight}, color: ${backgroundColor}`);
   
   
        
        // Calculate parent transform for this drawing
        const parentTransform = insertDwg.transform || { x: 0, y: 0, scale: 1.0 };

        // Get drawing items
        const drawingUnindexedItems = this.drawingManager.unindexedItems[drawingName] || [];
        const drawingIndexedItems = this.drawingManager.indexedItems[drawingName] || {};
        const touchZoneItems = this.drawingManager.touchZonesByCmd[drawingName] || {};
        const touchActionItems = this.drawingManager.touchActionsByCmd[drawingName] || {};

        console.log(`[DRAWING_MERGER] Processing ${drawingUnindexedItems.length} unindexed items, ${Object.keys(drawingIndexedItems).length} indexed items, ${Object.keys(touchZoneItems).length} touchZones from "${drawingName}"`);


        // Handle case where drawing has no items
        if (drawingUnindexedItems.length === 0 && Object.keys(drawingIndexedItems).length === 0) {
            console.log(`[DRAWING_MERGER] Drawing "${drawingName}" has no items, but will still be drawn as a rectangle with background color.`);
            if (Object.keys(touchZoneItems).length !== 0) {
                console.log(`[DRAWING_MERGER] Drawing "${drawingName}" has touchZones which will be drawn in debug mode.`);
            }    
        }
        
        
        let dwgTransform = {...insertDwg.transform}; // the current parent transform
        // adjust the scale by the ratio of the dwg.x to clip.width clip is the main dwg clip
        dwgTransform.scale = dwgTransform.scale * drawingWidth/parentClipRegion.width;
        
        console.log(`[SCALE_MERGE_DWG]  insertDwg transform: ${JSON.stringify(dwgTransform)}`);
        
        console.log(`[DRAWING_MERGER] For drawing: Raw dimensions: ${drawingWidth}x${drawingHeight}`);
        //console.log(`[MERGE_DWG] For drawing: Clip with scale: (${dwgTransform.x}, ${dwgTransform.y}, scale=${dwgTransform.scale})`);
        // Calculate the clip region for the nested drawing using our common function
        const dwgClipRegion = this.calculateItemClipRegion(dwgTransform, drawingWidth, drawingHeight, parentClipRegion);                   
        console.log(`[DRAWING_MERGER] Calculated nested drawing clip region: (${dwgClipRegion.x}, ${dwgClipRegion.y}, width:${dwgClipRegion.width}, height:${dwgClipRegion.height})`);
        
        // apply insertDwg offset move
        // update nestedTransform for  dwg offset to move dwg up and left need to include scale
         const dwg_xOffset = parseFloat(insertDwg.xOffset || 0);
         const dwg_yOffset = parseFloat(insertDwg.yOffset || 0);

        dwgTransform.x += (-dwg_xOffset) * dwgTransform.scale;
        dwgTransform.y += (-dwg_yOffset) * dwgTransform.scale;
        console.log(`[DRAWING_MERGER] Using item transform for nested drawing items: (${dwgTransform.x}, ${dwgTransform.y}, ${dwgTransform.scale})`);

        // Process touchZones
        for (const cmd in touchZoneItems) {
            const touchZone = touchZoneItems[cmd];
            const processedItem = {...touchZone};
            processedItem.clipRegion = dwgClipRegion;
            // build combined transform
           const itemTransform = {...processedItem.transform};
           itemTransform.x = itemTransform.x * dwgTransform.scale + dwgTransform.x;
           itemTransform.y = itemTransform.y * dwgTransform.scale + dwgTransform.y;
           itemTransform.scale = itemTransform.scale *  dwgTransform.scale;
           processedItem.transform = itemTransform;
           // Handle touchZone
           console.log(`[DRAWING_MERGER] Found touchzone item for drawing "${drawingName}" at offsets (${touchZone.xOffset || 0}, ${touchZone.yOffset || 0})`);
           const touchZoneCmd = touchZone.cmd || '';
           if (touchZoneCmd.trim().length == 0) {
             console.warn(`[DRAWING_MERGER] Error empty touchzone cmd in drawing "${drawingName}" ${JSON.stringify(processedItem)}`);
           } else {
             if (!allTouchZonesByCmd[touchZoneCmd]) {
             } else {
                const currentItem = allTouchZonesByCmd[touchZoneCmd];
                if (currentItem.parentDrawingName !== processedItem.parentDrawingName) {
                    console.warn(`[DRAWING_MERGER] Error: Updating existing touchZone with cmd ${touchZoneCmd} in "${processedItem.parentDrawingName}" with item from different drawing, "${currentItem.parentDrawingName}"`);
                }
                // save current transform
                processedItem.transform = {...currentItem.transform}; // keep new data but change transform and clipRegion
                processedItem.clipRegion = {...currentItem.clipRegion};
                console.log(`[DRAWING_MERGERG_UPDATE] Update existing touchZone with cmd ${touchZoneCmd} to ${JSON.stringify(processedItem)}`);
            }
            console.warn(`[DRAWING_MERGER] Added touchZone to allTouchZonesByCmd  ${JSON.stringify(processedItem)}`);
            allTouchZonesByCmd[touchZoneCmd] = processedItem;
           }
        }
        
        // Process touchActions - merge them into global collection
        for (const cmd in touchActionItems) {
            const touchActions = touchActionItems[cmd];
            if (touchActions && touchActions.length > 0) {
                console.log(`[DRAWING_MERGER] Found ${touchActions.length} touchActions for cmd="${cmd}" in drawing "${drawingName}"`);
                
                // Initialize global collection if needed
                if (!this.drawingManager.allTouchActionsByCmd) {
                    this.drawingManager.allTouchActionsByCmd = {};
                }
                
                // Add to global merged collection (overwrites any existing with same cmd)
                this.drawingManager.allTouchActionsByCmd[cmd] = [...touchActions];
                console.log(`[DRAWING_MERGER] Added ${touchActions.length} touchActions for cmd="${cmd}" to global merged collection`);
            }
        }

        // Process touchActionInputs - merge them into global collection
        const touchActionInputItems = this.drawingManager.touchActionInputsByCmd[drawingName] || {};
        for (const cmd in touchActionInputItems) {
            const touchActionInput = touchActionInputItems[cmd];
            if (touchActionInput) {
                console.log(`[DRAWING_MERGER] Found touchActionInput for cmd="${cmd}" in drawing "${drawingName}"`);
                
                // Initialize global collection if needed
                if (!this.drawingManager.allTouchActionInputsByCmd) {
                    this.drawingManager.allTouchActionInputsByCmd = {};
                }
                
                // Add to global merged collection (overwrites any existing with same cmd)
                this.drawingManager.allTouchActionInputsByCmd[cmd] = { ...touchActionInput };
                console.log(`[DRAWING_MERGER] Added touchActionInput for cmd="${cmd}" to global merged collection`);
            }
        }

        // Process unindexed items
        // Process unindexed items
        for (let i = 0; i < drawingUnindexedItems.length; i++) {
            const item = drawingUnindexedItems[i];
            // insertDwg does not process offset like rectangle
            item.clipRegion = dwgClipRegion;
            
            console.log(`[MERGE_DWG] Processing unindexed item ${i} of type '${item.type}' in drawing "${drawingName}"`);
            console.warn(`[MERGE_DWG] item: ${JSON.stringify(item)}`);
            //console.log(`[SCALE_MERGE_DWG]  parent transform: (${parentTransform.x}, ${parentTransform.y}, ${parentTransform.scale})`);
            
            if (item.type && item.type === 'insertDwg') {
                // Check if insertDwg should be visible
                if (item.visible === false) {
                    console.log(`[MERGE_DWG] Skipping hidden insertDwg for drawing "${item.drawingName}"`);
                    continue;
                }
                
                // Handle nested insertDwg
                const nestedDrawingName = item.drawingName;
                console.log(`[MERGE_DWG] Found nested insertDwg item for drawing "${nestedDrawingName}" at offsets (${item.xOffset || 0}, ${item.yOffset || 0})`);
                
                // Check if we have received a response for this drawing
                const hasResponse = this.getDrawingResponseStatus(nestedDrawingName);
                if (!hasResponse) {
                    console.warn(`[MERGE_DWG] No response received for drawing "${nestedDrawingName}" - skipping this insertDwg`);
                    continue;
                }
                
                // Create a processed item for the insertDwg itself and add it to the unindexed items
                const processedInsertDwgItem = {...item}; 
                processedInsertDwgItem.clipRegion = dwgClipRegion;

                // Store the parent transform directly with the item for reliable clipping                
              //  const itemTransform = {...parentTransform};
              //  processedInsertDwgItem.transform = itemTransform;
                
                // Add drawing bounds for clipping - use defaults if data not available
                const nestedDrawingData = this.drawingManager.drawingsData[nestedDrawingName];
                let drawingWidth = 50;  // Default width
                let drawingHeight = 50; // Default height
                
                if (nestedDrawingData && nestedDrawingData.data) {
                    drawingWidth = nestedDrawingData.data.x || drawingWidth;
                    drawingHeight = nestedDrawingData.data.y || drawingHeight;
                
                    processedInsertDwgItem.drawingBounds = {
                       width: drawingWidth,
                      height: drawingHeight
                    };
                } else {
                    console.warn(`[MERGE_DWG] insertDwg '${nestedDrawingName}' does not have sizes. Skipping`);
                    continue;
                }
                                
                // Add the nested insertDwg item to the list
               // allUnindexedItems.push(processedInsertDwgItem);
               // console.log(`[MERGE_DWG] Added nested insertDwg item for "${nestedDrawingName}" to unindexed items list`);
                
                // Process the nested drawing recursively if not already processed
                if (nestedDrawingName && !processedDrawings.has(nestedDrawingName)) {
                    processedDrawings.add(nestedDrawingName);                                                           
                    // Process the nested drawing with the intersection clip region
                    this.mergeDrawingItems(item, allUnindexedItems, allIndexedItemsByNumber, allTouchZonesByCmd, processedDrawings, dwgClipRegion);
                } else if (nestedDrawingName) {
                    console.log(`[MERGE_DWG] Drawing "${nestedDrawingName}" already processed, skipping content processing`);
                }
            } else {
                // Regular drawing item
                const processedItem = {...item};
                processedItem.clipRegion = dwgClipRegion;
                // build combined transform 
                // NOTE: default value only needed for test-modules.html, real display already has transform set
                const itemTransform = {...(processedItem.transform || { x: 0, y: 0, scale: 1 })};
                itemTransform.x = itemTransform.x * dwgTransform.scale + dwgTransform.x;
                itemTransform.y = itemTransform.y * dwgTransform.scale + dwgTransform.y;
                itemTransform.scale = itemTransform.scale *  dwgTransform.scale;
                processedItem.transform = itemTransform;
                console.warn(`[MERGE_DWG] Added unindexed Item  ${JSON.stringify(processedItem)}`);
                allUnindexedItems.push(processedItem);
            }
        }
        

        // Process indexed items
        for (const idx in drawingIndexedItems) {
            const item = drawingIndexedItems[idx];

            console.log(`[MERGE_DWG] Processing indexed item idx=${idx}, type='${item.type}' in drawing "${drawingName}"`);
            const processedItem = {...item};
            processedItem.clipRegion = dwgClipRegion;
            const itemTransform = {...processedItem.transform};
            itemTransform.x = itemTransform.x * dwgTransform.scale + dwgTransform.x;
            itemTransform.y = itemTransform.y * dwgTransform.scale + dwgTransform.y;
            itemTransform.scale = itemTransform.scale *  dwgTransform.scale;
            processedItem.transform = itemTransform;
            
           // Add to indexed items collection replacing existing 
           const numericIdx = parseInt(idx);
               // check for overwrite of another dwg
               // this check fails on update from touchAction in insertDwg so skip it
           if (!allIndexedItemsByNumber[numericIdx]) {
                //allIndexedItemsByNumber[numericIdx] = processedItem;
            } else {
               const currentItem = allIndexedItemsByNumber[numericIdx];
//               console.log(`[MERGE_DWG] Updating existing item with index ${numericIdx} in "${processedItem.drawingName}" with at ${JSON.stringify(processedItem)}`);
//               if (currentItem.parentDrawingName !== processedItem.parentDrawingName) {
//                 console.warn(`[MERGE_DWG] Error: Updating existing item with index ${numericIdx} in "${processedItem.parentDrawingName}" with item from different drawing, "${currentItem.parentDrawingName}"`);
//               }
               // save current transform
               processedItem.transform = {...currentItem.transform}; // keep new data but change transform and clipRegion
               processedItem.clipRegion = {...currentItem.clipRegion};
               processedItem.visible = {...currentItem.visible}; // keep current visible setting
               console.log(`[MERGE_DWG_UPDATE] Update existing item with index ${numericIdx} to ${JSON.stringify(processedItem)}`);
            }    
            console.warn(`[MERGE_DWG] Added indexed Item  ${JSON.stringify(processedItem)}`);
            allIndexedItemsByNumber[numericIdx] = processedItem;
        }
        
        console.log(`[MERGE_DWG] Completed merging items from "${drawingName}" at ${new Date().toISOString()}`);
        console.log(`[MERGE_DWG] Current status: ${allUnindexedItems.length} unindexed items, ${Object.keys(allIndexedItemsByNumber).length} different indices, ${Object.keys(allTouchZonesByCmd).length} touchZones `);
    }

}

// Export as global for browser compatibility
window.DrawingMerger = DrawingMerger;


/* ========================================
 * Inlined from: webTranslator.js
 * ======================================== */
/*   
   webTranslator.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

 /**
   from Android App these can be 'c' or 'r'
     public void updateColRows(int colPixel, int rowPixel) { // , int rc, int rr) {
        colOffset = setFromVar(colOffset, colOffsetVar, colPixel, rowPixel);// , rc, rr);
        rowOffset = setFromVar(rowOffset, rowOffsetVar, colPixel, rowPixel);// , rc, rr);
        vWidth = setFromVar(vWidth, vWidthVar, colPixel, rowPixel);// , rc, rr);
        vHeight = setFromVar(vHeight, vHeightVar, colPixel, rowPixel);// , rc, rr);
        value = (int) setFromVar((float) value, vValueVar, colPixel, rowPixel);// , rc, rr);
        // sortRect(); // resort after setting
    }
**/

// JS_VERSION is available globally via window.JS_VERSION from pfodWebDebug.js

function translateRawRectangle(rawRectString,isTouchAction=false) {
    // Parse rectangle type from prefix
    let rectType = '';
    let content = '';
    
    if (rawRectString.startsWith('|RRc')) {
        rectType = 'RRc';
        content = rawRectString.substring(4);
    } else if (rawRectString.startsWith('|RR')) {
        rectType = 'RR';
        content = rawRectString.substring(3);
    } else if (rawRectString.startsWith('|Rc')) {
        rectType = 'Rc';
        content = rawRectString.substring(3);
    } else if (rawRectString.startsWith('|R')) {
        rectType = 'R';
        content = rawRectString.substring(2);
    } else if (rawRectString.startsWith('|rrc')) {
        rectType = 'rrc';
        content = rawRectString.substring(4);
    } else if (rawRectString.startsWith('|rr')) {
        rectType = 'rr';
        content = rawRectString.substring(3);
    } else if (rawRectString.startsWith('|rc')) {
        rectType = 'rc';
        content = rawRectString.substring(3);
    } else if (rawRectString.startsWith('|r')) {
        rectType = 'r';
        content = rawRectString.substring(2);
    } else {
        throw new Error('Invalid rectangle format: must start with |r, |rc, |rr, |rrc, |R, |Rc, |RR, or |RRc');
    }
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Parse parts: [colour]~width~height[~colOffset[~rowOffset]]
    const colour = parts[0] === '' ? undefined : parseInt(parts[0]);
    let xSize = 1;
    let ySize = 1;
    // Handle isTouchAction transformations and invalid inputs
    if (parts.length > 1 && parts[1] !== '') {
        if (isTouchAction && parts[1] === 'c') {
            xSize = 'COL';
        } else if (isTouchAction && parts[1] === 'r') {
            xSize = 'ROW';
        } else if (!isNaN(parseFloat(parts[1]))) {
            xSize = parseFloat(parts[1]);
        } else {
            xSize = 1;
        }
    }
    
    if (parts.length > 2 && parts[2] !== '') {
        if (isTouchAction && parts[2] === 'c') {
            ySize = 'COL';
        } else if (isTouchAction && parts[2] === 'r') {
            ySize = 'ROW';
        } else if (!isNaN(parseFloat(parts[2]))) {
            ySize = parseFloat(parts[2]);
        } else {
            ySize = 1;
        }
    }
    
    
    let xOffset = 0;
    let yOffset = 0;
    
    // Handle isTouchAction transformations and invalid inputs
    if (parts.length > 3 && parts[3] !== '') {
        if (isTouchAction && parts[3] === 'c') {
            xOffset = 'COL';
        } else if (isTouchAction && parts[3] === 'r') {
            xOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[3]))) {
            xOffset = parseFloat(parts[3]);
        } else {
            xOffset = 0;
        }
    }
    
    if (parts.length > 4 && parts[4] !== '') {
        if (isTouchAction && parts[4] === 'c') {
            yOffset = 'COL';
        } else if (isTouchAction && parts[4] === 'r') {
            yOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[4]))) {
            yOffset = parseFloat(parts[4]);
        } else {
            yOffset = 0;
        }
    }
    
    // Create rectangle object
    const rectObject = {
        type: "rectangle",
        idx: idx
    };
    
    // Add colour if specified
    if (colour !== undefined && !isNaN(colour)) {
        rectObject.color = colour;
    } else {
      rectObject.color = -1;
    }
    
    // Add dimensions
    rectObject.xSize = xSize;
    rectObject.ySize = ySize;
    
    // Add offsets
    rectObject.xOffset = xOffset;
    rectObject.yOffset = yOffset;
    
    // Add rectangle properties based on type
    if (rectType.includes('R') || rectType.includes('r')) {
        if (rectType.includes('R')) {
            rectObject.filled = "true";
        }
        if (rectType.includes('c')) {
            rectObject.centered = "true";
        }
        if (rectType.includes('r') && !rectType.includes('R')) {
            // lowercase r in rr or rrc means rounded
            if (rectType.includes('rr')) {
                rectObject.rounded = "true";
            }
        } else if (rectType.includes('R')) {
            // uppercase R with additional r means rounded
            if (rectType.includes('RR')) {
                rectObject.rounded = "true";
            }
        }
    }
    
    return rectObject;
}

  
function translateRawLine(rawLineString,isTouchAction=false) {
    // Check if this is a line item
    if (!rawLineString.startsWith('|l')) {
        throw new Error('Invalid line format: must start with |l');
    }
    
    // Remove the |l prefix
    const content = rawLineString.substring(2);
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Parse parts: [colour]~colDelta~rowDelta[~colOffset[~rowOffset]]
    const colour = parts[0] === '' ? undefined : parseInt(parts[0]);
    const xSize = parseFloat(parts[1]); // colDelta
    const ySize = parseFloat(parts[2]); // rowDelta
    
    let xOffset = 0;
    let yOffset = 0;
    
    // Handle isTouchAction transformations and invalid inputs
    if (parts.length > 3 && parts[3] !== '') {
        if (isTouchAction && parts[3] === 'c') {
            xOffset = 'COL';
        } else if (isTouchAction && parts[3] === 'r') {
            xOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[3]))) {
            xOffset = parseFloat(parts[3]);
        } else {
            xOffset = 0;
        }
    }
    
    if (parts.length > 4 && parts[4] !== '') {
        if (isTouchAction && parts[4] === 'c') {
            yOffset = 'COL';
        } else if (isTouchAction && parts[4] === 'r') {
            yOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[4]))) {
            yOffset = parseFloat(parts[4]);
        } else {
            yOffset = 0;
        }
    }
    
    // Create line object
    const lineObject = {
        type: "line",
        idx: idx
    };
    
    // Add colour if specified
    if (colour !== undefined && !isNaN(colour)) {
        lineObject.color = colour;
     } else {
      lineObject.color = -1;
     }
    
    // Add coordinates
    lineObject.xSize = xSize;
    lineObject.ySize = ySize;
    
    // Add offsets
    lineObject.xOffset = xOffset;
    lineObject.yOffset = yOffset;
    
    return lineObject;
}

function translateRawCircle(rawCircleString,isTouchAction=false) {
    // Parse circle type from prefix
    let circleType = '';
    let content = '';
    
    if (rawCircleString.startsWith('|C')) {
        circleType = 'C';
        content = rawCircleString.substring(2);
    } else if (rawCircleString.startsWith('|c')) {
        circleType = 'c';
        content = rawCircleString.substring(2);
    } else {
        throw new Error('Invalid circle format: must start with |c or |C');
    }
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Parse parts: [colour]~dRadius[~colOffset[~rowOffset]]
    const colour = parts[0] === '' ? undefined : parseInt(parts[0]);
    const radius = parseFloat(parts[1]); // dRadius
    
    let xOffset = 0;
    let yOffset = 0;
    
    // Handle isTouchAction transformations and invalid inputs
    if (parts.length > 2 && parts[2] !== '') {
        if (isTouchAction && parts[2] === 'c') {
            xOffset = 'COL';
        } else if (isTouchAction && parts[2] === 'r') {
            xOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[2]))) {
            xOffset = parseFloat(parts[2]);
        } else {
            xOffset = 0;
        }
    }
    
    if (parts.length > 3 && parts[3] !== '') {
        if (isTouchAction && parts[3] === 'c') {
            yOffset = 'COL';
        } else if (isTouchAction && parts[3] === 'r') {
            yOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[3]))) {
            yOffset = parseFloat(parts[3]);
        } else {
            yOffset = 0;
        }
    }
    
    // Create circle object
    const circleObject = {
        type: "circle",
        idx: idx
    };
    
    // Add colour if specified
    if (colour !== undefined && !isNaN(colour)) {
        circleObject.color = colour;
     } else {
      circleObject.color = -1;
    }
    
    // Add offsets
    circleObject.xOffset = xOffset;
    circleObject.yOffset = yOffset;
    
    // Add radius
    circleObject.radius = radius;
    
    // Add filled property if it's a filled circle
    if (circleType === 'C') {
        circleObject.filled = "true";
    }
    
    return circleObject;
}

function translateRawArc(rawArcString,isTouchAction=false) {
    // Parse arc type from prefix
    let arcType = '';
    let content = '';
    
    if (rawArcString.startsWith('|A')) {
        arcType = 'A';
        content = rawArcString.substring(2);
    } else if (rawArcString.startsWith('|a')) {
        arcType = 'a';
        content = rawArcString.substring(2);
    } else {
        throw new Error('Invalid arc format: must start with |a or |A');
    }
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Parse parts: [colour]~dArcAngle~dStartAngle~dRadius[~colOffset[~rowOffset]]
    const colour = parts[0] === '' ? undefined : parseInt(parts[0]);
    const angle = parseFloat(parts[1]); // dArcAngle
    const start = parseFloat(parts[2]); // dStartAngle
    const radius = parseFloat(parts[3]); // dRadius
    
    let xOffset = 0;
    let yOffset = 0;
    
    // Handle isTouchAction transformations and invalid inputs
    if (parts.length > 4 && parts[4] !== '') {
        if (isTouchAction && parts[4] === 'c') {
            xOffset = 'COL';
        } else if (isTouchAction && parts[4] === 'r') {
            xOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[4]))) {
            xOffset = parseFloat(parts[4]);
        } else {
            xOffset = 0;
        }
    }
    
    if (parts.length > 5 && parts[5] !== '') {
        if (isTouchAction && parts[5] === 'c') {
            yOffset = 'COL';
        } else if (isTouchAction && parts[5] === 'r') {
            yOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[5]))) {
            yOffset = parseFloat(parts[5]);
        } else {
            yOffset = 0;
        }
    }
    
    // Create arc object
    const arcObject = {
        type: "arc",
        idx: idx
    };
    
    // Add colour if specified
    if (colour !== undefined && !isNaN(colour)) {
        arcObject.color = colour;
     } else {
      arcObject.color = -1;
    }
    
    // Add offsets
    arcObject.xOffset = xOffset;
    arcObject.yOffset = yOffset;
    
    // Add arc properties
    arcObject.radius = radius;
    arcObject.start = start;
    arcObject.angle = angle;
    
    // Add filled property if it's a filled arc
    if (arcType === 'A') {
        arcObject.filled = "true";
    }
    
    return arcObject;
}

function translateRawText(rawTextString,isTouchAction=false) {
    // Check if this is a text item
    if (!rawTextString.startsWith('|t')) {
        throw new Error('Invalid text format: must start with |t');
    }
    
    // Remove the |t prefix
    const content = rawTextString.substring(2);
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Parse parts: [colour]~text[~colOffset[~rowOffset[~alignment]]]
    const colour = parts[0] === '' ? undefined : parseInt(parts[0]);
    const rawText = parts[1]; // text with HTML tags
    
    let xOffset = 0;
    let yOffset = 0;
    
    // Handle isTouchAction transformations and invalid inputs
    if (parts.length > 2 && parts[2] !== '') {
        if (isTouchAction && parts[2] === 'c') {
            xOffset = 'COL';
        } else if (isTouchAction && parts[2] === 'r') {
            xOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[2]))) {
            xOffset = parseFloat(parts[2]);
        } else {
            xOffset = 0;
        }
    }
    
    if (parts.length > 3 && parts[3] !== '') {
        if (isTouchAction && parts[3] === 'c') {
            yOffset = 'COL';
        } else if (isTouchAction && parts[3] === 'r') {
            yOffset = 'ROW';
        } else if (!isNaN(parseFloat(parts[3]))) {
            yOffset = parseFloat(parts[3]);
        } else {
            yOffset = 0;
        }
    }
    
    const alignment = parts.length > 4 && parts[4] !== '' ? parts[4] : 'center';
    
    // Parse HTML-style formatting tags from text
    function parseTextFormatting(text) {
        const result = {
            text: text,
            bold: false,
            italic: false,
            underline: false,
            fontSize: undefined
        };
        
        // Check for bold tags
        if (text.includes('<b>')) {
            result.bold = true;
            result.text = result.text.replace(/<b>/g, '').replace(/<\\b>/g, '');
        }
        
        // Check for italic tags
        if (text.includes('<i>')) {
            result.italic = true;
            result.text = result.text.replace(/<i>/g, '').replace(/<\\i>/g, '');
        }
        
        // Check for underline tags
        if (text.includes('<u>')) {
            result.underline = true;
            result.text = result.text.replace(/<u>/g, '').replace(/<\\u>/g, '');
        }
        
        // Check for fontSize tags (e.g., <+3> or <-2>)
        const fontSizeMatch = text.match(/<([+-]\d+)>/);
        if (fontSizeMatch) {
            result.fontSize = parseInt(fontSizeMatch[1]);
            result.text = result.text.replace(/<[+-]\d+>/g, '').replace(/<\\[+-]\d+>/g, '');
        }
        
        return result;
    }
    
    const textInfo = parseTextFormatting(rawText);
    
    // Create text object
    const textObject = {
        type: "label",
        idx: idx
    };
    
    // Add colour if specified
    if (colour !== undefined && !isNaN(colour)) {
        textObject.color = colour;
     } else {
      textObject.color = -1;
    }
    
    // Add offsets
    textObject.xOffset = xOffset;
    textObject.yOffset = yOffset;
    
    // Add text content
    textObject.text = textInfo.text;
    
    // Add formatting properties if they exist
    if (textInfo.fontSize !== undefined) {
        textObject.fontSize = textInfo.fontSize;
    }
    if (textInfo.bold) {
        textObject.bold = "true";
    }
    if (textInfo.italic) {
        textObject.italic = "true";
    }
    if (textInfo.underline) {
        textObject.underline = "true";
    }
    
    // Add alignment if specified
    if (alignment) {
        const alignMap = { 'L': 'left', 'C': 'center', 'R': 'right' };
        textObject.align = alignMap[alignment] || 'center';
    }
    
    return textObject;
}

function translateRawValue(rawValueString,isTouchAction=false) {
    // Check if this is a value item
    if (!rawValueString.startsWith('|v')) {
        throw new Error('Invalid value format: must start with |v');
    }
    
    // Remove the |v prefix
    const content = rawValueString.substring(2);
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Rejoin parts and split by backtick to handle the ` separators properly
    const rejoined = parts.join('~');
    const backTickParts = rejoined.split('`');
    
    // Parse initial parts: [colour]~text~colOffset~rowOffset
    const initialParts = backTickParts[0].split('~');
    const colour = initialParts[0] === '' ? undefined : parseInt(initialParts[0]);
    const rawText = initialParts[1]; // text with HTML tags
    
    let xOffset = 0; // colOffset - required for values
    let yOffset = 0; // rowOffset - required for values
    
    // Handle isTouchAction transformations and invalid inputs for xOffset
    if (initialParts[2] !== undefined) {
        if (isTouchAction && initialParts[2] === 'c') {
            xOffset = 'COL';
        } else if (isTouchAction && initialParts[2] === 'r') {
            xOffset = 'ROW';
        } else if (!isNaN(parseFloat(initialParts[2]))) {
            xOffset = parseFloat(initialParts[2]);
        } else {
            xOffset = 0;
        }
    }
    
    // Handle isTouchAction transformations and invalid inputs for yOffset
    if (initialParts[3] !== undefined) {
        if (isTouchAction && initialParts[3] === 'c') {
            yOffset = 'COL';
        } else if (isTouchAction && initialParts[3] === 'r') {
            yOffset = 'ROW';
        } else if (!isNaN(parseFloat(initialParts[3]))) {
            yOffset = parseFloat(initialParts[3]);
        } else {
            yOffset = 0;
        }
    }
    
    // Parse value and units: value~units
    const valueAndUnits = backTickParts[1].split('~');

    let intValue = 0;
    if (valueAndUnits[0] !== undefined) {
        if (isTouchAction && valueAndUnits[0] === 'c') {
            intValue = 'COL';
        } else if (isTouchAction && valueAndUnits[0] === 'r') {
            intValue = 'ROW';
        } else if (!isNaN(parseFloat(valueAndUnits[0]))) {
            intValue = parseFloat(valueAndUnits[0]);
        } else {
            intValue = 0;
        }
    }
    
    const units = valueAndUnits[1];
    
    // Parse min value
    const minValue = parseInt(backTickParts[2]);
    
    // Parse max and display range: max~displaymin~displaymax
    const maxAndDisplay = backTickParts[3].split('~');
    const maxValue = parseInt(maxAndDisplay[0]);
    const displayMin = parseFloat(maxAndDisplay[1]);
    const displayMax = parseFloat(maxAndDisplay[2]);
    
    // Parse decimals and optional alignment: decimals~alignment
    const decimalsAndAlign = backTickParts[4].split('~');
    const decimals = parseInt(decimalsAndAlign[0]);
    const alignment = decimalsAndAlign.length > 1 ? decimalsAndAlign[1] : 'center';
    
    // Parse HTML-style formatting tags from text (reuse from translateRawText)
    function parseTextFormatting(text) {
        const result = {
            text: text,
            bold: false,
            italic: false,
            underline: false,
            fontSize: undefined
        };
        
        // Check for bold tags
        if (text.includes('<b>')) {
            result.bold = true;
            result.text = result.text.replace(/<b>/g, '').replace(/<\\b>/g, '');
        }
        
        // Check for italic tags
        if (text.includes('<i>')) {
            result.italic = true;
            result.text = result.text.replace(/<i>/g, '').replace(/<\\i>/g, '');
        }
        
        // Check for underline tags
        if (text.includes('<u>')) {
            result.underline = true;
            result.text = result.text.replace(/<u>/g, '').replace(/<\\u>/g, '');
        }
        
        // Check for fontSize tags (e.g., <+3> or <-2>)
        const fontSizeMatch = text.match(/<([+-]\d+)>/);
        if (fontSizeMatch) {
            result.fontSize = parseInt(fontSizeMatch[1]);
            result.text = result.text.replace(/<[+-]\d+>/g, '').replace(/<\\[+-]\d+>/g, '');
        }
        
        return result;
    }
    
    const textInfo = parseTextFormatting(rawText);
    
    // Create value object
    const valueObject = {
        type: "value",
        idx: idx
    };
    
    // Add colour if specified
    if (colour !== undefined && !isNaN(colour)) {
        valueObject.color = colour;
     } else {
      valueObject.color = -1;
    }
    
    // Add offsets
    valueObject.xOffset = xOffset;
    valueObject.yOffset = yOffset;
    
    // Add text content
    valueObject.text = textInfo.text;
    
    // Add formatting properties if they exist
    if (textInfo.fontSize !== undefined) {
        valueObject.fontSize = textInfo.fontSize;
    }
    if (textInfo.bold) {
        valueObject.bold = "true";
    }
    if (textInfo.italic) {
        valueObject.italic = "true";
    }
    if (textInfo.underline) {
        valueObject.underline = "true";
    }
    
    // Add value-specific properties
    valueObject.intValue = intValue;
    valueObject.min = minValue;
    valueObject.max = maxValue;
    valueObject.displayMin = displayMin;
    valueObject.displayMax = displayMax;
    valueObject.decimals = decimals;
    valueObject.units = units;
    
    // Add alignment if specified
    if (alignment) {
        const alignMap = { 'L': 'left', 'C': 'center', 'R': 'right' };
        valueObject.align = alignMap[alignment] || 'center';
    }
    
    return valueObject;
}

function translateRawHide(rawHideString) {
    // Check if this is a hide item
    if (!rawHideString.startsWith('|h')) {
        throw new Error('Invalid hide format: must start with |h');
    }
    
    // Remove the |h prefix
    const content = rawHideString.substring(2);
    
    // Create hide object
    const hideObject = {
        type: "hide"
    };
    
    // Check if idx is specified (starts with `) or cmd is specified (starts with ~)
    if (content.startsWith('`')) {
        // Extract idx
        const idx = parseInt(content.substring(1));
        hideObject.idx = idx;
    } else if (content.startsWith('~')) {
        // Extract cmd
        const cmd = content.substring(1);
        hideObject.cmd = cmd;
    } else {
        throw new Error('Invalid hide format: must specify either `idx or ~cmd');
    }
    
    return hideObject;
}

function translateRawUnhide(rawUnhideString) {
    // Check if this is an unhide item
    if (!rawUnhideString.startsWith('|uh')) {
        throw new Error('Invalid unhide format: must start with |uh');
    }
    
    // Remove the |uh prefix
    const content = rawUnhideString.substring(3);
    
    // Create unhide object
    const unhideObject = {
        type: "unhide"
    };
    
    // Check if idx is specified (starts with `) or cmd is specified (starts with ~)
    if (content.startsWith('`')) {
        // Extract idx
        const idx = parseInt(content.substring(1));
        unhideObject.idx = idx;
    } else if (content.startsWith('~')) {
        // Extract cmd
        const cmd = content.substring(1);
        unhideObject.cmd = cmd;
    } else {
        throw new Error('Invalid unhide format: must specify either `idx or ~cmd');
    }
    
    return unhideObject;
}

function translateRawErase(rawEraseString) {
    // Check if this is an erase item
    if (!rawEraseString.startsWith('|e')) {
        throw new Error('Invalid erase format: must start with |e');
    }
    
    // Remove the |e prefix
    const content = rawEraseString.substring(2);
    
    // Create erase object
    const eraseObject = {
        type: "erase"
    };
    
    // Check if idx is specified (starts with `) or cmd is specified (starts with ~)
    if (content.startsWith('`')) {
        // Extract idx
        const idx = parseInt(content.substring(1));
        eraseObject.idx = idx;
    } else if (content.startsWith('~')) {
        // Extract cmd
        const cmd = content.substring(1);
        eraseObject.cmd = cmd;
    } else {
        throw new Error('Invalid erase format: must specify either `idx or ~cmd');
    }
    
    return eraseObject;
}

function translateRawHideDwg(rawHideString) {
    // Check if this is a hide item
    if (!rawHideString.startsWith('|hd')) {
        throw new Error('Invalid hide dwg format: must start with |hd');
    }
    
    // Remove the |h prefix
    const content = rawHideString.substring(3);
    
    // Create hide object
    const hideObject = {
        type: "hide"
    };
    
    // Check if  cmd is specified (starts with ~)
    if (content.startsWith('~')) {
        // Extract cmd
        const cmd = content.substring(1);
        hideObject.cmd = cmd;
        hideObject.drawingName = cmd;
    } else {
        throw new Error('Invalid hide dwg format: must specify ~loadCmd');
    }
    
    return hideObject;
}

function translateRawUnhideDwg(rawUnhideString) {
    // Check if this is an unhide item
    if (!rawUnhideString.startsWith('|uhd')) {
        throw new Error('Invalid unhide dwg format: must start with |uhd');
    }
    
    // Remove the |uh prefix
    const content = rawUnhideString.substring(4);
    
    // Create unhide object
    const unhideObject = {
        type: "unhide"
    };
    
    // Check if cmd is specified (starts with ~)
    if (content.startsWith('~')) {
        // Extract cmd
        const cmd = content.substring(1);
        unhideObject.cmd = cmd;
        unhideObject.drawingName = cmd;
    } else {
        throw new Error('Invalid unhide dwg format: must specify ~loadCmd');
    }
    
    return unhideObject;
}

function translateRawEraseDwg(rawEraseString) {
    // Check if this is an erase item
    if (!rawEraseString.startsWith('|ed')) {
        throw new Error('Invalid erase dwg format: must start with |ed');
    }
    
    // Remove the |e prefix
    const content = rawEraseString.substring(3);
    
    // Create erase object
    const eraseObject = {
        type: "erase"
    };
    
    // Check if cmd is specified (starts with ~)
    if (content.startsWith('~')) {
        // Extract cmd
        const cmd = content.substring(1);
        eraseObject.cmd = cmd;
        eraseObject.drawingName = cmd;
    } else {
        throw new Error('Invalid erase format: must specify ~loadCmd');
    }
    
    return eraseObject;
}


function translateRawZero(rawZeroString) {
    // Check if this is a zero item
    if (!rawZeroString.startsWith('|z')) {
        throw new Error('Invalid zero format: must start with |z');
    }
    
    // Remove the |z prefix
    const content = rawZeroString.substring(2);
    
    // Check if this is a pop (no content) or push (has content)
    if (content === '') {
        // This is a pop operation
        return {
            type: "popZero"
        };
    } else {
        // This is a push operation - parse the parameters
        // Format: ~ col ~ row ~ scaling
        let x = 0;
        let y = 0;
        let scale = 1.0;
        
        if (content.startsWith('~')) {
           //throw new Error('Invalid pushZero format: must start with ~ after |z'); 
          // Split by ~ and remove empty first element
          const parts = content.split('~').slice(1);
          if (parts.length >= 1) { 
            x = parseFloat(parts[0]); // col
          }
          if (parts.length >= 2) { 
            y = parseFloat(parts[1]); // row
          }
          if (parts.length >= 3) { 
            scale = parseFloat(parts[2]); // scaling
          }
          if (parts.length > 3) {
            throw new Error('Invalid pushZero format: must have no more then 3 parameters (col, row, scaling)');
          }
        }
        return {
            type: "pushZero",
            x: x,
            y: y,
            scale: scale
        };
    }
}


function translateRawIndex(rawIndexString) {
    // Check if this is an index item
    if (!rawIndexString.startsWith('|i')) {
        throw new Error('Invalid index format: must start with |i');
    }
    
    // Remove the |i prefix
    const content = rawIndexString.substring(2);
    
    // Create index object
    const indexObject = {
        type: "index"
    };
    
    // Check if idx is specified (must start with `)
    if (content.startsWith('`')) {
        // Extract idx
        const idx = parseInt(content.substring(1));
        indexObject.idx = idx;
    } else {
        throw new Error('Invalid index format: must specify `idx');
    }
    
    return indexObject;
}

function translateRawTouchZone(rawTouchZoneString) {
    // Parse touchZone type from prefix
    let touchZoneType = '';
    let content = '';
    
    if (rawTouchZoneString.startsWith('|xc')) {
        touchZoneType = 'xc';
        content = rawTouchZoneString.substring(3);
    } else if (rawTouchZoneString.startsWith('|x')) {
        touchZoneType = 'x';
        content = rawTouchZoneString.substring(2);
    } else {
        throw new Error('Invalid touchZone format: must start with |x or |xc');
    }
    
    let idx = 0; // default value
    let parts;
    
    // Check if idx is specified (starts with `)
    if (content.startsWith('`')) {
        // Extract idx and split remaining by ~
        const idxEnd = content.indexOf('~');
        idx = parseInt(content.substring(1, idxEnd));
        parts = content.substring(idxEnd + 1).split('~');
    } else {
        // No idx, split all by ~ and drop leading empty string
        parts = content.split('~');
        if (parts[0] === '') {
            parts = parts.slice(1);
        }
    }
    
    // Handle the case where filter is specified with backtick
    // Format: cmd ~ width ~ height [ ~ colOffset [ ~ rowOffset ]] [`filter]
    let filterPart = '';
    const lastPart = parts[parts.length - 1];
    if (lastPart && lastPart.includes('`')) {
        // Extract filter from last part
        const backTickIndex = lastPart.indexOf('`');
        filterPart = lastPart.substring(backTickIndex + 1);
        parts[parts.length - 1] = lastPart.substring(0, backTickIndex);
    }
    
    // Parse parts: cmd~width~height[~colOffset[~rowOffset]]
    const cmd = parts[0]; // cmd
    const xSize = parseFloat(parts[1]); // width
    const ySize = parseFloat(parts[2]); // height
    const xOffset = parts.length > 3 && parts[3] !== '' ? parseFloat(parts[3]) : undefined;
    const yOffset = parts.length > 4 && parts[4] !== '' ? parseFloat(parts[4]) : undefined;
    
    // Create touchZone object
    const touchZoneObject = {
        type: "touchZone",
        xSize: xSize,
        ySize: ySize,
        cmd: cmd,
        idx: idx
    };
    
    // Add offsets if they exist
    if (xOffset !== undefined) {
        touchZoneObject.xOffset = xOffset;
    }
    if (yOffset !== undefined) {
        touchZoneObject.yOffset = yOffset;
    }
    
    // Add filter if specified
    if (filterPart !== '') {
        touchZoneObject.filter = parseInt(filterPart);
    }
    
    // Add centered property if it's a centered touchZone
    if (touchZoneType === 'xc') {
        touchZoneObject.centered = "true";
    }
    
    return touchZoneObject;
}

function translateRawInsertDwg(rawInsertDwgString) {
    // Check if this is an insertDwg item
    if (!rawInsertDwgString.startsWith('|d')) {
        throw new Error('Invalid insertDwg format: must start with |d');
    }
    
    // Remove the |d prefix
    const content = rawInsertDwgString.substring(2);
    
    // InsertDwg format: |d ~ loadcmd ~ ~ colOffset ~ rowOffset
    // Note: there's an empty field between loadcmd and colOffset
    if (!content.startsWith('~')) {
        throw new Error('Invalid insertDwg format: must start with ~ after |d');
    }
    
    // Split by ~ and remove empty first element
    const parts = content.split('~').slice(1);
    
    if (parts.length !== 4) {
        throw new Error('Invalid insertDwg format: must have exactly 4 parameters (loadcmd, empty, colOffset, rowOffset)');
    }
    
    // Parse parts: loadcmd ~ ~ colOffset ~ rowOffset
    const drawingName = parts[0]; // loadcmd (drawing name)
    // parts[1] is empty (intentional gap in format)
    const xOffset = parts[2] === '' ? 0 : parseFloat(parts[2]); // colOffset
    const yOffset = parts[3] === '' ? 0 : parseFloat(parts[3]); // rowOffset
    
    // Create insertDwg object
    const insertDwgObject = {
        type: "insertDwg",
        drawingName: drawingName,
        cmd: drawingName,
        cmdName: drawingName,
        xOffset: xOffset,
        yOffset: yOffset
    };
    
    return insertDwgObject;
}

function translateRawTouchActionInput(rawTouchActionInputString) {
    // Check if this is a touchActionInput item
    if (!rawTouchActionInputString.startsWith('|XI')) {
        throw new Error('Invalid touchActionInput format: must start with |XI');
    }
    
    // Remove the |XI prefix
    const content = rawTouchActionInputString.substring(3);
    
    // TouchActionInput format: |XI ~ cmd ~ prompt [`idxOfTextItem]
    if (!content.startsWith('~')) {
        throw new Error('Invalid touchActionInput format: must start with ~ after |XI');
    }
    
    // Split by ~ to get cmd and prompt, then handle backtick separation for textIdx
    const parts = content.split('~').slice(1); // Remove empty first element
    
    if (parts.length < 2) {
        throw new Error('Invalid touchActionInput format: must have at least cmd and prompt');
    }
    
    const cmd = parts[0];
    const promptWithIdx = parts[1]; // This may contain `textIdx at the end
    
    // Check if textIdx is specified (contains `)
    let prompt = promptWithIdx;
    let textIdx = undefined;
    
    if (promptWithIdx.includes('`')) {
        const backTickIndex = promptWithIdx.lastIndexOf('`');
        prompt = promptWithIdx.substring(0, backTickIndex);
        textIdx = parseInt(promptWithIdx.substring(backTickIndex + 1));
    }
    
    // Parse HTML-style formatting tags from prompt
    function parsePromptFormatting(text) {
        const result = {
            text: text,
            bold: false,
            italic: false,
            underline: false,
            fontSize: undefined,
            color: -1,
            backgroundColor: 0
        };
        
        // Check for bold tags
        if (text.includes('<b>')) {
            result.bold = true;
            result.text = result.text.replace(/<b>/g, '').replace(/<\\b>/g, '');
        }
        
        // Check for italic tags
        if (text.includes('<i>')) {
            result.italic = true;
            result.text = result.text.replace(/<i>/g, '').replace(/<\\i>/g, '');
        }
        
        // Check for underline tags
        if (text.includes('<u>')) {
            result.underline = true;
            result.text = result.text.replace(/<u>/g, '').replace(/<\\u>/g, '');
        }
        
        // Check for fontSize tags (e.g., <+3> or <-2>)
        const fontSizeMatch = text.match(/<([+-]\d+)>/);
        if (fontSizeMatch) {
            result.fontSize = parseInt(fontSizeMatch[1]);
            result.text = result.text.replace(/<[+-]\d+>/g, '').replace(/<\\[+-]\d+>/g, '');
        }
        
        // Check for color tags (e.g., <5> - note: no + sign)
        const colorMatch = text.match(/<(\d+)>/);
        if (colorMatch) {
            result.color = parseInt(colorMatch[1]);
            result.text = result.text.replace(/<\d+>/g, '').replace(/<\\\d+>/g, '');
        }
        
        // Check for background color tags (e.g., <bg 0>)
        const bgColorMatch = text.match(/<bg\s+(\d+)>/);
        if (bgColorMatch) {
            result.backgroundColor = parseInt(bgColorMatch[1]);
            result.text = result.text.replace(/<bg\s+\d+>/g, '').replace(/<\\bg\s+\d+>/g, '');
        }
        
        return result;
    }
    
    const promptInfo = parsePromptFormatting(prompt);
    
    // Create touchActionInput object
    const touchActionInputObject = {
        type: "touchActionInput",
        cmd: cmd,
        prompt: promptInfo.text
    };
    
    // Add textIdx if specified
    if (textIdx !== undefined) {
        touchActionInputObject.textIdx = textIdx;
    }
    
    // Add formatting properties if they exist
    if (promptInfo.fontSize !== undefined) {
        touchActionInputObject.fontSize = promptInfo.fontSize;
    }
    if (promptInfo.color !== undefined) {
        touchActionInputObject.color = promptInfo.color;
    }
    if (promptInfo.backgroundColor !== undefined) {
        touchActionInputObject.backgroundColor = promptInfo.backgroundColor;
    }
    
    return touchActionInputObject;
}

function translateRawTouchAction(rawTouchActionString) {
    // Check if this is a touchAction item
    if (!rawTouchActionString.startsWith('|X')) {
        throw new Error('Invalid touchAction format: must start with |X');
    }
    
    // Remove the |X prefix
    const content = rawTouchActionString.substring(2);
    
    // TouchAction format: |X ~ cmd ~ DrawingPrimitive
    if (!content.startsWith('~')) {
        throw new Error('Invalid touchAction format: must start with ~ after |X');
    }
    
    // Split by ~ and get cmd and the rest
    const firstTildeIndex = content.indexOf('~');
    const secondTildeIndex = content.indexOf('~', firstTildeIndex + 1);
    
    if (secondTildeIndex === -1) {
        throw new Error('Invalid touchAction format: must have cmd and primitive');
    }
    
    const cmd = content.substring(1, secondTildeIndex); // Extract cmd between first ~ and second ~
    const primitiveRaw = '|' + content.substring(secondTildeIndex + 1); // Reconstruct primitive with | prefix
    
    // Use existing translators to parse the drawing primitive
    let drawingPrimitive;
    
    try {
        // Remove the idx from the primitive if it exists, since touchAction primitives don't use idx
        let cleanPrimitiveRaw = primitiveRaw;        
        drawingPrimitive = translateRawItem(cleanPrimitiveRaw,true); // true if touchAction else default false
                
    } catch (error) {
        throw new Error(`Failed to parse touchAction primitive: ${error.message}`);
    }
    
    // Create touchAction object
    const touchActionObject = {
        type: "touchAction",
        cmd: cmd,
        action: [drawingPrimitive]
    };
    
    return touchActionObject;
}

function translateRawItem(rawItemString, isTouchAction = false) {
    // Determine the item type and call appropriate function
    if (rawItemString.startsWith('|l')) {
        return translateRawLine(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|r') || rawItemString.startsWith('|R')) {
        return translateRawRectangle(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|c') || rawItemString.startsWith('|C')) {
        return translateRawCircle(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|a') || rawItemString.startsWith('|A')) {
        return translateRawArc(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|t')) {
        return translateRawText(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|v')) {
        return translateRawValue(rawItemString,isTouchAction);
// check these first        
    } else if (rawItemString.startsWith('|uhd')) {
        return translateRawUnhideDwg(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|hd')) {
        return translateRawHideDwg(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|ed')) {
        return translateRawEraseDwg(rawItemString);
// then check these        
    } else if (rawItemString.startsWith('|uh')) {
        return translateRawUnhide(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|h')) {
        return translateRawHide(rawItemString,isTouchAction);
    } else if (rawItemString.startsWith('|e')) {
        return translateRawErase(rawItemString);

        
    } else if (rawItemString.startsWith('|z')) {
        return translateRawZero(rawItemString);
    } else if (rawItemString.startsWith('|xc') || rawItemString.startsWith('|x')) {
        return translateRawTouchZone(rawItemString);
    } else if (rawItemString.startsWith('|i')) {
        return translateRawIndex(rawItemString);
    } else if (rawItemString.startsWith('|d')) {
        return translateRawInsertDwg(rawItemString);
    } else if (rawItemString.startsWith('|XI')) {
        return translateRawTouchActionInput(rawItemString);
    } else if (rawItemString.startsWith('|X')) {
        return translateRawTouchAction(rawItemString);
    } else {
        throw new Error('Unknown item type: must start with |l (line), |r/|R (rectangle), |c/|C (circle), |a/|A (arc), |t (text), |v (value), |h (hide), |uh (unhide), |z (push/pop), |x/|xc (touchZone), |e (erase), |i (index), |d (insertDwg), |XI (touchActionInput), or |X (touchAction)');
    }
}


function translateMenuResponse(cmd) {
  let msgType = cmd.shift();
  if (!(msgType.startsWith("{,") || msgType.startsWith("{;"))) {
      console.error(`Error translating menu response : "${msgType}"`);
      const result = {
         error: 'msgType_invalid',
         message: `Expected mainMenu start or update but received "${msgType}"`,
         pfodDrawing: 'error'
       };
      return result;
  }
  if (cmd.length == 0) {
      console.error(`Error translating menu response : "${msgType}"`);
      const result = {
         error: 'msg_invalid',
         message: `Expected main items but only found menu start "${msgType}"`,
         pfodDrawing: 'error'
       };
      return result;
   }
   let menuItem = cmd.shift();
   if ((menuItem.trim() == '') || (menuItem == "}")) {
      console.error(`Error translating menu response : "${msgType}"`);
      const result = {
         error: 'msg_invalid',
         message: `Expected main items but only found menu start "${msgType}"`,
         pfodDrawing: 'error'
       };
      return result;
   }     
   
  // match next cmd item
      // Extract identifier and drawing name from {,|+identifier~drawingName} or {;|+identifier~drawingName}  or {;|+identifier}
    const pattern = /^\|\+(.+?)~(.+)$/;
    const patternNoDwg = /^\|\+(.+?)$/;

    let matchNoDwg = menuItem.match(patternNoDwg);
    let match = menuItem.match(pattern);
    if ((!match) && (!matchNoDwg)) {    
      console.error(`Error translating menu response : "${menuItem}"`);
      const result = {
         error: 'msg_invalid',
         message: `Expected dwg menu item but only found menu start "${menuItem}"`,
         pfodDrawing: 'error'
       };
      return result;
   }     
    
    let identifier = '';
    let drawingName = '';
    
    if (match) {
      identifier = match[1];
      drawingName = match[2];
      console.log(`[QUEUE] Extracted identifier: ${identifier}, drawing name: ${drawingName}`);
    } else if (matchNoDwg) {
      identifier = matchNoDwg[1];
      drawingName = '';
      console.log(`[QUEUE] Extracted identifier: ${identifier}, drawing name: ${drawingName}`);
    }
    const result = {
      pfodDrawing: 'menu',
      drawingName: drawingName,
      identifier: identifier
    };
    return result;
}



// returns null no not match else returns either start or update with empty itmes
function translateDwgResponse(cmd) {
  let cmdString = cmd.shift();
  if (!cmdString || typeof cmdString !== 'string' || !cmdString.startsWith("{+")) {
      console.error(`Error translating dwg response : "${cmdString}"`);
      const result = {
         error: 'msgType_invalid',
         message: `Expected dwg but received "${cmdString}"`,
         pfodDrawing: 'error'
       };
      return result;
  }
    cmdString.trim();
    
    const updatePattern = /^\{\+(~(m)?)?$/;
    const matchUpdate = cmdString.match(updatePattern);
    if (matchUpdate) {
        return {
            pfodDrawing: "update",
            js_ver: window.JS_VERSION,
            more: matchUpdate[2] === 'm' ? true : false,
            raw_items: []
        };
    }
    // else
    const regex = /^\{\+(?:(\d+)`(\d+)`(\d+))?(~(m)?)?(`?(\d+)?~(.*))?$/;
    const match = cmdString.match(regex);

    if (!match) {
        console.error(`Error match failed for dwg response : "${cmdString}"`);
         const result = {
         error: 'dwg_invalid',
         message: `Expected dwg response but received "${cmdString}"`,
         pfodDrawing: 'error'
       };
      return result;
    }

    const [, colorNo, cols, rows, , more, , refreshMs, version] = match;

    return {
        pfodDrawing: "start",
        js_ver: window.JS_VERSION,
        version: version || "",
        x: cols ? parseInt(cols, 10) : undefined,
        y: rows ? parseInt(rows, 10) : undefined,
        color: colorNo ? parseInt(colorNo, 10) : 0,
        refresh: refreshMs ? parseInt(refreshMs, 10) : 0,
        more: more === 'm',
        raw_items: []
    };
}

    
function translateRawItemsToItemArray(rawData) {
    console.log(`Called translateRawItemsToItemArray with `, JSON.stringify(rawData, null, 2));

    const result = {
        pfodDrawing: rawData.pfodDrawing,
        //js_ver: rawData.js_ver,  // rawData does not have js_ver
        js_ver: window.JS_VERSION,  // use pfodWebDebug.js version
        name: rawData.name,
        version: rawData.version,
        x: rawData.x,
        y: rawData.y,
        color: rawData.color,
        refresh: rawData.refresh,
        items: []
    };

    // Process each raw item
    // upto first }
    let skipRest = false;
    rawData.raw_items.forEach((rawItem, index) => {
        // stop when rawItem is "}" end of pfod cmd
        if (rawItem == '}') {
          if (!skipRest) {
           skipRest = true;
           console.log(`End of cmd "}" at line  ${index + 2}`);
          } else {
           console.log(`Skipping raw_items after "}",  ${index + 2}: "${rawItem}":`);
          }           
        } else {
         if (!skipRest) {
          if (rawItem && rawItem.trim() !== '') { // Ignore empty items
            try {
                const translatedItem = translateRawItem(rawItem);
                result.items.push(translatedItem);
            } catch (itemError) {
                console.error(`Error translating raw_items at line ${index + 2}: "${rawItem}":`, itemError.message);
                throw new Error(`Translation failed at line ${index + 2}: ${itemError.message}`);
            }
          }
         } else {
           console.log(`Skipping raw_items after "}",  ${index + 2}: "${rawItem}":`);
         }
        }
    });
    console.log(`Translated JSON:\n`, JSON.stringify(result,null,2));
    
    return result;
}

    // Browser environment
window.translateRawItemsToItemArray = translateRawItemsToItemArray;
window.translateMenuResponse = translateMenuResponse;



/* ========================================
 * Inlined from: drawingDataProcessor.js
 * ======================================== */
/*   
   drawingDataProcessor.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// Drawing Data Processor Module
// Extracted from pfodWeb.js to improve code organization

// TouchZone filter constants
const TouchZoneFilters = {
    TOUCH: 0,           // Touches blocked if pfodApp busy waiting for response
    DOWN: 1,            // Queued if pfodApp busy waiting for response
    DRAG: 2,            // Queued if pfodApp busy waiting for response
    UP: 4,              // Queued if pfodApp busy waiting for response
    CLICK: 8,           // Queued if pfodApp busy waiting for response
    PRESS: 16,          // Long press - queued if pfodApp busy waiting for response
    ENTRY: 32,          // NEVER sent to pfodApp
    EXIT: 64,           // NEVER sent to pfodApp
    DOWN_DRAG_UP: 256,       // Msg not sent until finger removed (UP) but updates touchAction alias for DOWN_UP
    TOUCH_DISABLED: 512 // Capture touch to prevent scroll but do not send msg
};

// Decode method to convert filter numbers to array of filter names
TouchZoneFilters.decode = function(filterNumber) {
    // Handle TOUCH (value 0) first
    if (filterNumber === 0) {
        return ['TOUCH'];
    }
    
    // TOUCH_DISABLED has special handling - only return itself, no other values
    if (filterNumber === 512) {
        return ['TOUCH_DISABLED'];
    }
    
    const result = [];
    
    // Check each filter value (excluding TOUCH and TOUCH_DISABLED which are handled above)
    for (const [name, value] of Object.entries(TouchZoneFilters)) {
        if (name !== 'decode' && value !== 0 && value !== 512 && (filterNumber & value) === value) {
            result.push(name);
        }
    }
    
    return result;
};

// make all cmd: array
class DrawingDataProcessor {
    constructor(pfodWebInstance) {
        this.pfodWeb = pfodWebInstance;
    }
    
    isEmptyCmd(cmd) {
      if (!cmd) {
        return false
      }
      if (cmd.length < 2) {
        return false;
      }
      let cmd0 = cmd[0].trim();
      let cmd1 = cmd[1].trim();
      if ((cmd0 == '{') && (cmd1 == '}')){
        console.log(`[DRAWING_DATA] Received empty cmd response `);
        return true; // Successfully handled - no drawing data to process
      }
      return false;
    }
      
    // Main processing function for drawing data
    processDrawingData(data, drawingManager, savedData, requestType = 'unknown') {
        // Handle empty cmd responses (e.g., from touchZone requests)
        let cmd = data.cmd;
        if (cmd) {
          if (cmd.length < 2) {
            console.log(`[DRAWING_DATA] Received response with less than 2 elements of cmds (requestType: ${requestType})`);
            return; // Successfully handled - no drawing data to process
          }
          if (this.isEmptyCmd(cmd)) {
            console.log(`[DRAWING_DATA] Received empty cmd response - no action needed (requestType: ${requestType})`);
            // need to restore from touchaction
            return; // Successfully handled - no drawing data to process
          }            
          let msgType = cmd[0]; // take top on
          let result = null;
          if (msgType.startsWith("{+")) {
              result = window.translateDwgResponse(cmd);
              result.raw_items = cmd; // the rest of the commands are the raw_items for processing below
              result.name = data.name;
          } else if (msgType.startsWith("{,") || msgType.startsWith("{;")) {
              result = window.translateMenuResponse(cmd);
              this.currentIdentifier = result.identifier;
              let drawingName;
              if (result.drawingName.trim() !== '') {
               drawingName = result.drawingName; // update it
             } else {
               drawingName = drawingManager.currentDrawingName; // assume we are updating main dwg from menu
             }
             console.log(`[processDrawingData] Updated dwgName and currentDrawingName "${drawingName}"`);

             drawingManager.currentDrawingName = drawingName;
            // Update page title with drawing name
            // this.updatePageTitle(drawingName);
            // Add the drawing as the first drawing in the array if not already present
            if (!drawingManager.drawings.includes(drawingName)) {
               drawingManager.drawings.unshift(drawingName);
            }
            // request dwgName and return
         //   console.log(`[DRAWING_DATA] After tranlation::`, JSON.stringify(result, null, 2));
         //   this.pfodWebDebug.loadDrawing();
         //   return;
          }
          console.log(`[DRAWING_DATA] After tranlation::`, JSON.stringify(result, null, 2));
          
          data = result; // for next set of processing
        }
        // then continue to handle json version
         
        // need to handle {"cmd":["{+...", ... ]
        
        console.log(`Processing drawing data: ${data.pfodDrawing} command for ${data.name} (requestType: ${requestType})`);
        
        const drawingName = data.name;
        
        // Check if this is a touch-triggered request that should replace a drawing
        // Only touch-triggered requests can cause complete drawing replacement when data.pfodDrawing === 'start'
        if (requestType === 'touch' && data.pfodDrawing === 'start') {
            console.log(`[TOUCH_REPLACEMENT] Touch request returned start response for "${drawingName}"`);
            
            // Check if drawingName matches any current drawing (main or inserted)
            const drawingIndex = drawingManager.drawings.indexOf(drawingName);
            
            if (drawingIndex >= 0) {
                // Drawing found in current drawings - completely replace that specific drawing
                console.log(`[TOUCH_REPLACEMENT] Found "${drawingName}" at index ${drawingIndex} - completely replacing it`);
                // The drawing data will be updated in the normal processing flow below
            } else {
                // Drawing not found - completely replace main drawing and clear all inserted drawings
                console.log(`[TOUCH_REPLACEMENT] "${drawingName}" not found in current drawings - completely starting fresh`);
                
                // Clear tracking for all current drawings
                drawingManager.drawings.forEach(dwgName => {
                    this.pfodWeb.requestTracker.touchRequests.delete(dwgName);
                    this.pfodWeb.requestTracker.insertDwgRequests.delete(dwgName);
                    
                    // Clear localStorage for each drawing
                    localStorage.removeItem(`${dwgName}_version`);
                    localStorage.removeItem(`${dwgName}_data`);
                    console.log(`[TOUCH_REPLACEMENT] Cleared localStorage for "${dwgName}"`);
                });
                
                // Create a completely new DrawingManager instance to ensure clean state
                console.log(`[TOUCH_REPLACEMENT] Creating new DrawingManager instance`);
                drawingManager = new window.DrawingManager();
                drawingManager.initialize(drawingName);
                
                // Update page title with new main drawing name
                document.title = `pfodWeb ${drawingName}`;
                
                // DrawingDataProcessor works on shadow data - redraw update handled by updateFromShadow()
                
                console.log(`[TOUCH_REPLACEMENT] Started completely fresh with main drawing "${drawingName}"`);
            }
        }
        // Handle error responses first
        if (data.pfodDrawing === 'error') {
            console.log(`[ERROR] Drawing error received for "${drawingName}": ${data.error} - ${data.message}`);
            
            // If drawing not found, clear any saved version to prevent future requests with invalid version
            if (data.error === 'drawing_not_found') {
                console.log(`[ERROR] Clearing saved version for non-existent drawing "${drawingName}"`);
                localStorage.removeItem(`${drawingName}_version`);
                localStorage.removeItem(`${drawingName}_data`);
            }
            
            // Delegate to error handler
            this.pfodWeb.handleDrawingError(data);
            return;
        }
        
        // If this is a start command, initialize with new data
        if (data.pfodDrawing === 'start') {
        
            // Ensure x and y are within valid range (1-255)
            const x = Math.min(Math.max(data.x || 50, 1), 255);
            const y = Math.min(Math.max(data.y || 50, 1), 255);
        
            // Handle color validation - accept both numbers and string numbers
            let colorValue = data.color;
            if (typeof colorValue === 'string' && !isNaN(colorValue)) {
                console.log(`[COLOR_CONVERSION] Converting string color "${colorValue}" to number ${parseInt(colorValue)}`);
                colorValue = isNaN(parseInt(colorValue))? 0 : parseInt(colorValue);
            }
            const validColor = (typeof colorValue === 'number' && ((colorValue >= 0 && colorValue <= 255) || colorValue === -1)) ? colorValue : 0;
            console.log(`[COLOR_VALIDATION] Original color: ${data.color} (${typeof data.color}) -> Final color: ${validColor}`);

            const drawingData = {
                name: data.name,
                version: data.version,
                x: x,
                y: y,
                color: validColor, // Default to white (15) if invalid
                // Ensure refresh value is properly handled - 0 is a valid value
                refresh: data.refresh !== undefined ? data.refresh : 0
            };
            
            // Set the drawing data in the manager
            drawingManager.setDrawingData(drawingName, drawingData);
            
            console.log(`[REFRESH] Initialized drawing: ${data.name}, size=${x}x${y}, refresh=${drawingData.refresh}ms, version=${data.version}`);
            
            // For 'start' commands, we need to check for previously inserted drawings to remove
            if (drawingName === (drawingManager.drawings.length > 0 ? drawingManager.drawings[0] : '') && drawingManager.drawings.length > 1) {
                console.log(`Start command received for ${data.name}, checking for drawings to remove`);
                // Create a copy of the array since we'll be modifying it during removal
                // Skip first drawing (main drawing) and only include inserted drawings
                const previouslyInserted = [...drawingManager.drawings.slice(1)];
                previouslyInserted.forEach(insertedDrawingName => {
                        // If the drawing was directly inserted by this drawing (parent relationship),
                        // remove it and all its children
                        if (drawingManager.drawingsData[insertedDrawingName] && 
                            drawingManager.drawingsData[insertedDrawingName].parentDrawing === drawingName) {
                        console.log(`Removing previously inserted drawing ${insertedDrawingName} as part of start command`);
                        this.pfodWeb.removeInsertedDrawing(insertedDrawingName);
                            }
                });
            }
            
            
            // Initialize or reset arrays for this drawing
            drawingManager.clearItems(drawingName);
            
        // Save the version and data - handle empty/blank/undefined versions
            // If version is undefined, empty or all blanks, set to empty string
            console.log(`[VERSION_DEBUG] Processing start data for ${data.name}:`, data);
            console.log(`[VERSION_DEBUG] data.version = "${data.version}", type = ${typeof data.version}`);
            const normalizedVersion = (data.version && data.version.trim()) ? data.version : '';
            console.log(`Saving initial version "${normalizedVersion}" for drawing ${data.name}`);
            drawingManager.saveToLocalStorage(drawingName);
            
            // Save merged data for the main drawing using new storage system
            const mainDrawingName = drawingManager.getMainDrawingName();
            if (mainDrawingName) {
                drawingManager.saveMergedDataToStorage(mainDrawingName);
            }
        }
       // If this is an update, apply changes to existing data
        else if (data.pfodDrawing === 'update') {
            let drawingData;

            if (drawingName === null && requestType === 'touch') {
                // TouchAction request - update merged/shadow data directly, not individual drawing
                console.log(`[TOUCH_UPDATE] Getting merged shadow data for touchAction update`);
                // For shadow drawingManager, create virtual merged drawing data
                drawingData = {
                    items: [], // Will be populated from update
                    x: drawingManager.drawingsData[drawingManager.getMainDrawingName()].data.x,
                    y: drawingManager.drawingsData[drawingManager.getMainDrawingName()].data.y,
                    color: drawingManager.drawingsData[drawingManager.getMainDrawingName()].data.color
                };
            } else {
                // Normal drawing request - get individual drawing data
                drawingData = drawingManager.getDrawingData(drawingName);
            }
            
            if (!drawingData) {
                // If we have saved data, try to use it
                if (savedData) {
                    console.log('No active drawing data, using saved data from localStorage');
                    drawingData = JSON.parse(savedData);
                
                    // Ensure saved data also respects the 1-255 limit
                    drawingData.x = Math.min(Math.max(drawingData.x, 1), 255);
                    drawingData.y = Math.min(Math.max(drawingData.y, 1), 255);
                    console.log(`Restored drawing from localStorage: ${drawingData.name}, size=${drawingData.x}x${drawingData.y}`);
                
                    // Set the loaded data in the manager
                    drawingManager.setDrawingData(drawingName, drawingData);
                } else {                
                    console.error('Received update without initial data');
                    throw new Error('Received update without initial data');
                }
            }  
            // Store original dimensions and color before processing update
            const originalX = drawingData.x;
            const originalY = drawingData.y;
            const originalColor = drawingData.color;
            const originalVer = drawingData.version;
            
            // Create updated drawing data
            const updatedData = { ...drawingData };
            
            // Update refresh interval if provided
            if (data.refresh !== undefined) {
                console.log(`[REFRESH] Updating refresh rate for ${drawingName}: ${updatedData.refresh}ms -> ${data.refresh}ms`);
                updatedData.refresh = data.refresh;
            }
            
            // Preserve dimensions and color
            console.log(`Preserving dimensions (${originalX}x${originalY}) and color (${originalColor}) from previous data`);
            updatedData.x = originalX;
            updatedData.y = originalY;
            updatedData.color = originalColor;
            
            // Handle version updates - preserve existing version if not provided
            console.log(`[VERSION_DEBUG] Processing update data for ${data.name}:`, data);
            console.log(`[VERSION_DEBUG] data.version = "${data.version}", type = ${typeof data.version}`);
            if (data.version !== undefined && data.version !== null) {
                const normalizedVersion = data.version.trim() ? data.version : '';
                console.log(`Updating version from "${originalVer}" to "${normalizedVersion}"`);
                updatedData.version = normalizedVersion;
            } else {
                console.log(`Version not provided in update - keeping existing version "${originalVer}"`);
                updatedData.version = originalVer;
            }
            
            if (drawingName === null && requestType === 'touch') {
                // TouchAction request - update merged shadow data directly, don't update individual drawings
                console.log(`[TOUCH_UPDATE] Updating merged shadow data directly, no individual drawing updates, no merge needed`);
                // The processed items are already in the drawingManager's merged collections (all* properties)
                // No need to update individual drawing data or trigger merge - shadow data is already updated
            } else {
                // Normal drawing request - update individual drawing data
                drawingManager.setDrawingData(drawingName, updatedData);
                // Always save the updated drawing data
                drawingManager.saveToLocalStorage(drawingName);

                // Save merged data for the main drawing using new storage system
                const mainDrawingName = drawingManager.getMainDrawingName();
                if (mainDrawingName) {
                    drawingManager.saveMergedDataToStorage(mainDrawingName);
                }
            }
        } 
        else { 
           this.pfodWeb.handleDrawingError({
                  error: 'response_invalid',
                  message: `Response to load drawing "${drawingName}" returned neither start or update, returned ${data.pfodDrawing}`,
                  pfodDrawing: 'error'
            });
           return;
       }
       // end if start else update
        
        // Reset the transformation state based on command type
        // Initialize local transform stack
        let transformStack = [];
        let currentTransform; //

        // Set up local collection variables based on request type
        let targetIndexedItems, targetTouchZones, targetTouchActions, targetTouchActionInputs, targetUnindexedItems;

        if (drawingName === null && requestType === 'touch') {
            // TouchAction request - use merged collections directly
            console.log(`[TOUCH_UPDATE] Using merged collections for touchAction update`);
            targetIndexedItems = drawingManager.allIndexedItemsByNumber;
            targetTouchZones = drawingManager.allTouchZonesByCmd;
            targetTouchActions = drawingManager.allTouchActionsByCmd;
            targetTouchActionInputs = drawingManager.allTouchActionInputsByCmd;
            targetUnindexedItems = drawingManager.allUnindexedItems;
        } else {
            // Normal request - use individual drawing collections
            console.log(`[NORMAL_UPDATE] Using individual drawing collections for drawing: ${drawingName}`);
            // These will be accessed as targetIndexedItems, targetTouchZones[drawingName], etc.
            targetIndexedItems = drawingManager.indexedItems[drawingName] || {};
            targetTouchZones = drawingManager.touchZonesByCmd[drawingName] || {};
            targetTouchActions = drawingManager.touchActionsByCmd[drawingName] || {};
            targetTouchActionInputs = drawingManager.touchActionInputsByCmd[drawingName] || {};
            targetUnindexedItems = drawingManager.unindexedItems[drawingName] || [];
        }

        // Set the initial transform
        if (data.pfodDrawing === 'start') {
            // For 'start' commands, reset to initial state
            currentTransform = { x: 0, y: 0, scale: 1.0 };
            console.log(`[TRANSFORM] Using initial transform (0,0,1.0) for drawing start: ${drawingName}`);
        } else if (data.pfodDrawing === 'update' && drawingManager.savedTransforms[drawingName]) {
            // For 'update' commands, use the saved transform if available
            currentTransform = {...drawingManager.savedTransforms[drawingName]};
            console.log(`[TRANSFORM] Using saved transform for update: x=${currentTransform.x}, y=${currentTransform.y}, scale=${currentTransform.scale}`);
        } else {
            // Default fallback
            currentTransform = { x: 0, y: 0, scale: 1.0 };
            console.log(`[TRANSFORM] No saved transform found, using default (0,0,1.0)`);
        }
                
        // Process drawing items if they exist (either items or raw_items)
        let itemsToProcess = [];
        
        if (data.raw_items && Array.isArray(data.raw_items)) {
            console.log(`Processing ${data.raw_items.length} raw drawing items - translating to items format`);
            // Translate raw_items to items format using translator
            try {
                const translatedData = window.translateRawItemsToItemArray(data);
                itemsToProcess = translatedData.items;
                console.log(`Successfully translated ${data.raw_items.length} raw items to ${itemsToProcess.length} processed items`);
            } catch (error) {
                console.error('Failed to translate raw_items:', error.message);
                throw new Error(`Failed to translate raw_items: ${error.message}`);
            }
        } else if (data.items && Array.isArray(data.items)) {
            console.log(`Processing ${data.items.length} drawing items`);
            itemsToProcess = data.items;
        }
        
        if (itemsToProcess.length > 0) {
            
            // For update commands, if items array is empty, don't process anything (no changes)
            // but still need to redraw to show the restored state
            if (data.pfodDrawing === 'update' && itemsToProcess.length === 0) {
                console.log(`Update command has empty items array - no changes to apply, but triggering redraw`);
                // Still need to trigger redraw and continue with normal flow
            }
            

            itemsToProcess.forEach(item => {
            // Validate and normalize item color to integer (0-255)
            if (item.color !== undefined) {
                let colorValue = item.color;
                
// Handle string numbers (like "9", "82" from ESP32)
                if (typeof colorValue === 'string' && !isNaN(colorValue)) {
                  console.log(`[COLOR_CONVERSION] Converting string color "${colorValue}" to number ${parseInt(colorValue)}`);
                  colorValue = isNaN(parseInt(colorValue))? 0 : parseInt(colorValue);
                }                                   
               
                if (typeof colorValue === 'number' && ((colorValue >= 0 && colorValue <= 255) || colorValue === -1)) {
                    item.color = Math.floor(colorValue); // Ensure integer (-1 for Black/White mode, 0-255 for regular colors)
                } else {
                    item.color = 0; // Default to black for invalid colors
                }
            }
            
            // Add a processing flag to each item (assume valid by default)
            let skipProcessing = false;
                
            // Validate item
            if (!item.type) {
                console.error('Item missing type property:', item);
                skipProcessing = true;
            }
                
            // Debug log for each item
            console.log(`Processing item: type=${item.type}, properties:`, JSON.stringify(item));
            // Check if hide, unhide, or erase has valid idx or cmd
            if ((item.type === 'hide' || item.type === 'unhide' || item.type === 'erase')) {
                // For erase, allow either idx or cmd
                    if (!item.idx && !item.cmd) {
                        console.error(`Error: ${item.type} item has neither idx nor cmd, ignoring item:`, JSON.stringify(item));
                        skipProcessing = true;
                    } else if (item.idx && (item.idx < 1)) {
                        console.error(`Error: ${item.type} item has idx < 1, ignoring item:`, JSON.stringify(item));
                        skipProcessing = true;
                    }
            }
            
            // Handle push and pop first to maintain transformation state (all local)
                
            // Store a copy of the current transform with the item
            item.transform = {...currentTransform};
            // Set visible property to true by default
            if (item.visible === undefined) {
                item.visible = true;
            }

                
                if (item.type === 'pushZero') {
                // Save current transform to stack
                transformStack.push({...currentTransform});
                    
                 // Default missing properties
                 const x = item.x !== undefined ? parseFloat(item.x) : 0;
                 const y = item.y !== undefined ? parseFloat(item.y) : 0;
                 const scale = item.scale !== undefined ? parseFloat(item.scale) : 1.0;
                    
                 // Apply the push transform to current transform
                 currentTransform.x += x * currentTransform.scale;
                 currentTransform.y += y * currentTransform.scale;
                 currentTransform.scale *= scale;
                    
                 console.log(`[TRANSFORM] Push for ${drawingName}: New transform (${currentTransform.x}, ${currentTransform.y}, ${currentTransform.scale})`);
                    
                 // Skip adding push items to any collection
                 skipProcessing = true;
                 } else if (item.type === 'popZero') {
                 // Get previous transform from stack
                 if (transformStack.length > 0) {
                     const oldTransform = {...currentTransform};
                     currentTransform = transformStack.pop();
                     console.log(`[TRANSFORM] Pop for ${drawingName}: Restored from (${oldTransform.x}, ${oldTransform.y}, ${oldTransform.scale}) to (${currentTransform.x}, ${currentTransform.y}, ${currentTransform.scale})`);
                 } else {
                     // If stack is empty, reset to initial state
                     const oldTransform = {...currentTransform};
                     currentTransform = { x: 0, y: 0, scale: 1.0 };
                     console.warn(`[TRANSFORM] Pop for ${drawingName}: Stack empty, reset to default (0,0,1.0)`);
                 }
                    
                 // Skip adding pop items to any collection
                 skipProcessing = true;
             } // end push pop
                
             // Apply default values based on item type
             if (item.type === 'rectangle') {
                 // Default missing properties
                 item.xOffset = item.xOffset !== undefined ? item.xOffset : 0;
                 item.yOffset = item.yOffset !== undefined ? item.yOffset : 0;
                 item.xSize = item.xSize !== undefined ? item.xSize : 1;
                 item.ySize = item.ySize !== undefined ? item.ySize : 1;
                 item.filled = item.filled || 'false';
                 item.rounded = item.rounded || 'false';
                 console.log('Processed rectangle with defaults:', JSON.stringify(item));
                
            } else if (item.type === 'line') {
                // Default missing properties
                item.xOffset = item.xOffset !== undefined ? item.xOffset : 0;
                item.yOffset = item.yOffset !== undefined ? item.yOffset : 0;
                item.xSize = item.xSize !== undefined ? item.xSize : 1;
                item.ySize = item.ySize !== undefined ? item.ySize : 1;
                console.log('Processed line with defaults:', JSON.stringify(item));
                
            } else if (item.type === 'insertDwg' ) { //|| item.type.toLowerCase() === 'insertdwg') {
                // Always ensure insertDwg items have null index - they should NEVER be indexed
                if (item.idx && item.idx !== 'null') {
                    console.warn(`Warning: insertDwg item for "${item.drawingName}" has idx=${item.idx}, nulling it as insertDwg should never be indexed`);
                    item.idx = 'null';
                }                
                // Normalize the type to insertDwg for consistency
                item.type = 'insertDwg';
                
            } else if (item.type === 'touchZone') {
                // Default missing properties
                item.xOffset = item.xOffset ||  0;
                item.yOffset = item.yOffset ||  0;
                item.xSize = item.xSize || 1;
                item.ySize = item.ySize || 1;
                item.cmd = item.cmd || '';
                item.filter = parseInt(item.filter || TouchZoneFilters.TOUCH);
                item.centered = item.centered || 'false';
                // idx is handled in the touchZone processing logic below, not here
                if (item.cmd.trim().length == 0) {
                    console.warn('Error: touchZone has empty cmd, in drawing {$data.name} ignoring:', JSON.stringify(item));
                    skipProcessing = true; // Flag to skip adding this item to collections
                } else {
                   console.log('Processed touchZone with defaults:', JSON.stringify(item));
                }
                
            } else if (item.type === 'touchAction') {
                // Default missing properties
                item.cmd = item.cmd || '';
                item.action = item.action || [];
                
                if (item.cmd.trim().length == 0) {
                    console.warn(`Error: touchAction has empty cmd in drawing "${data.name}", ignoring:`, JSON.stringify(item));
                    skipProcessing = true;
                } else {
                    console.log('Processed touchAction with defaults:', JSON.stringify(item));
                }
                
            } else if (item.type === 'label') {
                // Default missing properties for label
                item.xOffset = item.xOffset || 0;
                item.yOffset = item.yOffset || 0;
                item.text = item.text || '';
                item.fontSize = item.fontSize || 0;
                item.bold = item.bold === 'true' || item.bold === true;
                item.italic = item.italic === 'true' || item.italic === true;
                item.underline = item.underline === 'true' || item.underline === true;
                item.align = item.align || 'left'; // default alignment when not specified
                // Handle new optional properties (value, units, decimals) - no defaults needed as they're optional
                if (item.value !== undefined && item.value !== null && item.value !== '') {
                    item.value = parseFloat(item.value);
                }
                if (item.decimals !== undefined && item.decimals !== null && item.decimals !== '') {
                    item.decimals = parseInt(item.decimals);
                }
                // item.units stays as-is (string) - no conversion needed
                console.log('Processed label with defaults:', JSON.stringify(item));
                
            } else if (item.type === 'value') {
                // Default missing properties for value
                item.xOffset = item.xOffset || 0;
                item.yOffset = item.yOffset || 0;
                item.text = item.text || '';
                item.fontSize = item.fontSize || 0;
                item.bold = item.bold === 'true' || item.bold === true;
                item.italic = item.italic === 'true' || item.italic === true;
                item.underline = item.underline === 'true' || item.underline === true;
                item.align = item.align || 'left'; // default alignment when not specified
                item.intValue = item.intValue || 0;
                item.max = item.max || 1;
                item.min = item.min || 0;
                item.displayMax = item.displayMax || 1.0;
                item.displayMin = item.displayMin || 0.0;
                item.decimals = (item.decimals !== undefined && item.decimals !== null && item.decimals !== '') ? parseInt(item.decimals) : 2;
                item.units = item.units || '';
                console.log('Processed value with defaults:', JSON.stringify(item));
                
            } else if (item.type === 'circle') {
                // Default missing properties for circle
                item.xOffset = item.xOffset || 0;
                item.yOffset = item.yOffset || 0;
                item.radius = item.radius || 1;
                item.filled = item.filled === 'true' || item.filled === true;
                console.log('Processed circle with defaults:', JSON.stringify(item));
                
            } else if (item.type === 'arc') {
                // Default missing properties for arc
                item.xOffset = item.xOffset || 0;
                item.yOffset = item.yOffset || 0;
                item.radius = item.radius || 1;
                item.filled = item.filled === 'true' || item.filled === true;
                item.start = item.start || 0;
                item.angle = item.angle || 90;
                
                // Normalize start and angle to be within -360 to +360 range
                item.start = item.start % 360;
                if (item.start > 360) item.start -= 360;
                if (item.start < -360) item.start += 360;
                
                item.angle = item.angle % 360;
                if (item.angle > 360) item.angle -= 360;
                if (item.angle < -360) item.angle += 360;
                
                console.log('Processed arc with defaults:', JSON.stringify(item));
                
            } else if (item.type === 'index') {
                // Check if idx is less than 1 (invalid)
                if (item.idx < 1) {
                    console.error('Error: Index item has idx < 1, ignoring item:', JSON.stringify(item));
                    skipProcessing = true; // Flag to skip adding this item to collections
                } else {
                    const idx = item.idx;
                    const indexedItems = drawingManager.getIndexedItems(drawingName);
                    if (indexedItems[idx]) {
                      console.log(`Processing index item with idx=${item.idx} - already have item with that idx so skip processing this`);
                      skipProcessing = true; // Flag to skip adding this item to collections
                    } else {
                      // For valid index items, save transform data
                      console.log(`Processing index item with idx=${item.idx} - saving transform/clipping data for later use`);
                    }
                }
                // Handle index items with cmdName (touchZone items)  
                if (item.cmdName && item.cmdName.trim() !== '') {
                    const cmd = item.cmd || '';
                    if (cmd.trim().length > 0) {
                        // Check if there's already a touchZone with this cmd
                        const existingTouchZone = drawingManager.touchZonesByCmd[drawingName] && 
                                                drawingManager.touchZonesByCmd[drawingName][cmd];
                        if (existingTouchZone) {
                            console.log(`Processing index item with cmdName="${item.cmdName}" cmd="${cmd}" - already exists, skipping`);
                            skipProcessing = true;
                        } else {
                            console.log(`Processing index item with cmdName="${item.cmdName}" cmd="${cmd}" - will be added as touchZone placeholder`);
                        }
                    }
                }
            } // end not hide / unhide / erase
            
            // Process control items (hide, unhide, erase, push, pop) BEFORE checking skipProcessing
            // These should always be processed but never added to item collections
            if (item.type === 'hide' || item.type === 'unhide' || item.type === 'erase') {
                
                if (item.type === 'erase') {
                    // For erase items, handle both idx and cmd
                    if (item.idx) {
                        // Erase by index
                        const idx = item.idx;
                        const indexedItems = drawingManager.getIndexedItems(drawingName);
                        
                        if (indexedItems[idx]) {
                            delete drawingManager.indexedItems[drawingName][idx];
                            console.log(`Erased item with index ${idx}`);
                        } else {
                            console.warn(`Erase operation: No item found with idx=${idx} to erase`);
                        }
                    } else if (item.cmd) {
                        if (item.drawingName !== undefined) {
                         drawingManager.eraseByCmd(drawingName, item.cmd, item.drawingName);
                         console.log(`Erased insertDwg and actions with cmd="${item.cmd}"`);
                       } else {
                        // Erase by cmd - removes touchZone and all associated actions
                        drawingManager.eraseByCmd(drawingName, item.cmd);
                        console.log(`Erased touchZone and actions with cmd="${item.cmd}"`);
                       }
                    }
                    // Skip adding erase items to any collection
                    skipProcessing = true;
                } else {
                    // For hide/unhide, handle both idx and cmd
                    if (item.idx) {
                        // Hide/unhide by index - affects indexed items only (ignore touchZones)
                        const idx = item.idx;
                        const indexedItems = drawingManager.getIndexedItems(drawingName);
                        const targetItem = indexedItems[idx];
                        
                        if (targetItem) {
                            // Set the visible property based on hide/unhide type
                            targetItem.visible = item.type === 'unhide';
                            console.log(`${item.type === 'unhide' ? 'Unhiding' : 'Hiding'} item with index ${idx}`);
                        } else {
                            console.warn(`${item.type} operation: No item found with idx=${idx} to ${item.type === 'unhide' ? 'unhide' : 'hide'}`);
                        }
                    } else if (item.cmd) {
                        // Hide/unhide by cmd - affects touchZones and insertDwg items only
                        if (item.type === 'hide') {
                            if (item.drawingName !== undefined) {
                            drawingManager.hideByCmd(drawingName, item.cmd,item.drawingName);
                            console.log(`Hidden touchZone and insertDwg items with cmd="${item.cmd}"`);
                            } else {
                            drawingManager.hideByCmd(drawingName, item.cmd);
                            console.log(`Hidden touchZone and insertDwg items with cmd="${item.cmd}"`);
                            }
                        } else if (item.type === 'unhide') {
                            if (item.drawingName !== undefined) {
                            drawingManager.unhideByCmd(drawingName, item.cmd,item.drawingName);
                            console.log(`Unhidden touchZone and insertDwg items with cmd="${item.cmd}"`);
                            } else {
                            drawingManager.unhideByCmd(drawingName, item.cmd);
                            console.log(`Unhidden touchZone and insertDwg items with cmd="${item.cmd}"`);
                            }
                        }
                    }
                    // Skip adding hide/unhide items to any collection
                    skipProcessing = true;
                }
            }
                
           // Only proceed with normal item processing if not already marked to skip
           if (!skipProcessing) {
              // Get drawing name from item or use current drawing name
              // SPECIAL CASE: For insertDwg items, we ALWAYS use the current drawing name, not the drawingName specified in the item
              // This is because the insertDwg item needs to be stored in the current drawing's unindexed items list
              // to be properly processed by the handleInsertDwg function
              const mainDrawingName = drawingManager.drawings.length > 0 ? drawingManager.drawings[0] : '';
              const itemDrawingName = data.name; // (item.type === 'insertDwg' || item.type.toLowerCase() === 'insertdwg') ? data.name : (item.drawingName || data.name);
              item.parentDrawingName = itemDrawingName;
              drawingManager.ensureItemCollections(itemDrawingName);                       

              // Special handling for insertDwg items
              if (item.type === 'insertDwg') { // || (item.type && item.type.toLowerCase() === 'insertdwg')) {
                    // For insertDwg items, we MUST use the current drawing name
                    // NOT the drawingName specified in the item (which is the target drawing to insert)
                    const currentDrawing = data.name;
                    
                    // Ensure the collections exist for the current drawing
                    drawingManager.ensureItemCollections(currentDrawing);
                    
                    // Normalize type to camelCase for consistency
                    item.type = 'insertDwg';                    
                                        
                    // Add to the current drawing's unindexed items
                    try {
                        targetUnindexedItems.push(item);
                        console.log(`Added insertDwg item for "${item.drawingName}" with transform (${item.transform.x},${item.transform.y},${item.transform.scale}) to drawing=${currentDrawing}, visible=${item.visible}`);
                    } catch (error) {
                        console.error(`Error adding insertDwg item to unindexed items for ${currentDrawing}:`, error);
                        console.log('Item that caused error:', JSON.stringify(item));
                    }
              // Check if this is a touchZone or index item with cmdName
              } else if (item.type === 'touchZone' || (item.type === 'index' && item.cmdName && item.cmdName.trim() !== '')) {
                    // Only process filter for actual touchZone items, not index items
                    if (item.type === 'touchZone') {
                        // Check if there's an associated touchActionInput for this cmd
                        if (item.cmd && item.cmd.trim().length > 0) {
                            const existingTouchActionInput = targetTouchActionInputs[item.cmd];
                            if (existingTouchActionInput) {
                                // If touchActionInput exists, filter can only be TOUCH or TOUCH_DISABLED
                                if (item.filter !== TouchZoneFilters.TOUCH && item.filter !== TouchZoneFilters.TOUCH_DISABLED) {
                                    console.log(`[TOUCH_ZONE] Constraining updated touchZone filter from ${item.filter} to TOUCH for cmd=${item.cmd} due to existing touchActionInput`);
                                    item.filter = TouchZoneFilters.TOUCH;
                                }
                            }
                        }
                    }
                    
                    // Add the touchZone to the target collection
                    targetTouchZones[item.cmd] = item;
                    console.log(`Added touchZone: cmd=${item.cmd}, filter=${item.filter}, idx=${item.idx || 0}, drawing=${itemDrawingName}`);
                   // this.drawingManager.unindexedItems[itemDrawingName].push(item);
                   // console.log(`Added unindexed item: type=${item.type}, drawing=${itemDrawingName}, visible=${item.visible !== false}`);
                    
              // Check if this is a touchAction
              } else if (item.type === 'touchAction') {
                    // Add the touchAction to the target collection
                    // Initialize actions array if it doesn't exist for this cmd
                    if (!targetTouchActions[item.cmd]) {
                        targetTouchActions[item.cmd] = [];
                    }
                    // Append the action items to existing actions array instead of replacing
                    if (item.action && Array.isArray(item.action)) {
                        targetTouchActions[item.cmd].push(...item.action);
                    }
                    console.log(`Added touchAction: cmd=${item.cmd}, actions=${(item.action || []).length}, drawing=${itemDrawingName}`);
                    // touchActions are not added to unindexed/indexed items - they're stored separately
                    
              // Check if this is a touchActionInput
              } else if (item.type === 'touchActionInput') {
                    // Add the touchActionInput to the target collection
                    targetTouchActionInputs[item.cmd] = item;
                    console.log(`Added touchActionInput: cmd=${item.cmd}, prompt="${item.prompt}", textIdx=${item.textIdx}, drawing=${itemDrawingName}`);
                    // touchActionInputs are not added to unindexed/indexed items - they're stored separately
                    
              // Normal processing for other items
              } else if (item.idx && item.idx !== 'null') {
                  // For non-touchZone items, handle as regular indexed items
                  const idx = item.idx;                        
                  // Get the current indexed items for this drawing
                  const isUpdate = targetIndexedItems[idx] !== undefined;
                  // Add the item to the target indexed items collection
                  if (isUpdate) {
                   item.transform = targetIndexedItems[idx].transform;// || { x: 0, y: 0, scale: 1 };
                   item.clipRegion = targetIndexedItems[idx].clipRegion;// || { x: 0, y: 0, width: 100, height: 20 };
                   // Preserve visibility state from existing item
                   item.visible = targetIndexedItems[idx].visible;
                  }

                  targetIndexedItems[idx] = item;
                        
                  console.log(`${isUpdate ? 'Updated' : 'Added'} indexed item: type=${item.type}, drawing=${itemDrawingName}, idx=${idx}, visible=${item.visible !== false}`);
              } else {
                  // Unindexed items
                  // For non-touchZone items, add to the drawing's unindexed items array
                  // Ensure the collections exist for the drawing before adding the item
                  // This is especially important for insertDwg items which refer to other drawings
                  try {
                      // Add to target unindexed items collection
                      targetUnindexedItems.push(item);
                      console.log(`Added unindexed item: type=${item.type}, drawing=${itemDrawingName}, visible=${item.visible !== false}`);
                  } catch (error) {
                      console.error(`Error adding unindexed item to ${itemDrawingName}:`, error);
                      console.log('Item that caused error:', JSON.stringify(item));
                  }
                  console.log(`Added unindexed item: type=${item.type}, to drawing=${itemDrawingName}, visible=${item.visible}`);
               }
            } // if (!skipProcessing)
        });
        // Log summary of items
        console.log(`Drawing ${data.name} now has ${targetUnindexedItems.length} unindexed items, ${Object.keys(targetIndexedItems).length} indexed items,  ${Object.keys(targetTouchZones).length} touchZones`);
        if (targetUnindexedItems.length > 0) {
            console.log('Unindexed item types:', targetUnindexedItems.map(i => i.type).join(', '));
        }
        if (Object.keys(targetIndexedItems).length > 0) {
            console.log('Indexed item types:', Object.values(targetIndexedItems).map(i => i.type).join(', '));
        }
    } // if (data.items && Array.isArray(data.items))

    if (drawingName !== null) {
        console.log(`Set response status to TRUE for "${drawingName}"`);
        drawingManager.drawingResponseStatus[drawingName] = true;
    } else {
        console.log(`Skipping response status update for touchAction request (null drawingName)`);
    }
        
    // Check for insertDwg items and add them to the request queue
    console.log(`Scanning for insertDwg items in ${targetUnindexedItems.length} unindexed items of drawing ${data.name}`);
    // Debug: full dump of unindexed items array for this drawing
    console.log(`[DEBUG] Raw unindexed items array for ${data.name}:`, JSON.stringify(targetUnindexedItems));
    // Find insertDwg items in unindexed items
    const insertDwgItems = targetUnindexedItems.filter(item =>
        item.type && (
            //item.type.toLowerCase() === 'insertdwg' ||
            item.type === 'insertDwg'
        ));

        // Debugging detailed info about each unindexed item
    console.log(`[DEBUG] Detailed unindexed items for drawing ${data.name}:`);
    targetUnindexedItems.forEach((item, index) => {
        console.log(`- Item ${index}: type=${item.type}, drawingName=${item.drawingName || 'none'}, would match insertDwg filter: ${(item.type === 'insertDwg' || (item.type && item.type.toLowerCase() === 'insertdwg'))}`);
        // Print full item for better debugging
        console.log(`  Full item ${index}:`, JSON.stringify(item));
    });

    const indices = Object.keys(targetIndexedItems);
    indices.forEach(idx => {
        const itemWithIndex = targetIndexedItems[idx];
        const drawingSource = itemWithIndex.parentDrawingName || 'unknown';
        console.log(`[PROCESS_DATA] Drawing indexed item ${idx} of type ${itemWithIndex.type} from ${drawingSource}`);
        if (itemWithIndex.transform) {
            console.log(`[PROCESS_DATA] Indexed item transform: x=${itemWithIndex.transform.x}, y=${itemWithIndex.transform.y}, scale=${itemWithIndex.transform.scale}`);
        } else {
            console.log(`[PROCESS_DATA] Indexed item has no transform!`);
        }
    });
    
    let foundInsertDwgItems = false;
        
    if (insertDwgItems.length > 0) {
        foundInsertDwgItems = true;
        console.log(`Found ${insertDwgItems.length} insertDwg items to process in drawing ${data.name}`);
        insertDwgItems.forEach(item => {
            // Check for and null any idx on insertDwg items
            if (item.idx && item.idx !== 'null') {
                console.log(`Warning: insertDwg item for "${item.drawingName}" has idx=${item.idx}, nulling it as insertDwg should not have an idx.`);
                item.idx = 'null';
            }
            console.log(`Processing insertDwg item for drawing "${item.drawingName}" at offsets (${item.xOffset || 0}, ${item.yOffset || 0})`);
            this.pfodWeb.handleInsertDwg(item);
        });
    } else {
        console.log(`No insertDwg items found in unindexed items of drawing ${data.name}`);
    }
        
    // Save the current transform for this drawing at the end of processing
    // This will be used as the starting transform for updates
    if (drawingName !== null) {
        drawingManager.saveTransform(drawingName, currentTransform);
        console.log(`[TRANSFORM] Saved transform for drawing "${data.name}": x=${currentTransform.x}, y=${currentTransform.y}, scale=${currentTransform.scale}`);
    } else {
        console.log(`[TRANSFORM] TouchAction request - no transform save needed for merged data update`);
    }
        
        // DrawingDataProcessor works on shadow data - redraw update handled by updateFromShadow()
        
        // If we found insertDwg items, we'll let the queue process them and do the redraw
        // when all items are processed. Otherwise, redraw immediately.
        console.log(`[REDRAW_DECISION] foundInsertDwgItems=${foundInsertDwgItems}, requestQueue.length=${this.pfodWeb.requestQueue.length}, isProcessingQueue=${this.pfodWeb.isProcessingQueue()}, sentRequest=${this.pfodWeb.sentRequest?.drawingName || 'none'}, drawingName=${drawingName}`);
        // Defer redraw if there are pending requests in the queue OR if we're actively processing a request OR if there's a sent request
        // This ensures all drawings are processed before attempting a final redraw
        if (this.pfodWeb.requestQueue.length > 0 || this.pfodWeb.isProcessingQueue() || this.pfodWeb.sentRequest) {
            console.log(`[REDRAW_DECISION] Deferring redraw for ${drawingName} - queue length: ${this.pfodWeb.requestQueue.length}, processing: ${this.pfodWeb.isProcessingQueue()}, sentRequest: ${this.pfodWeb.sentRequest?.drawingName || 'none'}`);
            // We'll still update the state, but defer redraw to the queue completion
        } else {
            // Queue is empty, not processing, and no sent request - redraw now
            console.log(`[REDRAW_DECISION] Queue empty, not processing, no sent request after ${drawingName}, redrawing immediately`);
            drawingManager.allDrawingsReceived = true; // this is not actually used!!
  //          this.pfodWeb.resizeCanvas();
        }
        
        // Enable updates and start update loop only after complete processing
        this.pfodWeb.isUpdating = true;
        this.pfodWeb.scheduleNextUpdate();
    }
}

// Export for use in other modules
// Make classes available globally for class definition access
// IMPORTANT: Only pfodWeb should create instances of these classes
// Other modules should use the instances provided by pfodWeb
window.DrawingDataProcessor = DrawingDataProcessor;
window.TouchZoneFilters = TouchZoneFilters;


/* ========================================
 * Inlined from: pfodWebMouse.js
 * ======================================== */
/*   
   pfodWebMouse.js
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.
 */

// Make pfodWebMouse available globally for browser use
window.pfodWebMouse = {
  // Helper method to calculate scale factors based on actual rendered canvas size
  // This handles layout changes (like raw message view) that affect canvas display
  getCanvasScale: function() {
    const rect = this.canvas.getBoundingClientRect();
    const logicalWidth = this.redraw ? (this.redraw.redrawDrawingManager?.drawingsData[this.redraw.getCurrentDrawingName()]?.data?.x || 255) : 255;
    const logicalHeight = this.redraw ? (this.redraw.redrawDrawingManager?.drawingsData[this.redraw.getCurrentDrawingName()]?.data?.y || 255) : 255;
    return {
      scaleX: rect.width / logicalWidth,
      scaleY: rect.height / logicalHeight,
      rect: rect
    };
  },

  setupEventListeners: function(drawingViewer) {
    const canvas = drawingViewer.canvas;
    
    // Initialize touchActionBackups on global object only if it doesn't exist to preserve existing backups
    if (window.pfodWebMouse.touchActionBackups === undefined) {
      window.pfodWebMouse.touchActionBackups = null;
    }

    canvas.addEventListener('mousedown', (e) => this.handleMouseDown.call(drawingViewer, e));
    canvas.addEventListener('mousemove', (e) => this.handleMouseMove.call(drawingViewer, e));
    canvas.addEventListener('mouseup', (e) => this.handleMouseUp.call(drawingViewer, e));
    canvas.addEventListener('mouseleave', (e) => this.handleMouseLeave.call(drawingViewer, e));
    canvas.addEventListener('click', (e) => this.handleClick.call(drawingViewer, e));
    canvas.addEventListener('contextmenu', function(e) {
      e.preventDefault(); // Prevent context menu
    });
    
    // Prevent browser drag behavior on canvas
    canvas.addEventListener('dragstart', function(e) {
      e.preventDefault(); // Prevent canvas from being dragged
    });
    
    // Disable canvas selection and drag
    canvas.style.userSelect = 'none';
    canvas.style.webkitUserSelect = 'none';
    canvas.style.msTouchAction = 'none';
    canvas.style.touchAction = 'none';
    canvas.draggable = false;

    // Touch events for mobile support
    canvas.addEventListener('touchstart', (e) => this.handleMouseDown.call(drawingViewer, e.touches[0]));
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      this.handleMouseMove.call(drawingViewer, e.touches[0]);
    });
    canvas.addEventListener('touchend', (e) => this.handleMouseUp.call(drawingViewer, e.changedTouches[0]));
  },

  // Mouse and touch event handlers
  handleMouseDown: function(e) {
    console.warn(`[MOUSE_DOWN] called handleMouseDown`);

    // Get canvas-relative coordinates and scale factors
    const scale = window.pfodWebMouse.getCanvasScale.call(this);
    const x = (e.clientX - scale.rect.left) / scale.scaleX;
    const y = (e.clientY - scale.rect.top) / scale.scaleY;

    let minTouch_mm = 9;
    let minPercent = 2 / 100;
    let colPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4); // half 9mm to add to both sides
    let rowPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4);
    if ((scale.rect.width * minPercent) > colPixelsHalf9mm) {
      colPixelsHalf9mm = scale.rect.width * minPercent;
    }
    if ((scale.rect.height * minPercent) > rowPixelsHalf9mm) {
      rowPixelsHalf9mm = scale.rect.height * minPercent;
    }
    console.log(`DOWN in touchZone: enlarge by ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);
    colPixelsHalf9mm = colPixelsHalf9mm / scale.scaleX;
    rowPixelsHalf9mm = rowPixelsHalf9mm / scale.scaleX;
    console.log(`DOWN in touchZone: canvas ${scale.rect.width} x ${scale.rect.height}`);
    console.log(`DOWN in touchZone: enlarge by dwg coords ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);

    // Update touch state
    console.log(`[MOUSE_DOWN] Setting touchState.isDown = true`);
    this.touchState.wasDown = this.touchState.isDown;
    this.touchState.isDown = true;

    // Cancel any existing refresh timer to prevent interruption during user interaction
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
      console.log(`[MOUSE_DOWN] Cancelled refresh timer`);
    }

    this.touchState.startX = x;
    this.touchState.startY = y;
    this.touchState.lastX = x;
    this.touchState.lastY = y;
    this.touchState.startTime = Date.now();
    this.touchState.hasDragged = false;
    this.touchState.hasEnteredZones.clear();


      // Create backup using redraw's makeBackup method
      console.log(`[TOUCH_ACTION] Creating backup using redraw.makeBackup()`);
      window.pfodWebMouse.touchActionBackups = this.redraw.makeBackup();

      if (!window.pfodWebMouse.touchActionBackups) {
        console.error(`[TOUCH_ACTION] Failed to create backup - makeBackup() returned null`);
        return;
      }


    // Find the touchZone at this position
    const foundTouchZone = window.pfodWebMouse.findTouchZoneAt.call(this, x, y, colPixelsHalf9mm, rowPixelsHalf9mm);
    this.touchState.targetTouchZone = foundTouchZone;

    // Handle basic TOUCH filter (default if no filter specified)
    if (foundTouchZone && (foundTouchZone.filter === TouchZoneFilters.TOUCH || foundTouchZone.filter === 0)) {
      console.log(`TOUCH in touchZone: cmd=${foundTouchZone.cmd}`);
      window.pfodWebMouse.handleTouchZoneActivation.call(this, foundTouchZone, TouchZoneFilters.TOUCH, x, y);
    } 

    // If we found a touchZone with a DOWN filter, handle it
    if (foundTouchZone && (foundTouchZone.filter & TouchZoneFilters.DOWN)) {
      console.log(`Mouse DOWN in touchZone: cmd=${foundTouchZone.cmd}, filter=${foundTouchZone.filter}`);
      window.pfodWebMouse.handleTouchZoneActivation.call(this, foundTouchZone, TouchZoneFilters.DOWN, x, y);
    }
    // If we found a touchZone with a DOWN_UP / DOWN_DRAG_UP filter, handle it show touchActions but no msg yet
    if (foundTouchZone && (foundTouchZone.filter & TouchZoneFilters.DOWN_DRAG_UP)) {
      console.log(`Mouse DOWN in touchZone: cmd=${foundTouchZone.cmd}, filter=${foundTouchZone.filter}`);
      window.pfodWebMouse.handleTouchZoneActivation.call(this, foundTouchZone, TouchZoneFilters.DOWN, x, y, false);
    }

    // If we found a touchZone with a CLICK filter, handle it
//    if (foundTouchZone && (foundTouchZone.filter & TouchZoneFilters.CLICK)) {
//      console.log(`Mouse DOWN in touchZone: cmd=${foundTouchZone.cmd}, filter=${foundTouchZone.filter}`);
//      window.pfodWebMouse.handleTouchZoneActivation.call(this, foundTouchZone, TouchZoneFilters.DOWN, x, y, false); // show touchActions but no msg
//    }
    
    // If the touchZone supports PRESS (long press), set up a timer
    if (foundTouchZone && (foundTouchZone.filter & TouchZoneFilters.PRESS)) {
      if (this.touchState.longPressTimer) {
        clearTimeout(this.touchState.longPressTimer);
      }

      // Set a timer for long press (700ms is standard)
      this.touchState.longPressTimer = setTimeout(() => {
        if (this.touchState.isDown && this.touchState.targetTouchZone === foundTouchZone) {
          console.log(`Long PRESS in touchZone: cmd=${foundTouchZone.cmd}`);
          window.pfodWebMouse.handleTouchZoneActivation.call(this, foundTouchZone, TouchZoneFilters.PRESS, this.touchState.lastX, this.touchState.lastY);
        }
      }, 700);
    }
  },

  handleMouseMove: function(e) {
    if (!this.touchState.isDown) {
      console.log(`[MOUSE_MOVE] Ignoring - mouse not down`);
      return;
    }
    console.log(`[MOUSE_MOVE] Processing mouse move event`);

    // Get canvas-relative coordinates and scale factors
    const scale = window.pfodWebMouse.getCanvasScale.call(this);
    const x = (e.clientX - scale.rect.left) / scale.scaleX;
    const y = (e.clientY - scale.rect.top) / scale.scaleY;

    let minTouch_mm = 9;
    let minPercent = 2 / 100;
    let colPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4); // half 9mm to add to both sides
    let rowPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4);
    if ((scale.rect.width * minPercent) > colPixelsHalf9mm) {
      colPixelsHalf9mm = scale.rect.width * minPercent;
    }
    if ((scale.rect.height * minPercent) > rowPixelsHalf9mm) {
      rowPixelsHalf9mm = scale.rect.height * minPercent;
    }
    console.log(`DRAG in touchZone enlarge by ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);
    colPixelsHalf9mm = colPixelsHalf9mm / scale.scaleX;
    rowPixelsHalf9mm = rowPixelsHalf9mm / scale.scaleX;
    console.log(`DRAG in touchZone canvas ${scale.rect.width} x ${scale.rect.height}`);
    console.log(`DRAG in touchZone enlarge by dwg coords ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);

    // Update current position
    this.touchState.lastX = x;
    this.touchState.lastY = y;

    // Calculate distance moved from start point
    const dx = x - this.touchState.startX;
    const dy = y - this.touchState.startY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Only consider as drag if moved more than a small threshold
    if (distance > 0) {
      console.log(`[MOUSE_DRAG] Distance moved: ${distance.toFixed(2)}, setting hasDragged = true`);
      this.touchState.hasDragged = true;

      // Find touchZone at current position
      const currentTouchZone = window.pfodWebMouse.findTouchZoneAt.call(this, x, y, colPixelsHalf9mm, rowPixelsHalf9mm);
      console.log(`[MOUSE_DRAG] CurrentTouchZone:`, currentTouchZone ? `cmd=${currentTouchZone.cmd}, filter=${currentTouchZone.filter}` : 'null');

      // Handle ENTRY/EXIT events
      if (currentTouchZone !== this.touchState.targetTouchZone) {
        // Handle EXIT from previous touchZone
        if (this.touchState.targetTouchZone && (this.touchState.targetTouchZone.filter & TouchZoneFilters.EXIT)) {
          console.log(`EXIT from touchZone: cmd=${this.touchState.targetTouchZone.cmd}`);
          window.pfodWebMouse.handleTouchZoneActivation.call(this, this.touchState.targetTouchZone, TouchZoneFilters.EXIT, x, y, false);
        }

        // Handle ENTRY to new touchZone
        if (currentTouchZone && (currentTouchZone.filter & TouchZoneFilters.ENTRY)) {
          // Only trigger ENTRY once per touch sequence for this zone
          if (!this.touchState.hasEnteredZones.has(currentTouchZone)) {
            console.log(`ENTRY to touchZone: cmd=${currentTouchZone.cmd}`);
            window.pfodWebMouse.handleTouchZoneActivation.call(this, currentTouchZone, TouchZoneFilters.ENTRY, x, y, false);
            this.touchState.hasEnteredZones.add(currentTouchZone);
          }
        }

        this.touchState.targetTouchZone = currentTouchZone;
      }

      // Handle DRAG events for current touchZone
      if (currentTouchZone && (currentTouchZone.filter & TouchZoneFilters.DRAG)) {
        console.warn(`[MOUSE_DRAG] DRAG filter detected - calling handleTouchZoneActivation for cmd=${currentTouchZone.cmd}`);
        window.pfodWebMouse.handleTouchZoneActivation.call(this, currentTouchZone, TouchZoneFilters.DRAG, x, y);
      } else if (currentTouchZone) {
        console.log(`[MOUSE_DRAG] TouchZone found but no DRAG filter - filter=${currentTouchZone.filter}, DRAG=${TouchZoneFilters.DRAG}`);
        console.log(`[MOUSE_DRAG] Binary check: (${currentTouchZone.filter} & ${TouchZoneFilters.DRAG}) = ${currentTouchZone.filter & TouchZoneFilters.DRAG}`);
      }
      // Handle DRAG events for current touchZone
      if (currentTouchZone && (currentTouchZone.filter & TouchZoneFilters.DOWN_DRAG_UP)) {
        console.log(`[MOUSE_DRAG] DOWN_DRAG_UP filter detected - calling handleTouchZoneActivation for cmd=${currentTouchZone.cmd}`);
        window.pfodWebMouse.handleTouchZoneActivation.call(this, currentTouchZone, TouchZoneFilters.DRAG, x, y,false); // show but not send
      } else if (currentTouchZone) {
        console.log(`[MOUSE_DRAG] TouchZone found but no DOWN_DRAG_UP filter - filter=${currentTouchZone.filter}, DOWN_DRAG_UP=${TouchZoneFilters.DOWN_DRAG_UP}`);
        console.log(`[MOUSE_DRAG] Binary check: (${currentTouchZone.filter} & ${TouchZoneFilters.DOWN_DRAG_UP}) = ${currentTouchZone.filter & TouchZoneFilters.DOWN_DRAG_UP}`);
      }

      // Check if we've left the original touchzone that started the drag
      if (this.touchState.targetTouchZone && !currentTouchZone) {
        console.warn('[MOUSE_DRAG] Left original touchzone area - restoring touchActions and processing pending responses');

        // Restore from any active touchActions FIRST to get back to basic state

        // THEN process any pending responses
        if (this.pendingResponseQueue.length > 0) {
          this.processPendingResponses();
        }

        // Reset mouse state since we've left the drag area
        this.touchState.wasDown = this.touchState.isDown;
        this.touchState.isDown = false;
        this.touchState.targetTouchZone = null;
        this.touchState.hasEnteredZones.clear();
      }
    }
  },

  handleMouseUp: function(e) {
    if (!this.touchState.isDown) return;

    // Get canvas-relative coordinates and scale factors
    const scale = window.pfodWebMouse.getCanvasScale.call(this);
    const x = (e.clientX - scale.rect.left) / scale.scaleX;
    const y = (e.clientY - scale.rect.top) / scale.scaleY;

    // Cancel long press timer if active
    if (this.touchState.longPressTimer) {
      clearTimeout(this.touchState.longPressTimer);
      this.touchState.longPressTimer = null;
    }

    // Handle UP and DOWN_DRAG_UP events for current touchZone
    if (this.touchState.targetTouchZone) {
      // Handle UP filter - Works
      if (this.touchState.targetTouchZone.filter & TouchZoneFilters.UP) {
        console.log(`Mouse UP in touchZone: cmd=${this.touchState.targetTouchZone.cmd}`);
        window.pfodWebMouse.handleTouchZoneActivation.call(this, this.touchState.targetTouchZone, TouchZoneFilters.UP, x, y);
      }

      // Handle DOWN_DRAG_UP filter - only sends on finger up - Works
      if (this.touchState.targetTouchZone.filter & TouchZoneFilters.DOWN_DRAG_UP) {
        console.log(`DOWN_UP in touchZone: cmd=${this.touchState.targetTouchZone.cmd}`);
        window.pfodWebMouse.handleTouchZoneActivation.call(this, this.touchState.targetTouchZone, TouchZoneFilters.DOWN_DRAG_UP, x, y);
      }
    }

    // Reset touch state FIRST to allow final redraw
    console.log(`[MOUSE_UP] Setting touchState.isDown = false`);
    this.touchState.wasDown = this.touchState.isDown;
    this.touchState.isDown = false;

    // Check if we have touchAction backup that needs to be restored
    if (window.pfodWebMouse.touchActionBackups) {
      console.log(`[MOUSE_UP] TouchAction backup exists - should restore original data before processing responses`);
      console.log(`[MOUSE_UP] Backup contains: unindexed=${window.pfodWebMouse.touchActionBackups.allUnindexedItems?.length || 0}, indexed=${Object.keys(window.pfodWebMouse.touchActionBackups.allIndexedItemsByNumber || {}).length}`);
    } else {
      console.log(`[MOUSE_UP] No touchAction backup exists`);
    }

    // THEN process any pending responses that were queued while mouse was down
    this.processPendingResponses();
    this.touchState.targetTouchZone = null;
    this.touchState.hasEnteredZones.clear();
  },

  handleMouseLeave: function(e) {
    console.log('[MOUSE_LEAVE] Mouse left canvas area');
    if (this.touchState.isDown) {
      console.log('[MOUSE_LEAVE] Mouse was down - restoring touchActions and processing pending responses');


      // THEN process any pending responses
      if (this.pendingResponseQueue.length > 0) {
        this.processPendingResponses();
      }

      // Reset touch state
      this.touchState.wasDown = this.touchState.isDown;
      this.touchState.isDown = false;
      this.touchState.targetTouchZone = null;
      this.touchState.hasEnteredZones.clear();
    }
  },

  handleClick: function(e) {
    // Check if mouse was held down for longer than PRESS timeout (700ms)
    // If so, ignore this click as it was a long press
    const currentTime = Date.now();
    const pressDuration = currentTime - this.touchState.startTime;
    if (pressDuration >= 700) {
      console.log(`Ignoring click - mouse was held down for ${pressDuration}ms (long press)`);
      this.touchState.hasDragged = false;
      return;
    }

    // Get canvas-relative coordinates and scale factors
    const scale = window.pfodWebMouse.getCanvasScale.call(this);
    const x = (e.clientX - scale.rect.left) / scale.scaleX;
    const y = (e.clientY - scale.rect.top) / scale.scaleY;

    let minTouch_mm = 9;
    let minPercent = 2 / 100;
    let colPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4); // half 9mm to add to both sides
    let rowPixelsHalf9mm = (96 * minTouch_mm) / (2 * 25.4);
    if ((scale.rect.width * minPercent) > colPixelsHalf9mm) {
      colPixelsHalf9mm = scale.rect.width * minPercent;
    }
    if ((scale.rect.height * minPercent) > rowPixelsHalf9mm) {
      rowPixelsHalf9mm = scale.rect.height * minPercent;
    }
    console.log(`CLICK in touchZone: enlarge by ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);
    colPixelsHalf9mm = colPixelsHalf9mm / scale.scaleX;
    rowPixelsHalf9mm = rowPixelsHalf9mm / scale.scaleX;
    console.log(`CLICK in touchZone: canvas ${scale.rect.width} x ${scale.rect.height}`);
    console.log(`CLICK in touchZone: enlarge by dwg coords ${colPixelsHalf9mm} x ${rowPixelsHalf9mm}`);

    // Find touchZone at click position
    const touchZone = window.pfodWebMouse.findTouchZoneAt.call(this, x, y, colPixelsHalf9mm, rowPixelsHalf9mm);

    // Handle basic CLICK event without drag
    if (!this.touchState.hasDragged) {
      if (touchZone) {
        // Handle CLICK filter
        if (touchZone && (touchZone.filter & TouchZoneFilters.CLICK)) {
          console.log(`CLICK in touchZone: cmd=${touchZone.cmd}`);
          window.pfodWebMouse.handleTouchZoneActivation.call(this, touchZone, TouchZoneFilters.CLICK, x, y, false);
          if (this.touchState.clickTimer) {
           clearTimeout(this.touchState.clickTimer);
          }

          // Set a timer for display of click touchActions (100ms is standard)
          this.touchState.clickTimer = setTimeout(() => {
            window.pfodWebMouse.handleTouchZoneActivation.call(this, touchZone, TouchZoneFilters.CLICK, this.touchState.lastX, this.touchState.lastY);
          }, 100);
          return;
        } 
      } else {
        // Special case: no touchZones defined or clicked outside all touchZones
        // Only send update request if no touchZones are defined
        const hasTouchZones = Object.keys(window.pfodWebMouse.touchActionBackups.allTouchZonesByCmd).length > 0;

        if (!hasTouchZones) {
          // No touchZones defined, so queue a general update request
          console.log("No touchZones defined - requesting general update on click");

          // Queue a general update request
          this.queueDrawingUpdate(window.pfodWebMouse.touchActionBackups.currentDrawingName);
        } else {
          console.log("Touch outside defined touchZones - ignoring");
        }
      }
    }

    // Safety net: Restore touchActions and process any pending responses if mouse state got out of sync

    if (this.pendingResponseQueue.length > 0) {
      console.log(`[QUEUE] Safety net: Processing ${this.pendingResponseQueue.length} pending responses in handleClick`);
      this.processPendingResponses();
    }

    // Reset drag state
    this.touchState.hasDragged = false;
  },

  // Find touchZone containing specified coordinates (instance method)
  // touchZone object
  //    touchZoneObject = {
  //        type: "touchZone",
  //        xSize: xSize,
  //        ySize: ySize,
  //        cmd: cmd,
  //        idx: idx
  //        xOffset: xOffset,
  //        yOffset: yOffset,
  //        filter: filter,
  //        centered: "true"
  //    }
  
  // row col extra in dwg coords
  findTouchZoneAt: function(x, y, colExtra, rowExtra) { 
    console.warn(`[FIND_TOUCH_ZONE] findTouchZoneAt called with x:${x} y:${y} colExtra:${colExtra} rowExtra:${rowExtra}`);

    // Collect all visible touchZones
    let visibleTouchZones = [];

    //always use touchActionBackups
    
    // Create array from touchZonesByCmd values
    // Debug check for undefined issues during drag
//    if (!this.redraw) {
//        console.error(`[FIND_TOUCH_ZONE] this.redraw is undefined`);
//        return null;
 //   }
    
    const allTouchZones = window.pfodWebMouse.touchActionBackups?.allTouchZonesByCmd;
    console.log(`[FIND_TOUCH_ZONE] DEBUG allTouchZonesByCmd returned ${Object.keys(allTouchZones || {}).length} touchZones:`, Object.keys(allTouchZones || {}));
    if (allTouchZones === undefined) {
        console.error(`[FIND_TOUCH_ZONE] allTouchZonesByCmd returned undefined during ${this.touchState?.isDown ? 'DRAG' : 'NORMAL'} operation`);
        return null;
    }
    for (const cmd in allTouchZones) {
      const zone = allTouchZones[cmd];

      // Only include visible and non-disabled zones
      if (zone.visible !== false && zone.filter !== TouchZoneFilters.TOUCH_DISABLED) {
        visibleTouchZones.push(zone);
      }
    }
    console.warn(`[FIND_TOUCH_ZONE] number of visible touchZones ${visibleTouchZones.length}`);

    // Sort by idx (high idx first) last one wins if it over lays earlier one
    //visibleTouchZones.sort((a, b) => (b.idx || 0) - (a.idx || 0));

    // returns -ve if outside rect else min (x-x_middle,y-y_middle)
    // Check if point is inside any touchZone
    let currentZone = null;
    let currentBounds = null;
    let current_colMin = 0;
    let current_rowMin = 0;
    for (const zone of visibleTouchZones) {
      // Calculate touchZone bounds in dwg coords
      let bounds = window.pfodWebMouse.calculateTouchZoneBounds.call(this, zone);
      // apply min extra
      bounds.left -= colExtra;
      bounds.right += colExtra;
      bounds.top -= rowExtra;
      bounds.bottom += rowExtra;
      bounds.width = bounds.right - bounds.left;
      bounds.height = bounds.bottom - bounds.top;
      console.warn(`[FIND_TOUCH_ZONE] TouchZone: cmd=${zone.cmd}, left:${bounds.left} right:${bounds.right} top:${bounds.top} bottom:${bounds.bottom}`);
      // Check if point is inside bounds
      let insideZone = (x >= bounds.left && x <= bounds.left + bounds.width &&
        y >= bounds.top && y <= bounds.top + bounds.height);
      if (!insideZone) {
        continue;
      }
      colMin = Math.min(x - bounds.left, bounds.right - x); // closest col to edge
      rowMin = Math.min(y - bounds.top, bounds.bottom - y); // closest row to edge
      if (currentZone == null) {
        // make sure these are set for rect compare on next call
        currentZone = zone;
        current_colMin = colMin;
        current_rowMin = rowMin;
        currentBounds = bounds;
         console.warn(`[FIND_TOUCH_ZONE] TouchZone: cmd=${currentZone.cmd}, colMin:${colMin} rowMin:${rowMin})`);
        continue;
      } else { // have current
        let currentIdx = currentZone.idx;
        let thisIdx = zone.idx;
        if (currentIdx != thisIdx) {
          if (currentIdx > thisIdx) {
            // currentZone; // wins
            continue;
          } else if (thisIdx > currentIdx) {
            currentZone = zone;
            current_colMin = colMin;
            current_rowMin = rowMin;
            currentBounds = bounds;
            continue;
          }
        } else { // same idx so compare overlaps  
           console.warn(`[FIND_TOUCH_ZONE] TouchZone: cmd=${zone.cmd}, colMin:${colMin} rowMin:${rowMin})`);

          // else // continue to check overlaps
          // Returns true if `a` contains `b`
          // if current contains this return current
          // i.e. larger rect sits over smaller one but only if it completely covers it.
          // used for dragging
          // normally touchZones do not have/need indices
          // this approach allows you to put a whole dwg touchZone over other dwgs and
          // then click and drag them (identified by their position on the dwg)
          // without triggering the underlying dwgs own touchZones.
          //
          // touchZones ordered in the order they (first) arrived
          // if a late touchZone exactly overlays an earlier on the later (higher) touchZone is the active one!!
          // NOTE: rectf can have -ve values It is not limited to screen
          const contains = (a, b) => a.left <= b.left && a.top <= b.top && a.right >= b.right && a.bottom >= b.bottom;
          if (contains(zone, currentZone)) { // later zone contains earlier
            currentZone = zone;
            current_colMin = colMin;
            current_rowMin = rowMin;
            currentBounds = bounds;
            continue;
          } else if (contains(currentZone, zone)) {
            // no change
            continue;
          } else {
            // check overlap for best fit
            // else compare based on min overlap dimension
            // x_overlap = Math.max(0, Math.min(x12,x22) - Math.max(x11,x21));
            // y_overlap = Math.max(0, Math.min(y12,y22) - Math.max(y11,y21));
            // x11 = left y11 = top x12 = right, y12 = bottom
            // MUST overlap since point in both so can skip Math.max(0...
            let colOverlap = Math.min(bounds.right, currentBounds.right) - Math.max(bounds.left, currentBounds.left);
            let rowOverlap = Math.min(bounds.bottom, currentBounds.bottom) - Math.max(bounds.top, currentBounds.top);
            // console.warn(`[FIND_TOUCH_ZONE] colOverlap:${colOverlap} rowOverlap:${rowOverlap})`);

            let compareCol = true;
            // need this for long rectangles
            if (colOverlap == rowOverlap) {
              // check both dimensions point in col dimension
              let col_min = Math.min(current_colMin, colMin);
              let row_min = Math.min(current_rowMin, rowMin);
              // console.warn(`[FIND_TOUCH_ZONE] col_min:${col_min} row_min:${row_min})`);
              if (col_min < row_min) {
                // since overlap equal then this also implies col_max > row_max
                // closest to col boundry
                // compareCol == true;
              } else {
                compareCol = false;
              }
            } else if (colOverlap < rowOverlap) {
              // compareCol == true;
            } else {
              compareCol = false;
            }
            if (compareCol) {
              // check point in col dimension
              if (current_colMin <= colMin) {
                // nearer edge of current so choose this
                // if equal later ones take precedence
                currentZone = zone;
                current_colMin = colMin;
                current_rowMin = rowMin;
                currentBounds = bounds;
              } else {
                // return current;
              }
            } else {
              // check point in row dimension
              if (current_rowMin <= rowMin) {
                // nearer edge of current so choose this
                currentZone = zone;
                current_colMin = colMin;
                current_rowMin = rowMin;
                currentBounds = bounds;
              } else {
                // return current;
              }
            }
          }
        }
      }
    }
    if (currentZone) {
      console.warn(`[FIND_TOUCH_ZONE] returning TouchZone: cmd=${currentZone.cmd}`);
    } else {
      console.warn(`[FIND_TOUCH_ZONE] returning TouchZone: null`);
    }
    return currentZone; // the one found
  },

  // Calculate the bounds of a touchZone in canvas coordinates (instance method)
  // left, right, top, bottom
  calculateTouchZoneBounds: function(zone) {
    // Get the transform
    const transform = zone.transform || {
      x: 0,
      y: 0,
      scale: 1.0
    };

    // Get properties with defaults
    const xOffset = parseFloat(zone.xOffset || 0);
    const yOffset = parseFloat(zone.yOffset || 0);
    const xSize = parseFloat(zone.xSize || 1); // min size is 1
    const ySize = parseFloat(zone.ySize || 1);
    const centered = zone.centered === 'true' || zone.centered === true;

    // Apply transform scale
    const scaledXOffset = xOffset * transform.scale;
    const scaledYOffset = yOffset * transform.scale;
    const scaledXSize = xSize * transform.scale;
    const scaledYSize = ySize * transform.scale;

    // Calculate bounds based on centered property
    let x, y, width, height;

    if (centered) {
      // For centered zones, center point is at the offset
      x = transform.x + scaledXOffset - Math.abs(scaledXSize) / 2;
      y = transform.y + scaledYOffset - Math.abs(scaledYSize) / 2;
      width = Math.abs(scaledXSize);
      height = Math.abs(scaledYSize);
    } else {
      // For non-centered zones, handle negative sizes
      if (scaledXSize >= 0) {
        x = transform.x + scaledXOffset;
        width = scaledXSize;
      } else {
        x = transform.x + scaledXOffset + scaledXSize; // Move start point left
        width = Math.abs(scaledXSize);
      }

      if (scaledYSize >= 0) {
        y = transform.y + scaledYOffset;
        height = scaledYSize;
      } else {
        y = transform.y + scaledYOffset + scaledYSize; // Move start point up
        height = Math.abs(scaledYSize);
      }
    }

    //        return { x, y, width, height };
    let left = x;
    let right = x + width;
    let top = y;
    let bottom = y + height;
    return {
      left,
      right,
      top,
      bottom,
      width,
      height
    };
  },

  // Handle touchZone activation by queueing a request (instance method)
  handleTouchZoneActivation: function(touchZone, touchType, x, y, sendMsg = true) {
    if (!touchZone.cmd) return;

    // Skip disabled touchZones
    if (touchZone.filter & TouchZoneFilters.TOUCH_DISABLED) return;

    // Calculate touchZone bounds in canvas coordinates left, rigth, top, bottom, width, height
    const bounds = window.pfodWebMouse.calculateTouchZoneBounds.call(this, touchZone);
    // apply min extra
    //    bounds.left -= colHalf9mm;
    //    bounds.right += colHalf9mm;
    //    bounds.top -= rowHalf9mm;
    //    bounds.bottom += rowHalf9mm;
    //    bounds.width = bounds.right - bounds.left;
    //    bounds.height = bounds.bottom - bounds.top;

    // Get the original touchZone dimensions (unscaled)
    const xSize = parseFloat(touchZone.xSize || 1);
    const ySize = parseFloat(touchZone.ySize || 1);

    // Convert global coordinates to touchZone-relative coordinates
    // First, get the position within the rendered (scaled) touchZone
    const relativeX = x - bounds.left;
    const relativeY = y - bounds.top;

    // Scale back to the original touchZone coordinate system
    // This ensures coordinates range from 0,0 to width,height regardless of scaling
    const scaledCol = (relativeX / bounds.width) * Math.abs(xSize);
    const scaledRow = (relativeY / bounds.height) * Math.abs(ySize);

    // Round to nearest integer
    let col = Math.round(scaledCol);
    let row = Math.round(scaledRow);
    // limit to zone size
    if (col < 0) {
      col = 0;
    }
    if (row < 0) {
      row = 0;
    }
    if (col > xSize) {
      col = xSize;
    }
    if (row > ySize) {
      row = ySize;
    }

    console.log(`[TOUCH_ZONE} TouchZone activated: cmd=${touchZone.cmd}, touchType=${touchType}`);
    console.log(`Global coords: (${x}, ${y}), TouchZone bounds: (${bounds.left}, ${bounds.top}, ${bounds.width}, ${bounds.height})`);
    console.log(`Original size: ${xSize}x${ySize}, Displayed size: ${bounds.width}x${bounds.height}`);
    console.log(`Relative coords: (${relativeX}, ${relativeY}), Scaled: (${scaledCol}, ${scaledRow})`);
    console.log(`[TOUCH_ZONE]  Rounded to nearest int: col=${col}, row=${row} (range 0,0 to ${xSize},${ySize})`);

    // Get the drawing name
    const drawingName = window.pfodWebMouse.touchActionBackups.currentDrawingName; //touchZone.drawingName || 

    // Check for touchActionInput first - it runs before other touchActions
    const touchActionInput = window.pfodWebMouse.touchActionBackups.allTouchActionInputsByCmd[touchZone.cmd];
    if (touchActionInput) {
      console.log(`[TOUCH_ACTION_INPUT] Found touchActionInput for cmd=${touchZone.cmd}`);
      window.pfodWebMouse.executeTouchActionInput.call(this, drawingName, touchZone.cmd, touchActionInput, col, row, touchType);
      return; // touchActionInput handles its own execution flow
    }

    // Execute touchAction if it exists for this cmd clears before starting
    window.pfodWebMouse.executeTouchAction.call(this, drawingName, touchZone.cmd, col, row, touchType);
    if (sendMsg) {
      // Build the command for the touchZone event
      // For touchZone actions, include col, row, touchType inside the command
      // Use dynamic identifier from calling context (this.currentIdentifier)
      const identifier = this.currentIdentifier || 'pfodWeb';
      let touchZoneCmd = `{${identifier}~${touchZone.cmd}\`${col}\`${row}\`${touchType}}`;

      // Add version to command if available
      const savedVersion = localStorage.getItem(`${drawingName}_version`);
      console.log(`[TOUCH_ACTION_QUEUE] drawingName: ${drawingName}, savedVersion: "${savedVersion}"`);
      if (savedVersion !== null) {
        touchZoneCmd = '{' + savedVersion + ':' + touchZoneCmd.substring(1);
        console.log(`[TOUCH_ACTION_QUEUE] Added version to command: ${touchZoneCmd}`);
      }

      console.log(`[TOUCH_ACTION_QUEUE] command: ${touchZoneCmd}`);

      // Set up request options - will be corrected by addToRequestQueue for cross-origin
      const options = {
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        mode: 'same-origin',
        credentials: 'same-origin',
        cache: 'no-cache'
      };

      // Add to the request queue with touchZone info for drag optimization
      this.addToRequestQueue(drawingName, touchZoneCmd, options, {
        cmd: touchZone.cmd,
        filter: touchType
      }, 'touch');
    }
  },

  // Execute touchAction when touchZone is activated
  executeTouchAction: function(drawingName, cmd, col, row, touchType) {
    console.log(`[TOUCH_ACTION] executeTouchAction Checking for touchAction: drawing=${drawingName}, cmd=${cmd} touchType=${touchType}`);

    // REQUIREMENT: Always start from basic (untouched) drawing
    // Only make backup once - don't restore during drag operations

    // Get the touchAction for this cmd from merged data
    const allTouchActionsByCmd = window.pfodWebMouse.touchActionBackups.allTouchActionsByCmd;
    console.log(`[TOUCH_ACTION] Available touchActions:`, Object.keys(allTouchActionsByCmd));
    const touchActions = allTouchActionsByCmd[cmd];

    if (!touchActions || touchActions.length === 0) {
      console.log(`[TOUCH_ACTION] No touchAction found for cmd=${cmd}, drawing=${drawingName}`);
      return;
    }

    console.log(`[TOUCH_ACTION] Found touchAction with ${touchActions.length} actions for cmd=${cmd}, touchType=${touchType}`);
    console.log(`[TOUCH_ACTION] TouchActions for cmd=${cmd}:`, touchActions);

    

    // Get the backup before creating the pseudo response
    const backup = window.pfodWebMouse.touchActionBackups;
    console.log(`[TOUCH_ACTION] Backup exists:`, !!backup);
    if (backup) {
      console.log(`[TOUCH_ACTION] Backup contains: unindexed=${backup.allUnindexedItems?.length || 0}, indexed=${Object.keys(backup.allIndexedItemsByNumber || {}).length}, touchZones=${Object.keys(backup.allTouchZonesByCmd || {}).length}`);
    }
    
    // Create a pseudo update response with the touchAction items
    const pseudoUpdateResponse = {
      pfodDrawing: 'update',
      name: drawingName,
      items: touchActions.map(actionItem => {
        const item = JSON.parse(JSON.stringify(actionItem));
        
        if (item.idx !== undefined) {
          const backupIndexedItem = backup.allIndexedItemsByNumber[item.idx];
          if (!backupIndexedItem) {
            console.error(`[TOUCH_ACTION] Processing touchAction but no dwg item for this index`, JSON.stringify(item,null,2));
            return null; // Return null for invalid items, they'll be filtered out
          }
          console.warn(`[TOUCH_ACTION] Processing touchAction to update `, JSON.stringify(backupIndexedItem,null,2));
          
          // Apply special touchZone values if they exist (support both string and numeric formats)
          if (item.xOffset === 'COL' || item.xOffset === TouchZoneSpecialValues.TOUCHED_COL) {
            item.xOffset = col;
            console.log(`[TOUCH_ACTION] Replaced xOffset COL with ${col}`);
          } else if (item.xOffset === 'ROW' || item.xOffset === TouchZoneSpecialValues.TOUCHED_ROW) {
            item.xOffset = row;
            console.log(`[TOUCH_ACTION] Replaced xOffset ROW with ${row}`);
          }
          if (item.yOffset === 'ROW' || item.yOffset === TouchZoneSpecialValues.TOUCHED_ROW) {
            item.yOffset = row;
            console.log(`[TOUCH_ACTION] Replaced yOffset ROW with ${row}`);
          } else if (item.yOffset === 'COL' || item.yOffset === TouchZoneSpecialValues.TOUCHED_COL) {
            item.yOffset = col;
            console.log(`[TOUCH_ACTION] Replaced yOffset COL with ${col}`);
          }

                    // Apply special touchZone values if they exist (support both string and numeric formats)
          if (item.xSize === 'COL' || item.xSize === TouchZoneSpecialValues.TOUCHED_COL) {
            item.xSize = col;
            console.log(`[TOUCH_ACTION] Replaced xSize COL with ${col}`);
          } else if (item.xSize === 'ROW' || item.xSize === TouchZoneSpecialValues.TOUCHED_ROW) {
            item.xSize = row;
            console.log(`[TOUCH_ACTION] Replaced xSize ROW with ${row}`);
          }
          if (item.ySize === 'ROW' || item.ySize === TouchZoneSpecialValues.TOUCHED_ROW) {
            item.ySize = row;
            console.log(`[TOUCH_ACTION] Replaced ySize ROW with ${row}`);
          } else if (item.ySize === 'COL' || item.ySize === TouchZoneSpecialValues.TOUCHED_COL) {
            item.ySize = col;
            console.log(`[TOUCH_ACTION] Replaced ySize COL with ${col}`);
          }

          // Apply special touchZone values for intValue if item is a value type
          if (item.type === 'value' && item.intValue !== undefined) {
            if (item.intValue === 'COL' || item.intValue === TouchZoneSpecialValues.TOUCHED_COL) {
              item.intValue = col;
              console.log(`[TOUCH_ACTION] Replaced intValue COL with ${col}`);
            } else if (item.intValue === 'ROW' || item.intValue === TouchZoneSpecialValues.TOUCHED_ROW) {
              item.intValue = row;
              console.log(`[TOUCH_ACTION] Replaced intValue ROW with ${row}`);
            }
          }

          // Add transform and clipRegion from backup
          item.transform = backupIndexedItem.transform;// || { x: 0, y: 0, scale: 1 };
          item.clipRegion = backupIndexedItem.clipRegion;// || { x: 0, y: 0, width: 100, height: 20 };
          
          console.log(`[TOUCH_ACTION] Processing touchAction as pseudo update `, JSON.stringify(item,null,2));
          return item;
          
        } else {
          console.error(`[TOUCH_ACTION] Processing touchAction but it has no index`, JSON.stringify(item,null,2));
          return null; // Return null for items without index
        }
      }).filter(item => item !== null)
    };

    console.log(`[TOUCH_ACTION] Processing touchAction as pseudo update with ${pseudoUpdateResponse.items.length} items`);

    // Create a working copy of the backup to apply touchAction changes
    const workingCopy = {
      allUnindexedItems: JSON.parse(JSON.stringify(backup.allUnindexedItems)),
      allIndexedItemsByNumber: JSON.parse(JSON.stringify(backup.allIndexedItemsByNumber)),
      allTouchZonesByCmd: JSON.parse(JSON.stringify(backup.allTouchZonesByCmd))
    };
    console.log(`[TOUCH_ACTION_DEBUG] Created working copy - unindexed: ${workingCopy.allUnindexedItems.length}, indexed keys: [${Object.keys(workingCopy.allIndexedItemsByNumber).join(', ')}], touchZones: [${Object.keys(workingCopy.allTouchZonesByCmd).join(', ')}]`);


    // Apply touchAction changes to the working copy using the processed items from pseudoUpdateResponse
    pseudoUpdateResponse.items.forEach(processedItem => {
      console.log(`[TOUCH_ACTION] Applying processed item to working copy:`, JSON.stringify(processedItem, null, 2));
      
      // Handle hide/unhide items specially - they modify target item visibility instead of replacing the item
      if (processedItem.idx !== undefined) {
        if (processedItem.type === 'hide' || processedItem.type === 'unhide') {
          const targetItem = workingCopy.allIndexedItemsByNumber[processedItem.idx];
          if (targetItem) {
            const newVisible = (processedItem.type === 'unhide');
            console.log(`[TOUCH_ACTION] ${processedItem.type === 'unhide' ? 'Unhiding' : 'Hiding'} item ${processedItem.idx}: setting visible from ${targetItem.visible} to ${newVisible}`);
            targetItem.visible = newVisible;
          } else {
            console.warn(`[TOUCH_ACTION] ${processedItem.type} operation: No item found with idx=${processedItem.idx} to ${processedItem.type === 'unhide' ? 'unhide' : 'hide'}`);
          }
        } else {
          // Normal item replacement for non-hide/unhide items
          workingCopy.allIndexedItemsByNumber[processedItem.idx] = processedItem;
          console.log(`[TOUCH_ACTION] Updated working copy indexed item ${processedItem.idx} with processed touchAction item`);
          console.log(`[TOUCH_ACTION_DEBUG] Working copy item ${processedItem.idx} after update:`, JSON.stringify(workingCopy.allIndexedItemsByNumber[processedItem.idx], null, 2));
        }
      }
    });


    // Trigger a redraw to show the touchAction effects using the new direct redraw method
    console.log(`[TOUCH_ACTION] Triggering redraw to display touchAction effects using working copy`);
    console.log(`[TOUCH_ACTION] Working copy contains: unindexed=${workingCopy.allUnindexedItems.length}, indexed=${Object.keys(workingCopy.allIndexedItemsByNumber).length}, touchZones=${Object.keys(workingCopy.allTouchZonesByCmd).length}`);
    this.redraw.redrawWithWorkingCopy(workingCopy);
    console.log(`[TOUCH_ACTION] Redraw completed`);
  },

  // Execute touchActionInput - opens text dialog and handles response
  executeTouchActionInput: function(drawingName, cmd, touchActionInput, col, row, touchType) {
    console.log(`[TOUCH_ACTION_INPUT] Executing touchActionInput: cmd=${cmd}, prompt="${touchActionInput.prompt}", textIdx=${touchActionInput.textIdx}`);

    // Get initial text from textIdx if specified
    let initialText = '';
    if (touchActionInput.textIdx !== undefined && touchActionInput.textIdx !== null) {
      const indexedItems = window.pfodWebMouse.touchActionBackups.allIndexedItemsByNumber;
      const item = indexedItems[touchActionInput.textIdx];
      if (item && (item.type === 'label' || item.type === 'value')) {
        if (item.type === 'label') {
          // Generate label text using same utility as drawLabel and displayTextUtils
          initialText = addFormattedValueToText(item.text || '', item);
        } else if (item.type === 'value') {
          // For value items, get the displayed text (prefix + scaled value + units)
          const prefix = item.text || '';
          const intValue = parseFloat(item.intValue || 0);
          const min = parseFloat(item.min || 0);
          const max = parseFloat(item.max || 1);
          const displayMin = parseFloat(item.displayMin || 0.0);
          const displayMax = parseFloat(item.displayMax || 1.0);
          const decimals = parseInt(item.decimals || 2);
          const units = item.units || '';

          // Calculate scaled value using same logic as drawValue
          let maxMin = max - min;
          if (maxMin === 0) maxMin = 1;
          const scaledValue = (intValue - min) * (displayMax - displayMin) / maxMin + displayMin;

          initialText = prefix + printFloatDecimals(scaledValue, decimals) + units;
        }
        console.log(`[TOUCH_ACTION_INPUT] Retrieved initial text from textIdx ${touchActionInput.textIdx} (${item.type}): "${initialText}"`);
      } else {
        console.log(`[TOUCH_ACTION_INPUT] textIdx ${touchActionInput.textIdx} not found or not label/value, using blank text`);
      }
    }

    // Create and show text input dialog with formatting options
    const formatOptions = {
      fontSize: touchActionInput.fontSize,
      color: touchActionInput.color,
      backgroundColor: touchActionInput.backgroundColor
    };
    console.log(`[TOUCH_ACTION_INPUT] Format options:`, formatOptions);
    window.pfodWebMouse.showTextInputDialog.call(this, touchActionInput.prompt, initialText, formatOptions, (result, text) => {
      console.log(`[TOUCH_ACTION_INPUT] Dialog result: ${result}, text: "${text}"`);

      if (result === 'ok') {
        // Build command with the edited text included
        // For touchActionInput, include col, row, touchType, and editedText inside the command
        // Use dynamic identifier from calling context (this.currentIdentifier)
        const identifier = this.currentIdentifier || 'pfodWeb';
        let touchZoneCmd = `{${identifier}~${cmd}\`${col}\`${row}\`${touchType}~${text}}`;

        // Add version to command if available
        const savedVersion = localStorage.getItem(`${drawingName}_version`);
        console.log(`[TOUCH_ACTION_INPUT] drawingName: ${drawingName}, savedVersion: ${savedVersion}`);
        if (savedVersion !== null) {
          touchZoneCmd = '{' + savedVersion + ':' + touchZoneCmd.substring(1);
          console.log(`[TOUCH_ACTION_INPUT] Added version to command: ${touchZoneCmd}`);
        }

        console.log(`[TOUCH_ACTION_INPUT] command: ${touchZoneCmd}`);
        console.log(`[TOUCH_ACTION_INPUT] Sending request with edited text: ${touchZoneCmd}`);

        // Queue the request with proper headers
        const options = {
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          mode: 'same-origin',
          credentials: 'same-origin',
          cache: 'no-cache'
        };
        this.addToRequestQueue(drawingName, touchZoneCmd, options, {
          cmd: cmd,
          filter: touchType
        }, 'touch');

        // After the text input is confirmed, run any other touchActions for this cmd
        // clears before starting to show actions
        window.pfodWebMouse.executeTouchAction.call(this, drawingName, cmd, col, row, touchType);
      } else {
        console.log(`[TOUCH_ACTION_INPUT] User cancelled text input, no request sent`);
      }
    });
  },

  // Show text input dialog within canvas bounds
  showTextInputDialog: function(prompt, initialText, formatOptions, callback) {
    // Handle the case where formatOptions is actually the callback (backward compatibility)
    if (typeof formatOptions === 'function') {
      callback = formatOptions;
      formatOptions = {};
    }
    console.log(`[DIALOG] showTextInputDialog called with prompt="${prompt}", formatOptions:`, formatOptions);
    // Remove any existing dialog
    window.pfodWebMouse.hideTextInputDialog.call(this);

    // Get canvas bounds for positioning
    const canvasRect = this.canvas.getBoundingClientRect();

    // Calculate dialog position within canvas bounds - reduced width by half
    const dialogWidth = Math.min(250, canvasRect.width * 0.4);
    const dialogHeight = 'auto'; // Let content determine height
    const dialogX = canvasRect.left + (canvasRect.width - Math.min(250, canvasRect.width * 0.4)) / 2;
    const dialogY = canvasRect.top + (canvasRect.height * 0.3); // Position higher for better visibility

    // Create dialog container
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.left = dialogX + 'px';
    dialog.style.top = dialogY + 'px';
    dialog.style.width = dialogWidth + 'px';
    dialog.style.minWidth = '150px';
    dialog.style.maxWidth = '250px';
    dialog.style.height = 'auto';
    dialog.style.minHeight = '150px';
    dialog.style.backgroundColor = '#f0f0f0';
    dialog.style.border = '2px solid #666';
    dialog.style.borderRadius = '8px';
    dialog.style.padding = '15px';
    dialog.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
    dialog.style.zIndex = '1000';
    dialog.style.fontFamily = 'Arial, sans-serif';
    dialog.style.fontSize = '14px';

    // Create title with formatting - match the non-modal preview styling
    const title = document.createElement('div');
    title.textContent = prompt;
    title.style.padding = '10px';
    title.style.marginBottom = '10px';
    title.style.borderRadius = '4px';
    title.style.wordWrap = 'break-word';

    // Apply formatting options if provided
    console.log(`[DIALOG] Applying formatting options:`, formatOptions);
    if (formatOptions.fontSize !== undefined) {
      const actualFontSize = getActualFontSizeForDialog(formatOptions.fontSize);
      console.log(`[DIALOG] Setting fontSize to ${actualFontSize}px (from relative ${formatOptions.fontSize})`);
      title.style.fontSize = actualFontSize + 'px';
    }
    if (formatOptions.color !== undefined) {
      try {
        const colorHex = convertColorToHex(formatOptions.color);
        console.log(`[DIALOG] Setting color to ${colorHex} (from ${formatOptions.color})`);
        title.style.color = colorHex;
      } catch (error) {
        console.error(`[DIALOG] Error getting color hex for ${formatOptions.color}:`, error);
        title.style.color = '#000';
      }
    } else {
      title.style.color = '#000';
    }
    if (formatOptions.backgroundColor !== undefined) {
      try {
        const bgColorHex = convertColorToHex(formatOptions.backgroundColor);
        console.log(`[DIALOG] Setting backgroundColor to ${bgColorHex} (from ${formatOptions.backgroundColor})`);
        title.style.backgroundColor = bgColorHex;
      } catch (error) {
        console.error(`[DIALOG] Error getting backgroundColor hex for ${formatOptions.backgroundColor}:`, error);
      }
    } else {
      // Default background color if none specified
      title.style.backgroundColor = '#ffffff';
    }

    dialog.appendChild(title);

    // Create text input
    const input = document.createElement('input');
    input.type = 'text';
    input.value = initialText;
    input.maxLength = 255;
    input.style.width = '100%';
    input.style.padding = '6px';
    input.style.fontSize = '14px';
    input.style.border = '1px solid #ccc';
    input.style.borderRadius = '4px';
    input.style.marginBottom = '10px';
    input.style.boxSizing = 'border-box';
    dialog.appendChild(input);

    // Create button container
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '10px';
    buttonContainer.style.justifyContent = 'space-between';

    // Create cancel button
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.style.padding = '8px 16px';
    cancelButton.style.border = '1px solid #666';
    cancelButton.style.borderRadius = '4px';
    cancelButton.style.backgroundColor = 'white';
    cancelButton.style.color = '#000';
    cancelButton.style.cursor = 'pointer';
    cancelButton.style.fontSize = '10px';

    // Create OK button with tick and blue background
    const okButton = document.createElement('button');
    okButton.textContent = '✓ OK';
    okButton.style.padding = '8px 16px';
    okButton.style.border = '1px solid #0066cc';
    okButton.style.borderRadius = '4px';
    okButton.style.backgroundColor = '#0066cc';
    okButton.style.color = 'white';
    okButton.style.cursor = 'pointer';
    okButton.style.fontSize = '10px';

    buttonContainer.appendChild(cancelButton);
    buttonContainer.appendChild(okButton);
    dialog.appendChild(buttonContainer);

    // Event handlers
    const handleOk = () => {
      const text = input.value;
      window.pfodWebMouse.hideTextInputDialog.call(this);
      callback('ok', text);
    };

    const handleCancel = () => {
      window.pfodWebMouse.hideTextInputDialog.call(this);
      callback('cancel', '');
    };

    okButton.addEventListener('click', handleOk);
    cancelButton.addEventListener('click', handleCancel);

    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        handleOk();
      } else if (e.key === 'Escape') {
        handleCancel();
      }
    });

    // Add to page and focus
    document.body.appendChild(dialog);
    input.focus();
    input.select();

    // Store reference
    this.textInputDialog = dialog;
  },

  // Hide text input dialog
  hideTextInputDialog: function() {
    if (this.textInputDialog) {
      document.body.removeChild(this.textInputDialog);
      this.textInputDialog = null;
    }
  },


};
</script>
<script>
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Loading files ...', canvas.width / 2, canvas.height / 2);
    </script>

    <div id="message-overlay">
        <h1 id="message-title"></h1>
        <p id="message-text"></p>
    </div>

    <div id="connection-prompt">
        <div class="prompt-container">
            <h2>pfodWebDebug Connection Setup</h2>
            <div style="color: #666; font-size: 12px; margin: -10px 0 10px 0;">
                <span id="connection-version">Loading...</span><br>
                (c)2025 <a href="https://www.forward.com.au/pfod/pfodWeb" target="_blank">https://www.forward.com.au/pfod/pfodWeb</a>
            </div>

            <div class="protocol-selector">
                <label><strong>Select Connection Protocol:</strong></label>
                <div class="protocol-options">
                    <div class="protocol-option">
                        <input type="radio" id="prompt-protocol-http" name="prompt-protocol" value="http" checked>
                        <label for="prompt-protocol-http">HTTP</label>
                    </div>
                    <div class="protocol-option">
                        <input type="radio" id="prompt-protocol-serial" name="prompt-protocol" value="serial">
                        <label for="prompt-protocol-serial">Serial</label>
                    </div>
                    <div class="protocol-option">
                        <input type="radio" id="prompt-protocol-ble" name="prompt-protocol" value="ble">
                        <label for="prompt-protocol-ble">BLE</label>
                    </div>
                </div>
            </div>

            <div class="connection-details">
                <!-- HTTP Settings -->
                <div id="http-settings" class="protocol-section visible">
                    <label for="prompt-ip">IP Address:</label><br>
                    <input type="text" id="prompt-ip" placeholder="192.168.1.100" maxlength="15">
                    <div class="help-text">Enter the IP address of your pfod device</div>
                </div>

                <!-- Serial Settings -->
                <div id="serial-settings" class="protocol-section">
                    <label for="prompt-baud">Baud Rate:</label><br>
                    <select id="prompt-baud">
                        <option value="" disabled>Select baud rate...</option>
                        <option value="9600">9600</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="74880">74880</option>
                        <option value="115200" selected>115200</option>
                    </select>
                    <div class="help-text">Select baud rate, then click Connect to choose serial port</div>
                </div>

                <!-- BLE Settings -->
                <div id="ble-settings" class="protocol-section">
                    <div class="help-text">Click Connect to scan for BLE devices</div>
                </div>

                <!-- Response Timeout (applies to all protocols) -->
                <div style="margin: 5px 0;">
                    <label for="prompt-timeout">Timeout (s):</label>
                    <select id="prompt-timeout" style="width: 80px;">
                        <option value="3">3</option>
                        <option value="5">5</option>
                        <option value="10" selected>10</option>
                        <option value="20">20</option>
                        <option value="30">30</option>
                    </select>
                </div>

                <button id="connect-button" onclick="connectWithPrompt()">Connect</button>
            </div>
        </div>
    </div>

    <!-- Load main application script which will load its dependencies -->
    <script>
        // Draggable divider for resizing canvas and message viewer
        let isDragging = false;
        const divider = document.getElementById('resize-divider');
        const layoutContainer = document.getElementById('layout-container');
        const canvasPane = document.getElementById('canvas-pane');
        const messageViewer = document.getElementById('raw-message-viewer');

        function setSplitRatio(ratio) {
          canvasPane.style.flex = ratio;
          messageViewer.style.flex = (1 - ratio);
        }

        // Hide divider and message viewer initially
        divider.style.display = 'none';
        messageViewer.style.display = 'none';

        // Set canvas to 100% width initially - viewer is hidden
        canvasPane.style.flex = 1;
        messageViewer.style.flex = 0;

        divider.addEventListener('mousedown', () => {
          isDragging = true;
          divider.classList.add('dragging');
          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'col-resize';
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;

          const rect = layoutContainer.getBoundingClientRect();
          const newCanvasWidth = e.clientX - rect.left;
          const containerWidth = rect.width;
          const newRatio = newCanvasWidth / containerWidth;

          // Constrain ratio between 40% and 90%
          const constrainedRatio = Math.max(0.40, Math.min(0.90, newRatio));
          setSplitRatio(constrainedRatio);
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            divider.classList.remove('dragging');
            document.body.style.userSelect = 'auto';
            document.body.style.cursor = 'auto';
          }
        });

        // Update connection prompt version on load and hide unavailable protocols
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof JS_VERSION !== 'undefined') {
                document.getElementById('connection-version').textContent = JS_VERSION;
            }
            // Hide protocol options that are not needed based on URL parameters
            hideUnavailableProtocols();
        });

        // Hide protocol options based on URL parameters
        function hideUnavailableProtocols() {
            const urlParams = new URLSearchParams(window.location.search);
            const hasTargetIP = urlParams.has('targetIP');
            const hasSerial = urlParams.has('serial');
            const hasBLE = urlParams.has('ble');

            const protocolOptions = document.querySelector('.protocol-options');
            const protocolSelectorLabel = document.querySelector('.protocol-selector label');

            if (hasTargetIP) {
                // Show HTTP label only, hide all radio buttons
                if (protocolOptions) protocolOptions.classList.add('hidden');
                if (protocolSelectorLabel) {
                    protocolSelectorLabel.innerHTML = '<strong>HTTP</strong>';
                    protocolSelectorLabel.style.fontSize = '1.25em';
                }
            } else if (hasSerial) {
                // Show Serial label only, hide all radio buttons
                if (protocolOptions) protocolOptions.classList.add('hidden');
                if (protocolSelectorLabel) {
                    protocolSelectorLabel.innerHTML = '<strong>Serial</strong>';
                    protocolSelectorLabel.style.fontSize = '1.25em';
                }
            } else if (hasBLE) {
                // Show BLE label only, hide all radio buttons
                if (protocolOptions) protocolOptions.classList.add('hidden');
                if (protocolSelectorLabel) {
                    protocolSelectorLabel.innerHTML = '<strong>BLE</strong>';
                    protocolSelectorLabel.style.fontSize = '1.25em';
                }
            }
        }

        // Connection prompt functions
        function updatePromptUI() {
            const protocol = document.querySelector('input[name="prompt-protocol"]:checked').value;
            document.getElementById('http-settings').classList.toggle('visible', protocol === 'http');
            document.getElementById('serial-settings').classList.toggle('visible', protocol === 'serial');
            document.getElementById('ble-settings').classList.toggle('visible', protocol === 'ble');
            validateConnectButton();
        }

        // Validate connect button state
        function validateConnectButton() {
            const protocol = document.querySelector('input[name="prompt-protocol"]:checked').value;
            const connectButton = document.getElementById('connect-button');

            if (protocol === 'http') {
                const ip = document.getElementById('prompt-ip').value.trim();
                connectButton.disabled = !ip || ip === '';
            } else if (protocol === 'serial') {
                const baudRate = document.getElementById('prompt-baud').value;
                connectButton.disabled = !baudRate || baudRate === '';
            } else {
                // BLE doesn't need validation
                connectButton.disabled = false;
            }
        }

        // Set up protocol radio listeners
        document.querySelectorAll('input[name="prompt-protocol"]').forEach(radio => {
            radio.addEventListener('change', updatePromptUI);
        });

        // Set up IP input listener
        document.getElementById('prompt-ip').addEventListener('input', validateConnectButton);

        // Set up baud rate change listener
        document.getElementById('prompt-baud').addEventListener('change', validateConnectButton);

        // Set up Enter key handler for the entire connection prompt
        document.getElementById('connection-prompt').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                const connectButton = document.getElementById('connect-button');
                if (!connectButton.disabled) {
                    connectWithPrompt();
                }
            }
        });

        async function connectWithPrompt() {
            const protocol = document.querySelector('input[name="prompt-protocol"]:checked').value;

            // Collect connection settings
            const connectionSettings = {
                protocol: protocol
            };

            // Get timeout setting (applies to all protocols)
            const timeoutValue = parseInt(document.getElementById('prompt-timeout').value, 10);
            if (!isNaN(timeoutValue)) {
                connectionSettings.responseTimeoutSec = timeoutValue;
            }

            // Validate and collect protocol-specific settings
            if (protocol === 'http') {
                const ip = document.getElementById('prompt-ip').value.trim();
                if (!ip) {
                    alert('Please enter an IP address');
                    return;
                }
                connectionSettings.targetIP = ip;
            } else if (protocol === 'serial') {
                const baudRate = document.getElementById('prompt-baud').value;
                connectionSettings.baudRate = parseInt(baudRate, 10);
            } else if (protocol === 'ble') {
                // No additional settings needed for BLE
            }

            // Create ConnectionManager for all protocols
            try {
                // Create ConnectionManager with the connection settings
                const tempConnectionManager = new ConnectionManager(connectionSettings);

                // For Serial and BLE, prompt for device selection NOW (before hiding prompt)
                if (protocol === 'serial' || protocol === 'ble') {
                    await tempConnectionManager.connect();
                    console.log('[CONNECT_PROMPT] Device selected and connected, proceeding...');
                }

                // Store the entire ConnectionManager for continueInitialization to use (for all protocols)
                // This preserves all protocol information and settings
                window.pfodConnectionManager = tempConnectionManager;
                console.log('[CONNECT_PROMPT] ConnectionManager stored, protocol:', protocol);
            } catch (error) {
                console.error('[CONNECT_PROMPT] Connection failed:', error);

                // Show error with Close button to return to connection setup
                pfodAlert(error.message, () => {
                    // Disable the unsupported protocol option
                    const radioButton = document.getElementById('prompt-protocol-' + protocol);
                    /**
                    if (radioButton) {
                        radioButton.disabled = true;
                        const label = document.querySelector(`label[for="prompt-protocol-${protocol}"]`);
                        if (label) {
                            label.style.color = '#999';
                            label.style.textDecoration = 'line-through';
                        }
                    }
                    **/

                    // Switch to HTTP protocol as default
                    document.getElementById('prompt-protocol-http').checked = true;
                    updatePromptUI();

                    // Show the connection prompt again
                    document.getElementById('connection-prompt').style.display = 'flex';
                });
                return;
            }

            // Hide the connection prompt
            document.getElementById('connection-prompt').style.display = 'none';

            // Continue initialization with settings
            if (typeof continueInitialization === 'function') {
                continueInitialization(connectionSettings);
            }
        }
    </script>

    
    
</body>
</html>